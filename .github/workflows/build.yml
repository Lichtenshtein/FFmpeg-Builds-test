name: Build FFmpeg

on:
  workflow_dispatch:
    inputs:
      ffmpeg_repo:
        description: 'FFmpeg Repository URL'
        default: 'https://github.com/MartinEesmaa/FFmpeg.git'
      ffmpeg_branch:
        description: 'FFmpeg Branch'
        default: 'master'
      only_stage:
        description: 'Regex for ONLY_STAGE: 10-mingw|50-x264'
        required: false
        default: '10-mingw-std-threads|10-mingw|15-base|16-libicu'
        # default: '.*'
      doClean:
        description: 'Clean cache before build (Full Rebuild)'
        type: boolean
        default: false
      use_lto:
        description: 'Enable LTO optimization'
        type: boolean
        default: false
      verbosity:
        description: 'Log Verbosity (1: Full, 0: Quiet)'
        required: false
        default: '1'
      debug_no_hash:
        description: 'Debug: Do not recalculate VARS_HASH (Preserve Docker cache)'
        type: boolean
        default: true
      skip_ffmpeg:
        description: 'Skip final FFmpeg compilation (Component test only)'
        type: boolean
        default: true
      dedupe_flags:
        description: 'Deduplicate LDFLAGS/LIBS (Disable if link errors occur)'
        type: boolean
        default: false
      use_wine:
        description: 'Enable Wine for tests/conftest (auto/on/off)'
        required: false
        default: 'auto'
      doRelease:
        description: 'Publish new release'
        type: boolean
        default: false
        required: false

env:
  DOCKER_BUILDKIT: 1
  TARGET: win64
  VARIANT: nonfree
  FFMPEG_REPO: ${{ github.event.inputs.ffmpeg_repo || 'https://github.com/MartinEesmaa/FFmpeg.git' }}
  FFMPEG_BRANCH: ${{ github.event.inputs.ffmpeg_branch || 'master' }}
  # Список для удаления лишних .git (в download.sh)
  GIT_PRESERVE_LIST: "ffmpeg|glib2|x264|x265|opus|vulkan-loader|mbedtls|pcre2|avisynth|openssl|pango|freetype|ilbc|libjxl|mbedtls|snappy|zimg|vmaf|dav1d|libplacebo"
  # Список для сохранения DLL (в run_stage.sh)
  DLL_PRESERVE_LIST: "openvino|torch|tensorflow|vulkan|amf|nvcodec|mfx|onevpl|glib2|leptonica-test|audiotoolbox|vapoursynth|vapoursynth-python-test"
  FFBUILD_VERBOSE: ${{ github.event.inputs.verbosity || '1' }}
  ONLY_STAGE: ${{ github.event.inputs.only_stage }}
  DEBUG_NO_HASH: ${{ github.event.inputs.debug_no_hash }}
  DEDUPE_FLAGS: ${{ github.event.inputs.dedupe_flags }}

jobs:
  build_all:
    name: Build FFmpeg Win64
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          buildkitd-flags: --debug

      - name: Install Host Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y subversion subversion-tools nasm yasm

      - name: Set Image Names
        id: images
        run: |
          REPO_LC="${GITHUB_REPOSITORY,,}"
          echo "repo_lc=ghcr.io/${REPO_LC}" >> $GITHUB_OUTPUT
          echo "base=ghcr.io/${REPO_LC}/base:latest" >> $GITHUB_OUTPUT
          echo "target_base=ghcr.io/${REPO_LC}/base-win64:latest" >> $GITHUB_OUTPUT

      - name: Login to Docker
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      ## This cleans ~24Gb
      # - name: Free Disk Space
        # uses: jlumbroso/free-disk-space@main
        # with:
          # tool-cache: true
          # android: true
          # dotnet: true
          # haskell: true
          # large-packages: true
          # docker-images: true
          # swap-storage: false

      ## This cleans ~400Mb
      # - name: Final Deep Clean and Space Check
        # run: |
          # sudo ionice -c 3 rm -rf /usr/share/dotnet &
          # sudo ionice -c 3 rm -rf /usr/local/lib/android &
          # sudo ionice -c 3 rm -rf /opt/ghc &
          # sudo ionice -c 3 rm -rf "/usr/local/share/boost" &
          # sudo ionice -c 3 rm -rf "$AGENT_TOOLSDIRECTORY" &
          # docker image prune -af &
          # wait
          # echo "--- FINAL DISK SPACE REPORT ---"
          # df -h /
          # echo "-------------------------------"

      - name: Build Root Base Image
        uses: docker/build-push-action@v5
        with:
          context: images/base
          build-args: |
            CARGO_C_VERSION=0.10.20
          tags: ${{ steps.images.outputs.repo_lc }}/base:latest
          # push: false
          push: true
          # load: true
          load: false
          cache-from: type=gha,scope=base-root
          # min сохраняет только слои, участвующие в финальном образе. max сохраняет все промежуточные слои (даже те, что в build-stage).
          cache-to: type=gha,mode=max,scope=base-root

      - name: Build Base Win64 Image
        uses: docker/build-push-action@v5
        with:
          context: images/base-win64
          build-args: |
            GH_REPO=${{ steps.images.outputs.repo_lc }}
          cache-from: type=gha,scope=base
          cache-to: type=gha,mode=max,scope=base
          # push: false
          push: true
          # load: true
          load: false
          tags: ${{ steps.images.outputs.target_base }} 

      - name: Get Download Cache Key
        id: dl_cache
        run: |
          KEY=$(./util/get_dl_cache_tag.sh)
          echo "Cache Key: $KEY"
          echo "key=$KEY" >> $GITHUB_OUTPUT

      - name: Restore Source Cache
        uses: actions/cache/restore@v4
        with:
          path: |
            .cache/downloads
            .cache/ffmpeg
          key: dl-cache-${{ steps.dl_cache.outputs.key }}
          # Если точного совпадения нет, берется самый свежий кэш с таким префиксом
          restore-keys: |
            dl-cache-${{ steps.dl_cache.outputs.key }}-
            dl-cache-

      - name: Run Download and Generate
        run: |
          if [[ "${{ github.event.inputs.doClean }}" == "true" ]]; then
            echo "### CLEAN BUILD REQUESTED ###"
            rm -rf .cache/downloads/* .cache/ffmpeg/* .cache/ccache/*
          fi
          export ONLY_STAGE="${{ github.event.inputs.only_stage }}"
          export DEBUG_NO_HASH="${{ github.event.inputs.debug_no_hash }}"
          export DEDUPE_FLAGS="${{ github.event.inputs.dedupe_flags }}"
          LTO_PARAM="nolto"
          [[ "${{ github.event.inputs.use_lto }}" == "true" ]] && LTO_PARAM="lto"
          SKIP_PARAM="false"
          [[ "${{ github.event.inputs.skip_ffmpeg }}" == "true" ]] && SKIP_PARAM="skip_ffmpeg"
          mkdir -p .cache/downloads .cache/ffmpeg
          chmod +x ./download.sh ./util/clean_cache.sh ./generate.sh
          ./download.sh
          ./util/clean_cache.sh
          ./generate.sh win64 nonfree "$LTO_PARAM" "$SKIP_PARAM" 

      - name: Inspect Dockerfile
        run: head -n 30 Dockerfile

      - name: Force Save Cache
        # if: always()
        if: success()
        uses: actions/cache/save@v4
        with:
          path: |
            .cache/downloads
            .cache/ffmpeg
          # Сохраняем под тем же ключом. 
          # Если билд не скачал ничего нового, этот шаг просто пропустится (Cache Hit).
          # Если что-то изменилось, ключ хеша (outputs.key) будет другим, и кэш сохранится.
          # key: dl-cache-${{ steps.dl_cache.outputs.key }}-${{ github.run_id }}
          key: dl-cache-${{ steps.dl_cache.outputs.key }}

      - name: Prepare and Build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: false
          tags: ffmpeg-final:local
          cache-from: type=gha,scope=ffmpeg-build
          cache-to: type=gha,mode=max,scope=ffmpeg-build
          build-contexts: |
            base-win64=docker-image://${{ steps.images.outputs.target_base }}
            ffmpeg_src=${{ github.workspace }}/.cache/ffmpeg
          outputs: type=local,dest=artifacts/
          provenance: false

      - name: Cleanup Old Caches
        if: always()
        continue-on-error: true
        run: |
          gh extension install actions/gh-actions-cache || true
          echo "Fetching list of caches..."
          caches=$(gh actions-cache list --limit 100 --order desc 2>/dev/null | cut -f 1) || true
          if [ -z "$caches" ]; then
            echo "No caches found."
          else
            count=0
            for cache in $caches; do
              ((count++))
              if [ $count -gt 5 ]; then
                echo "Deleting old cache: $cache"
                gh actions-cache delete "$cache" --confirm || true
              fi
            done
          fi
          # Удаляем только старые версии кэша, оставляя 3 последних для каждой области. Используем фильтрацию по префиксу области (scope)
          for scope in "base-root" "base" "ffmpeg-build"; do
            echo "Checking scope: $scope"
            cache_ids=$(gh actions-cache list --key "$scope" --limit 100 | cut -f 1 | tail -n +4)
            for id in $cache_ids; do
              echo "Deleting old cache ID: $id"
              gh actions-cache delete "$id" --confirm
            done
          done
          # Удалить ВСЕ кэши, содержащие "buildkit" (blobs) в названии
          # gh actions-cache delete --github-token ${{ secrets.GITHUB_TOKEN }} --keyword "buildkit" --confirm
        env:
          GITHUB_TOKEN: ${{ github.token }}

      - name: Upload Final Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-win64-nonfree
          path: artifacts/*.7z
          if-no-files-found: error

      - name: Create Release
        if: ${{ github.event.inputs.doRelease == 'true' && success() }}
        run: |
          RELDATE="$(date +'%Y-%m-%d %H:%M')"
          TAGNAME="autobuild-$(date +'%Y-%m-%d-%H-%M')"
          (cd artifacts && sha256sum *.7z > checksums.sha256)
          gh release create "$TAGNAME" --target "${{ github.ref_name }}" \
            --title "Auto-Build $RELDATE" artifacts/*.7z artifacts/checksums.sha256
        env:
          GITHUB_TOKEN: ${{ github.token }}
