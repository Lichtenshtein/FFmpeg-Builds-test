From ae2d29aaf917abfb07ec3a484b9d3ee8692bc90c Mon Sep 17 00:00:00 2001
From: MartinEesmaa <martin.eesmaa@protonmail.com>
Date: Fri, 3 Oct 2025 01:41:00 +0300
Subject: [PATCH] Fix multiple definitions to rid off FDK-AAC issue

This will fix the issue by avoiding multiple definitions for replacing it, and it can build to FFmpeg with external features of libfdk_aac and libmpeghdec with available features.

- Martin Eesmaa
---
 include/sys/genericStds.h                     | 138 +++++------
 include/sys/machine_type.h                    |   4 +-
 src/libArithCoding/src/ac_arith_coder.cpp     |   8 +-
 src/libDRCdec/src/FDK_drcDecLib.cpp           |  10 +-
 src/libDRCdec/src/drcDec_gainDecoder.cpp      |   6 +-
 src/libDRCdec/src/drcDec_reader.cpp           |  28 +--
 src/libDRCdec/src/drcDec_selectionProcess.cpp |  12 +-
 src/libDRCdec/src/drcGainDec_init.cpp         |   2 +-
 src/libDRCdec/src/drcGainDec_preprocess.cpp   |   2 +-
 src/libFDK/include/FDK_bitstream.h            |   4 +-
 src/libFDK/include/FDK_lpc.h                  |   4 +-
 src/libFDK/include/FDK_matrixCalloc.h         |  10 +-
 src/libFDK/include/FDK_tools_rom.h            |  26 +-
 src/libFDK/include/FDK_trigFcts.h             |   8 +-
 .../include/arm/FDK_aarch64_neon_funcs.h      |  40 +--
 src/libFDK/include/arm/FDK_neon_funcs.h       |  34 +--
 src/libFDK/include/fixpoint_math.h            |  18 +-
 src/libFDK/include/mdct.h                     |  16 +-
 src/libFDK/include/scale.h                    |  28 +--
 src/libFDK/src/FDK_bitbuffer.cpp              |   6 +-
 src/libFDK/src/FDK_lpc.cpp                    |  18 +-
 src/libFDK/src/FDK_matrixCalloc.cpp           |  22 +-
 src/libFDK/src/FDK_stftfilterbank.cpp         |  22 +-
 src/libFDK/src/FDK_stftfilterbank_data.cpp    |   4 +-
 src/libFDK/src/FDK_stftfilterbank_process.cpp |   4 +-
 src/libFDK/src/FDK_tools_rom.cpp              |  36 +--
 src/libFDK/src/FDK_trigFcts.cpp               |   6 +-
 src/libFDK/src/TD_upsampler.cpp               |   4 +-
 src/libFDK/src/arm/FDK_lpc_arm.cpp            |  10 +-
 src/libFDK/src/arm/fft_rad2_arm.cpp           |   6 +-
 src/libFDK/src/arm/scale_arm.cpp              |  22 +-
 src/libFDK/src/arm/scale_arm_neon.cpp         |  14 +-
 src/libFDK/src/dct.cpp                        |   4 +-
 src/libFDK/src/fft.cpp                        |   8 +-
 src/libFDK/src/mdct.cpp                       |  30 +--
 src/libFDK/src/rfft.cpp                       |   8 +-
 src/libFDK/src/scale.cpp                      |  40 +--
 .../src/FDK_dmxMatrixParser.cpp               |   2 +-
 .../src/FDK_formatConverter.cpp               |  12 +-
 .../src/FDK_formatConverterLib.cpp            |  84 +++----
 .../FDK_formatConverter_activeDmx_stft.cpp    |  46 ++--
 .../src/FDK_formatConverter_data.cpp          |  68 +++---
 .../src/FDK_formatConverter_init.cpp          |  20 +-
 src/libIGFdec/src/FDK_igfDec.cpp              |  44 ++--
 src/libIGFdec/src/FDK_igfSCFDecoder.cpp       |  14 +-
 src/libIGFdec/src/arm/FDK_igfDec_arm.cpp      |   2 +-
 src/libMpegTPDec/src/tpdec_asc.cpp            |   4 +-
 src/libMpegTPDec/src/tpdec_asi.cpp            |  20 +-
 src/libMpegTPDec/src/tpdec_lib.cpp            |  14 +-
 src/libMpeghDec/src/FDK_delay.cpp             |   4 +-
 src/libMpeghDec/src/aacdec_tns.cpp            |  10 +-
 src/libMpeghDec/src/aacdecoder.cpp            |  48 ++--
 src/libMpeghDec/src/aacdecoder_lib.cpp        |  38 +--
 src/libMpeghDec/src/block.cpp                 |  30 +--
 src/libMpeghDec/src/channel.cpp               |  32 +--
 src/libMpeghDec/src/conceal.cpp               |  26 +-
 src/libMpeghDec/src/deque.cpp                 |  18 +-
 src/libMpeghDec/src/fdp.cpp                   |   8 +-
 src/libMpeghDec/src/ltp_post.cpp              |  20 +-
 src/libMpeghDec/src/mct.cpp                   |  78 +++---
 src/libMpeghDec/src/mpeghdecoder.cpp          |  16 +-
 src/libMpeghDec/src/stereo.cpp                |  26 +-
 src/libMpeghDec/src/ui.cpp                    |  16 +-
 src/libMpeghUIMan/src/mpeghUIManager.cpp      |   6 +-
 src/libPCMutils/include/pcm_utils.h           |   2 +-
 src/libPCMutils/src/arm/pcm_utils_arm.cpp     |   4 +-
 src/libPCMutils/src/limiter.cpp               |  26 +-
 src/libPCMutils/src/pcm_utils.cpp             |   2 +-
 src/libSYS/src/cmdl_parser.cpp                |  38 +--
 src/libSYS/src/genericStds.cpp                | 122 +++++-----
 src/libSYS/src/wav_file.cpp                   | 230 +++++++++---------
 src/libUIManager/src/uiManager.cpp            |  10 +-
 src/libUIManager/src/uiPersistence.cpp        |  14 +-
 src/libUIManager/src/uiXml.cpp                |  18 +-
 src/libgVBAPRenderer/src/gVBAPRenderer.cpp    |  94 +++----
 src/libgVBAPRenderer/src/quickHull.cpp        |  34 +--
 src/libgVBAPRenderer/src/vbap_core.cpp        |   8 +-
 77 files changed, 985 insertions(+), 985 deletions(-)

diff --git a/include/sys/genericStds.h b/include/sys/genericStds.h
index b84b51b..5f3ae36 100644
--- a/include/sys/genericStds.h
+++ b/include/sys/genericStds.h
@@ -103,7 +103,7 @@ amm-info@iis.fraunhofer.de
 
 /**
  * Identifiers for various memory locations. They are used along with memory allocation
- * functions like FDKcalloc_L() to specify the requested memory's location.
+ * functions like mpegh_FDKcalloc_L() to specify the requested memory's location.
  */
 typedef enum {
   /* Internal */
@@ -156,11 +156,11 @@ typedef enum {
 #define C_ALLOC_MEM(name, type, num)               \
   type* Get##name(int n) {                         \
     FDK_ASSERT((n) == 0);                          \
-    return ((type*)FDKcalloc(num, sizeof(type)));  \
+    return ((type*)mpegh_FDKcalloc(num, sizeof(type)));  \
   }                                                \
   void Free##name(type** p) {                      \
     if (p != NULL) {                               \
-      FDKfree(*p);                                 \
+      mpegh_FDKfree(*p);                                 \
       *p = NULL;                                   \
     }                                              \
   }                                                \
@@ -172,11 +172,11 @@ typedef enum {
 #define C_ALLOC_MEM2(name, type, n1, n2)                 \
   type* Get##name(int n) {                               \
     FDK_ASSERT((n) < (n2));                              \
-    return ((type*)FDKcalloc(n1, sizeof(type)));         \
+    return ((type*)mpegh_FDKcalloc(n1, sizeof(type)));         \
   }                                                      \
   void Free##name(type** p) {                            \
     if (p != NULL) {                                     \
-      FDKfree(*p);                                       \
+      mpegh_FDKfree(*p);                                       \
       *p = NULL;                                         \
     }                                                    \
   }                                                      \
@@ -189,12 +189,12 @@ typedef enum {
   type* Get##name(int n) {                                            \
     type* ap;                                                         \
     FDK_ASSERT((n) == 0);                                             \
-    ap = ((type*)FDKaalloc((num) * sizeof(type), ALIGNMENT_DEFAULT)); \
+    ap = ((type*)mpegh_FDKaalloc((num) * sizeof(type), ALIGNMENT_DEFAULT)); \
     return ap;                                                        \
   }                                                                   \
   void Free##name(type** p) {                                         \
     if (p != NULL) {                                                  \
-      FDKafree(*p);                                                   \
+      mpegh_FDKafree(*p);                                                   \
       *p = NULL;                                                      \
     }                                                                 \
   }                                                                   \
@@ -207,12 +207,12 @@ typedef enum {
   type* Get##name(int n) {                                           \
     type* ap;                                                        \
     FDK_ASSERT((n) < (n2));                                          \
-    ap = ((type*)FDKaalloc((n1) * sizeof(type), ALIGNMENT_DEFAULT)); \
+    ap = ((type*)mpegh_FDKaalloc((n1) * sizeof(type), ALIGNMENT_DEFAULT)); \
     return ap;                                                       \
   }                                                                  \
   void Free##name(type** p) {                                        \
     if (p != NULL) {                                                 \
-      FDKafree(*p);                                                  \
+      mpegh_FDKafree(*p);                                                  \
       *p = NULL;                                                     \
     }                                                                \
   }                                                                  \
@@ -224,11 +224,11 @@ typedef enum {
 #define C_ALLOC_MEM_L(name, type, num, s)              \
   type* Get##name(int n) {                             \
     FDK_ASSERT((n) == 0);                              \
-    return ((type*)FDKcalloc_L(num, sizeof(type), s)); \
+    return ((type*)mpegh_FDKcalloc_L(num, sizeof(type), s)); \
   }                                                    \
   void Free##name(type** p) {                          \
     if (p != NULL) {                                   \
-      FDKfree_L(*p);                                   \
+      mpegh_FDKfree_L(*p);                                   \
       *p = NULL;                                       \
     }                                                  \
   }                                                    \
@@ -240,11 +240,11 @@ typedef enum {
 #define C_ALLOC_MEM2_L(name, type, n1, n2, s)            \
   type* Get##name(int n) {                               \
     FDK_ASSERT((n) < (n2));                              \
-    return (type*)FDKcalloc_L(n1, sizeof(type), s);      \
+    return (type*)mpegh_FDKcalloc_L(n1, sizeof(type), s);      \
   }                                                      \
   void Free##name(type** p) {                            \
     if (p != NULL) {                                     \
-      FDKfree_L(*p);                                     \
+      mpegh_FDKfree_L(*p);                                     \
       *p = NULL;                                         \
     }                                                    \
   }                                                      \
@@ -257,12 +257,12 @@ typedef enum {
   type* Get##name(int n) {                                                 \
     type* ap;                                                              \
     FDK_ASSERT((n) == 0);                                                  \
-    ap = ((type*)FDKaalloc_L((num) * sizeof(type), ALIGNMENT_DEFAULT, s)); \
+    ap = ((type*)mpegh_FDKaalloc_L((num) * sizeof(type), ALIGNMENT_DEFAULT, s)); \
     return ap;                                                             \
   }                                                                        \
   void Free##name(type** p) {                                              \
     if (p != NULL) {                                                       \
-      FDKafree_L(*p);                                                      \
+      mpegh_FDKafree_L(*p);                                                      \
       *p = NULL;                                                           \
     }                                                                      \
   }                                                                        \
@@ -275,12 +275,12 @@ typedef enum {
   type* Get##name(int n) {                                                \
     type* ap;                                                             \
     FDK_ASSERT((n) < (n2));                                               \
-    ap = ((type*)FDKaalloc_L((n1) * sizeof(type), ALIGNMENT_DEFAULT, s)); \
+    ap = ((type*)mpegh_FDKaalloc_L((n1) * sizeof(type), ALIGNMENT_DEFAULT, s)); \
     return ap;                                                            \
   }                                                                       \
   void Free##name(type** p) {                                             \
     if (p != NULL) {                                                      \
-      FDKafree_L(*p);                                                     \
+      mpegh_FDKafree_L(*p);                                                     \
       *p = NULL;                                                          \
     }                                                                     \
   }                                                                       \
@@ -360,73 +360,73 @@ INT FDKisalpha(INT c);
 /* Wrapper for <ctypes.h>'s tolower(). */
 INT FDKtolower(INT c);
 
-void FDKprintf(const char* szFmt, ...);
+void mpegh_FDKprintf(const char* szFmt, ...);
 
-void FDKprintfErr(const char* szFmt, ...);
+void mpegh_FDKprintfErr(const char* szFmt, ...);
 
 /** Wrapper for <stdio.h>'s getchar(). */
-INT FDKgetchar(void);
+INT mpegh_FDKgetchar(void);
 
-INT FDKfprintf(void* stream, const char* format, ...);
+INT mpegh_FDKfprintf(void* stream, const char* format, ...);
 
-char* FDKstrchr(char* s, INT c);
-const char* FDKstrstr(const char* haystack, const char* needle);
-char* FDKstrcpy(char* dest, const char* src);
-char* FDKstrncpy(char* dest, const char* src, const UINT n);
+char* mpegh_FDKstrchr(char* s, INT c);
+const char* mpegh_FDKstrstr(const char* haystack, const char* needle);
+char* mpegh_FDKstrcpy(char* dest, const char* src);
+char* mpegh_FDKstrncpy(char* dest, const char* src, const UINT n);
 
 #define FDK_MAX_OVERLAYS 9 /**< Maximum number of memory overlays. */
 
-void* FDKcalloc(const UINT n, const UINT size);
-void* FDKmalloc(const UINT size);
-void FDKfree(void* ptr);
+void* mpegh_FDKcalloc(const UINT n, const UINT size);
+void* mpegh_FDKmalloc(const UINT size);
+void mpegh_FDKfree(void* ptr);
 
 /**
- *  Allocate and clear an aligned memory area. Use FDKafree() instead of FDKfree() for these memory
+ *  Allocate and clear an aligned memory area. Use mpegh_FDKafree() instead of mpegh_FDKfree() for these memory
  * areas.
  *
  * \param size       Size of requested memory in bytes.
  * \param alignment  Alignment of requested memory in bytes.
  * \return           Pointer to allocated memory.
  */
-void* FDKaalloc(const UINT size, const UINT alignment);
+void* mpegh_FDKaalloc(const UINT size, const UINT alignment);
 
 /**
  *  Free an aligned memory area.
  *
  * \param ptr  Pointer to be freed.
  */
-void FDKafree(void* ptr);
+void mpegh_FDKafree(void* ptr);
 
 /**
  *  Allocate memory in a specific memory section.
  *  Requests can be made for internal or external memory. If internal memory is
- *  requested, FDKcalloc_L() first tries to use L1 memory, which sizes are defined
+ *  requested, mpegh_FDKcalloc_L() first tries to use L1 memory, which sizes are defined
  *  by ::DATA_L1_A_SIZE and ::DATA_L1_B_SIZE. If no L1 memory is available, then
- *  FDKcalloc_L() tries to use L2 memory. If that fails as well, the requested
- *  memory is allocated at an extern location using the fallback FDKcalloc().
+ *  mpegh_FDKcalloc_L() tries to use L2 memory. If that fails as well, the requested
+ *  memory is allocated at an extern location using the fallback mpegh_FDKcalloc().
  *
  * \param n     See MSDN documentation on calloc().
  * \param size  See MSDN documentation on calloc().
  * \param s     Memory section.
  * \return      See MSDN documentation on calloc().
  */
-void* FDKcalloc_L(const UINT n, const UINT size, MEMORY_SECTION s);
+void* mpegh_FDKcalloc_L(const UINT n, const UINT size, MEMORY_SECTION s);
 
 /**
  *  Allocate aligned memory in a specific memory section.
- *  See FDKcalloc_L() description for details - same applies here.
+ *  See mpegh_FDKcalloc_L() description for details - same applies here.
  */
-void* FDKaalloc_L(const UINT size, const UINT alignment, MEMORY_SECTION s);
+void* mpegh_FDKaalloc_L(const UINT size, const UINT alignment, MEMORY_SECTION s);
 
 /**
  *  Free memory that was allocated in a specific memory section.
  */
-void FDKfree_L(void* ptr);
+void mpegh_FDKfree_L(void* ptr);
 
 /**
  *  Free aligned memory that was allocated in a specific memory section.
  */
-void FDKafree_L(void* ptr);
+void mpegh_FDKafree_L(void* ptr);
 
 /**
  * Copy memory. Source and destination memory must not overlap.
@@ -436,7 +436,7 @@ void FDKafree_L(void* ptr);
  * The function arguments correspond to the standard memcpy(). Please see MSDN
  * documentation for details on how to use it.
  */
-void FDKmemcpy(void* dst, const void* src, const UINT size);
+void mpegh_FDKmemcpy(void* dst, const void* src, const UINT size);
 
 /**
  * Copy memory. Source and destination memory are allowed to overlap.
@@ -446,7 +446,7 @@ void FDKmemcpy(void* dst, const void* src, const UINT size);
  * The function arguments correspond to the standard memmove(). Please see MSDN
  * documentation for details on how to use it.
  */
-void FDKmemmove(void* dst, const void* src, const UINT size);
+void mpegh_FDKmemmove(void* dst, const void* src, const UINT size);
 
 /**
  * Clear memory.
@@ -456,21 +456,21 @@ void FDKmemmove(void* dst, const void* src, const UINT size);
  * The function arguments correspond to the standard memclear(). Please see MSDN
  * documentation for details on how to use it.
  */
-void FDKmemclear(void* memPtr, const UINT size);
+void mpegh_FDKmemclear(void* memPtr, const UINT size);
 
 /**
  * Fill memory with values.
  * The function arguments correspond to the standard memset(). Please see MSDN
  * documentation for details on how to use it.
  */
-void FDKmemset(void* memPtr, const INT value, const UINT size);
+void mpegh_FDKmemset(void* memPtr, const INT value, const UINT size);
 
 /* Compare function wrappers */
-INT FDKmemcmp(const void* s1, const void* s2, const UINT size);
-INT FDKstrcmp(const char* s1, const char* s2);
-INT FDKstrncmp(const char* s1, const char* s2, const UINT size);
+INT mpegh_FDKmemcmp(const void* s1, const void* s2, const UINT size);
+INT mpegh_FDKstrcmp(const char* s1, const char* s2);
+INT mpegh_FDKstrncmp(const char* s1, const char* s2, const UINT size);
 
-UINT FDKstrlen(const char* s);
+UINT mpegh_FDKstrlen(const char* s);
 
 #define FDKmax(a, b) ((a) > (b) ? (a) : (b))
 #define FDKmin(a, b) ((a) < (b) ? (a) : (b))
@@ -485,7 +485,7 @@ UINT FDKstrlen(const char* s);
  *
  * \return  1 if platform is little endian, non-1 if platform is big endian.
  */
-int IS_LITTLE_ENDIAN(void);
+int MPEGH_IS_LITTLE_ENDIAN(void);
 
 /*!
  *  Convert input value to little endian format.
@@ -493,43 +493,43 @@ int IS_LITTLE_ENDIAN(void);
  * \param val  Value to be converted. It may be in both big or little endian.
  * \return     Value in little endian format.
  */
-UINT TO_LITTLE_ENDIAN(UINT val);
+UINT MPEGH_TO_LITTLE_ENDIAN(UINT val);
 
 /*!
- * \fn     FDKFILE *FDKfopen(const char *filename, const char *mode);
+ * \fn     FDKFILE *mpegh_FDKfopen(const char *filename, const char *mode);
  *         Standard fopen() wrapper.
- * \fn     INT FDKfclose(FDKFILE *FP);
+ * \fn     INT mpegh_FDKfclose(FDKFILE *FP);
  *         Standard fclose() wrapper.
- * \fn     INT FDKfseek(FDKFILE *FP, LONG OFFSET, int WHENCE);
+ * \fn     INT mpegh_FDKfseek(FDKFILE *FP, LONG OFFSET, int WHENCE);
  *         Standard fseek() wrapper.
- * \fn     INT FDKftell(FDKFILE *FP);
+ * \fn     INT mpegh_FDKftell(FDKFILE *FP);
  *         Standard ftell() wrapper.
  * \fn     INT FDKfseek64(FDKFILE *FP, INT64 OFFSET, int WHENCE);
  *         Machine dependent fseek() wrapper for files >4GB.
  * \fn     INT64 FDKftell64(FDKFILE *FP);
  *         Machine dependent ftell() wrapper for files >4GB.
- * \fn     INT FDKfflush(FDKFILE *fp);
+ * \fn     INT mpegh_FDKfflush(FDKFILE *fp);
  *         Standard fflush() wrapper.
- * \fn     UINT FDKfwrite(const void *ptrf, INT size, UINT nmemb, FDKFILE *fp);
+ * \fn     UINT mpegh_FDKfwrite(const void *ptrf, INT size, UINT nmemb, FDKFILE *fp);
  *         Standard fwrite() wrapper.
- * \fn     UINT FDKfread(void *dst, INT size, UINT nmemb, FDKFILE *fp);
+ * \fn     UINT mpegh_FDKfread(void *dst, INT size, UINT nmemb, FDKFILE *fp);
  *         Standard fread() wrapper.
  */
 typedef void FDKFILE;
-extern const INT FDKSEEK_SET, FDKSEEK_CUR, FDKSEEK_END;
+extern const INT MPEGH_FDKSEEK_SET, MPEGH_FDKSEEK_CUR, MPEGH_FDKSEEK_END;
 
-FDKFILE* FDKfopen(const char* filename, const char* mode);
-INT FDKfclose(FDKFILE* FP);
-INT FDKfseek(FDKFILE* FP, LONG OFFSET, int WHENCE);
-INT FDKftell(FDKFILE* FP);
+FDKFILE* mpegh_FDKfopen(const char* filename, const char* mode);
+INT mpegh_FDKfclose(FDKFILE* FP);
+INT mpegh_FDKfseek(FDKFILE* FP, LONG OFFSET, int WHENCE);
+INT mpegh_FDKftell(FDKFILE* FP);
 INT FDKfseek64(FDKFILE* fp, INT64 OFFSET, int WHENCE);
 INT64 FDKftell64(FDKFILE* FP);
-INT FDKfflush(FDKFILE* fp);
-UINT FDKfwrite(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp);
-UINT FDKfread(void* dst, INT size, UINT nmemb, FDKFILE* fp);
-char* FDKfgets(void* dst, INT size, FDKFILE* fp);
-void FDKrewind(FDKFILE* fp);
-INT FDKfeof(FDKFILE* fp);
+INT mpegh_FDKfflush(FDKFILE* fp);
+UINT mpegh_FDKfwrite(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp);
+UINT mpegh_FDKfread(void* dst, INT size, UINT nmemb, FDKFILE* fp);
+char* mpegh_FDKfgets(void* dst, INT size, FDKFILE* fp);
+void mpegh_FDKrewind(FDKFILE* fp);
+INT mpegh_FDKfeof(FDKFILE* fp);
 
 /**
  * \brief        Write each member in little endian order. Convert automatically to host endianess.
@@ -539,7 +539,7 @@ INT FDKfeof(FDKFILE* fp);
  * \param fp     File pointer of type FDKFILE.
  * \return       Number of items read on success and fread() error on failure.
  */
-UINT FDKfwrite_EL(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp);
+UINT mpegh_FDKfwrite_EL(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp);
 
 /**
  * \brief        Read variable of size "size" as little endian. Convert automatically to host
@@ -550,7 +550,7 @@ UINT FDKfwrite_EL(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp);
  * \param fp     File pointer of type FDKFILE.
  * \return       Number of items read on success and fread() error on failure.
  */
-UINT FDKfread_EL(void* dst, INT size, UINT nmemb, FDKFILE* fp);
+UINT mpegh_FDKfread_EL(void* dst, INT size, UINT nmemb, FDKFILE* fp);
 
 #ifdef __cplusplus
 }
diff --git a/include/sys/machine_type.h b/include/sys/machine_type.h
index 99fd601..1cf564c 100644
--- a/include/sys/machine_type.h
+++ b/include/sys/machine_type.h
@@ -343,10 +343,10 @@ typedef LONG INT_PCM;
 
 /* Alignment macros for libSYS heap implementation */
 #define ALIGNMENT_EXTRES (ALIGNMENT_DEFAULT)
-/* aligned size required for FDKcalloc() / FDKmalloc() */
+/* aligned size required for mpegh_FDKcalloc() / mpegh_FDKmalloc() */
 #define ALGN_SIZE_EXTRES(a) \
   ((a) + (((INT)ALIGNMENT_EXTRES - ((INT)(a) & (ALIGNMENT_EXTRES - 1))) & (ALIGNMENT_EXTRES - 1)))
-/* aligned size required for FDKaalloc() */
+/* aligned size required for mpegh_FDKaalloc() */
 #define A_ALGN_SIZE_EXTRES(a) (ALGN_SIZE_EXTRES((a) + ALIGNMENT_DEFAULT + sizeof(void*)))
 
 /*!
diff --git a/src/libArithCoding/src/ac_arith_coder.cpp b/src/libArithCoding/src/ac_arith_coder.cpp
index 34c15ea..7e7c62b 100644
--- a/src/libArithCoding/src/ac_arith_coder.cpp
+++ b/src/libArithCoding/src/ac_arith_coder.cpp
@@ -703,7 +703,7 @@ static ARITH_CODING_ERROR decode2(HANDLE_FDK_BITSTREAM bbuf, UCHAR* RESTRICT c_p
     }
   }
 
-  FDKmemset(&c_prev[i], 1, sizeof(c_prev[0]) * (nt - i));
+  mpegh_FDKmemset(&c_prev[i], 1, sizeof(c_prev[0]) * (nt - i));
 
   return ErrorStatus;
 }
@@ -726,11 +726,11 @@ ARITH_CODING_ERROR CArco_DecodeArithData(CArcoData* pArcoData, HANDLE_FDK_BITSTR
     return ARITH_CODER_ERROR;
   }
 
-  FDKmemclear(mdctSpectrum, lg_max * sizeof(FIXP_DBL));
+  mpegh_FDKmemclear(mdctSpectrum, lg_max * sizeof(FIXP_DBL));
 
   /* arith_map_context */
   if (arith_reset_flag) {
-    FDKmemclear(pArcoData->c_prev, sizeof(pArcoData->c_prev[0]) * ((lg_max / 2) + 4));
+    mpegh_FDKmemclear(pArcoData->c_prev, sizeof(pArcoData->c_prev[0]) * ((lg_max / 2) + 4));
   } else {
     if (lg_max != pArcoData->m_numberLinesPrev) {
       if (pArcoData->m_numberLinesPrev == 0) {
@@ -749,7 +749,7 @@ ARITH_CODING_ERROR CArco_DecodeArithData(CArcoData* pArcoData, HANDLE_FDK_BITSTR
   if (lg > 0) {
     ErrorStatus = decode2(hBs, pArcoData->c_prev + 2, mdctSpectrum, lg >> 1, lg_max >> 1);
   } else {
-    FDKmemset(&pArcoData->c_prev[2], 1, sizeof(pArcoData->c_prev[2]) * (lg_max >> 1));
+    mpegh_FDKmemset(&pArcoData->c_prev[2], 1, sizeof(pArcoData->c_prev[2]) * (lg_max >> 1));
   }
 
   if ((INT)FDKgetValidBits(hBs) < 0) {
diff --git a/src/libDRCdec/src/FDK_drcDecLib.cpp b/src/libDRCdec/src/FDK_drcDecLib.cpp
index 24a8cac..cf20631 100644
--- a/src/libDRCdec/src/FDK_drcDecLib.cpp
+++ b/src/libDRCdec/src/FDK_drcDecLib.cpp
@@ -174,7 +174,7 @@ static void startSelectionProcess(HANDLE_DRC_DECODER hDrcDec) {
   if (!hDrcDec->status) return;
 
   C_ALLOC_SCRATCH_START(oldSelProcOutput, SEL_PROC_OUTPUT, 1);
-  FDKmemcpy(oldSelProcOutput, &hDrcDec->selProcOutput, sizeof(SEL_PROC_OUTPUT));
+  mpegh_FDKmemcpy(oldSelProcOutput, &hDrcDec->selProcOutput, sizeof(SEL_PROC_OUTPUT));
 
   if (hDrcDec->functionalRange & DRC_DEC_SELECTION) {
     uniDrcConfigHasChanged = hDrcDec->uniDrcConfig.diff;
@@ -218,11 +218,11 @@ FDK_drcDec_Open(HANDLE_DRC_DECODER* phDrcDec, const DRC_DEC_FUNCTIONAL_RANGE fun
   DRCDEC_SELECTION_PROCESS_RETURN sErr = DRCDEC_SELECTION_PROCESS_NO_ERROR;
   HANDLE_DRC_DECODER hDrcDec;
 
-  *phDrcDec = (HANDLE_DRC_DECODER)FDKcalloc(1, sizeof(struct s_drc_decoder));
+  *phDrcDec = (HANDLE_DRC_DECODER)mpegh_FDKcalloc(1, sizeof(struct s_drc_decoder));
   if (!*phDrcDec) return DRC_DEC_OUT_OF_MEMORY;
   hDrcDec = *phDrcDec;
 
-  hDrcDec->uniDrcConfig.p_scratch = (UINT*)FDKcalloc(1, getScratchBufferSize());
+  hDrcDec->uniDrcConfig.p_scratch = (UINT*)mpegh_FDKcalloc(1, getScratchBufferSize());
   if (!hDrcDec->uniDrcConfig.p_scratch) return DRC_DEC_OUT_OF_MEMORY;
 
   hDrcDec->functionalRange = functionalRange;
@@ -374,10 +374,10 @@ FDK_drcDec_Close(HANDLE_DRC_DECODER* phDrcDec) {
     drcDec_SelectionProcess_Delete(&(hDrcDec->hSelectionProc));
   }
 
-  FDKfree(hDrcDec->uniDrcConfig.p_scratch);
+  mpegh_FDKfree(hDrcDec->uniDrcConfig.p_scratch);
   hDrcDec->uniDrcConfig.p_scratch = NULL;
 
-  FDKfree(*phDrcDec);
+  mpegh_FDKfree(*phDrcDec);
   *phDrcDec = NULL;
 
   return DRC_DEC_OK;
diff --git a/src/libDRCdec/src/drcDec_gainDecoder.cpp b/src/libDRCdec/src/drcDec_gainDecoder.cpp
index c8ad735..88e7e75 100644
--- a/src/libDRCdec/src/drcDec_gainDecoder.cpp
+++ b/src/libDRCdec/src/drcDec_gainDecoder.cpp
@@ -130,7 +130,7 @@ DRC_ERROR
 drcDec_GainDecoder_Open(HANDLE_DRC_GAIN_DECODER* phGainDec) {
   DRC_GAIN_DECODER* hGainDec = NULL;
 
-  hGainDec = (DRC_GAIN_DECODER*)FDKcalloc(1, sizeof(DRC_GAIN_DECODER));
+  hGainDec = (DRC_GAIN_DECODER*)mpegh_FDKcalloc(1, sizeof(DRC_GAIN_DECODER));
   if (hGainDec == NULL) return DE_MEMORY_ERROR;
 
   hGainDec->multiBandActiveDrcIndex = -1;
@@ -211,7 +211,7 @@ drcDec_GainDecoder_Config(HANDLE_DRC_GAIN_DECODER hGainDec, HANDLE_UNI_DRC_CONFI
   if (pCoef) {
     hGainDec->drcCoef = *pCoef; /* keep deep copy of drcCoefficients */
   } else {
-    FDKmemset(&hGainDec->drcCoef, 0, sizeof(DRC_COEFFICIENTS_UNI_DRC));
+    mpegh_FDKmemset(&hGainDec->drcCoef, 0, sizeof(DRC_COEFFICIENTS_UNI_DRC));
   }
 
   if (hGainDec->drcCoef.drcFrameSizePresent &&
@@ -235,7 +235,7 @@ drcDec_GainDecoder_Config(HANDLE_DRC_GAIN_DECODER hGainDec, HANDLE_UNI_DRC_CONFI
 DRC_ERROR
 drcDec_GainDecoder_Close(HANDLE_DRC_GAIN_DECODER* phGainDec) {
   if (*phGainDec != NULL) {
-    FDKfree(*phGainDec);
+    mpegh_FDKfree(*phGainDec);
     *phGainDec = NULL;
   }
 
diff --git a/src/libDRCdec/src/drcDec_reader.cpp b/src/libDRCdec/src/drcDec_reader.cpp
index 631fc27..c326f67 100644
--- a/src/libDRCdec/src/drcDec_reader.cpp
+++ b/src/libDRCdec/src/drcDec_reader.cpp
@@ -492,7 +492,7 @@ drcDec_readUniDrcGain(HANDLE_FDK_BITSTREAM hBs, DRC_COEFFICIENTS_UNI_DRC* pCoef,
     _readDrcGainSequence(hBs, gainSet, frameSize, timeDeltaMin, &tmpNNodes, tmpNodes);
 
     hUniDrcGain->nNodes[startIndexGainSequence + seq] = tmpNNodes;
-    FDKmemcpy(hUniDrcGain->gainNode[startIndexGainSequence + seq], tmpNodes,
+    mpegh_FDKmemcpy(hUniDrcGain->gainNode[startIndexGainSequence + seq], tmpNodes,
               fMin(tmpNNodes, (UCHAR)32) * sizeof(GAIN_NODE));
   }
 
@@ -677,7 +677,7 @@ static DRC_ERROR _readDrcCoefficientsUniDrc(HANDLE_FDK_BITSTREAM hBs, const int
     pCoef->gainSetCount = fMin(gainSetCount, 48);
     for (i = 0; i < gainSetCount; i++) {
       GAIN_SET tmpGset;
-      FDKmemclear(&tmpGset, sizeof(GAIN_SET));
+      mpegh_FDKmemclear(&tmpGset, sizeof(GAIN_SET));
       err = _readGainSet(hBs, version, &gainSequenceIndex, &tmpGset);
       if (err) return err;
       gainSequenceCount += tmpGset.bandCount;
@@ -739,7 +739,7 @@ static DRC_ERROR _mergeSubstreamDrcCoefficients(DRC_COEFFICIENTS_UNI_DRC* pCoefS
       pCoefSubstream->gainSet[gs].gainSequenceIndex[b] += startIndexGainSequence;
     }
     if (!*pDiff)
-      *pDiff |= (FDKmemcmp(&pCoefSubstream->gainSet[gs], &pCoef->gainSet[startIndexGainSet + gs],
+      *pDiff |= (mpegh_FDKmemcmp(&pCoefSubstream->gainSet[gs], &pCoef->gainSet[startIndexGainSet + gs],
                            sizeof(GAIN_SET)) != 0);
     pCoef->gainSet[startIndexGainSet + gs] = pCoefSubstream->gainSet[gs];
   }
@@ -1061,7 +1061,7 @@ static DRC_ERROR _mergeSubstreamDrcInstructions(DRC_INSTRUCTIONS_UNI_DRC* pInstS
       /* insert the duckingModificationForChannel elements of this substream, starting from
        * startIndexChannel */
       if (!*pDiff)
-        *pDiff |= (FDKmemcmp(&pInstSubstream->duckingModificationForChannel[c],
+        *pDiff |= (mpegh_FDKmemcmp(&pInstSubstream->duckingModificationForChannel[c],
                              &pInst->duckingModificationForChannel[startIndexChannel + c],
                              sizeof(DUCKING_MODIFICATION)) != 0);
       pInst->duckingModificationForChannel[startIndexChannel + c] =
@@ -1076,7 +1076,7 @@ static DRC_ERROR _mergeSubstreamDrcInstructions(DRC_INSTRUCTIONS_UNI_DRC* pInstS
        * startIndexChannelGroup */
       for (b = 0; b < 4; b++) {
         if (!*pDiff)
-          *pDiff |= (FDKmemcmp(pInstSubstream->gainModificationForChannelGroup[cg],
+          *pDiff |= (mpegh_FDKmemcmp(pInstSubstream->gainModificationForChannelGroup[cg],
                                pInst->gainModificationForChannelGroup[startIndexChannelGroup + cg],
                                4 * sizeof(GAIN_MODIFICATION)) != 0);
         pInst->gainModificationForChannelGroup[startIndexChannelGroup + cg][b] =
@@ -1144,7 +1144,7 @@ drcDec_readMpegh3daUniDrcConfig(HANDLE_FDK_BITSTREAM hBs, HANDLE_UNI_DRC_CONFIG
   DRC_ERROR err = DE_OK;
   int i, j, diff = 0, uniDrcConfigExtPresent;
   CHANNEL_LAYOUT tmpChan;
-  FDKmemclear(&tmpChan, sizeof(CHANNEL_LAYOUT));
+  mpegh_FDKmemclear(&tmpChan, sizeof(CHANNEL_LAYOUT));
   if (hUniDrcConfig == NULL) return DE_NOT_OK;
   if (hLoudnessInfoSet == NULL) return DE_NOT_OK;
   if (subStreamIndex >= 4) return DE_OK;
@@ -1175,14 +1175,14 @@ drcDec_readMpegh3daUniDrcConfig(HANDLE_FDK_BITSTREAM hBs, HANDLE_UNI_DRC_CONFIG
   }
 
   if (!diff)
-    diff |= (FDKmemcmp(&tmpChan, &hUniDrcConfig->channelLayout, sizeof(CHANNEL_LAYOUT)) != 0);
+    diff |= (mpegh_FDKmemcmp(&tmpChan, &hUniDrcConfig->channelLayout, sizeof(CHANNEL_LAYOUT)) != 0);
   hUniDrcConfig->channelLayout = tmpChan;
 
   hUniDrcConfig->drcCoefficientsUniDrcCount =
       fMin(hUniDrcConfig->drcCoefficientsUniDrcCountV0[0], (UCHAR)2);
   for (i = 0; i < hUniDrcConfig->drcCoefficientsUniDrcCountV0[subStreamIndex]; i++) {
     DRC_COEFFICIENTS_UNI_DRC* tmpCoef = (DRC_COEFFICIENTS_UNI_DRC*)hUniDrcConfig->p_scratch;
-    FDKmemclear(tmpCoef, sizeof(DRC_COEFFICIENTS_UNI_DRC));
+    mpegh_FDKmemclear(tmpCoef, sizeof(DRC_COEFFICIENTS_UNI_DRC));
 
     err = _readDrcCoefficientsUniDrc(hBs, 0, tmpCoef);
     if (err) return err;
@@ -1209,7 +1209,7 @@ drcDec_readMpegh3daUniDrcConfig(HANDLE_FDK_BITSTREAM hBs, HANDLE_UNI_DRC_CONFIG
   for (i = 0; i < hUniDrcConfig->drcInstructionsUniDrcCountV0[subStreamIndex]; i++) {
     DRC_INSTRUCTIONS_UNI_DRC* tmpInst = (DRC_INSTRUCTIONS_UNI_DRC*)hUniDrcConfig->p_scratch;
 
-    FDKmemclear(tmpInst, sizeof(DRC_INSTRUCTIONS_UNI_DRC));
+    mpegh_FDKmemclear(tmpInst, sizeof(DRC_INSTRUCTIONS_UNI_DRC));
     tmpInst->drcInstructionsType = FDKreadBits(hBs, 1);
     if (tmpInst->drcInstructionsType != 0) {
       tmpInst->drcInstructionsType = FDKreadBits(hBs, 1) + 2;
@@ -1371,7 +1371,7 @@ static DRC_ERROR _readLoudnessInfo(HANDLE_FDK_BITSTREAM hBs, const int version,
   loudnessInfo->measurementCount = fMin(measurementCount, 16);
   for (i = 0; i < measurementCount; i++) {
     LOUDNESS_MEASUREMENT tmpMeas;
-    FDKmemclear(&tmpMeas, sizeof(LOUDNESS_MEASUREMENT));
+    mpegh_FDKmemclear(&tmpMeas, sizeof(LOUDNESS_MEASUREMENT));
     err = _readLoudnessMeasurement(hBs, &tmpMeas);
     if (err) return err;
     if (i >= 16) continue;
@@ -1433,7 +1433,7 @@ drcDec_readMpegh3daLoudnessInfoSet(HANDLE_FDK_BITSTREAM hBs,
       (UCHAR)fMin(startIndex + hLoudnessInfoSet->loudnessInfoCountV0[subStreamIndex], 32);
   for (i = 0; i < hLoudnessInfoSet->loudnessInfoCountV0[subStreamIndex]; i++) {
     LOUDNESS_INFO tmpLoud;
-    FDKmemclear(&tmpLoud, sizeof(LOUDNESS_INFO));
+    mpegh_FDKmemclear(&tmpLoud, sizeof(LOUDNESS_INFO));
     tmpLoud.loudnessInfoType = FDKreadBits(hBs, 2);
     if ((tmpLoud.loudnessInfoType == 1) || (tmpLoud.loudnessInfoType == 2)) {
       tmpLoud.mae_groupID = FDKreadBits(hBs, 7);
@@ -1447,7 +1447,7 @@ drcDec_readMpegh3daLoudnessInfoSet(HANDLE_FDK_BITSTREAM hBs,
 
     /* insert the loudnessInfo element of this substream, starting from startIndex */
     if (!diff)
-      diff |= (FDKmemcmp(&tmpLoud, &(hLoudnessInfoSet->loudnessInfo[startIndex + i]),
+      diff |= (mpegh_FDKmemcmp(&tmpLoud, &(hLoudnessInfoSet->loudnessInfo[startIndex + i]),
                          sizeof(LOUDNESS_INFO)) != 0);
     hLoudnessInfoSet->loudnessInfo[startIndex + i] = tmpLoud;
   }
@@ -1470,14 +1470,14 @@ drcDec_readMpegh3daLoudnessInfoSet(HANDLE_FDK_BITSTREAM hBs,
       (UCHAR)fMin(startIndex + hLoudnessInfoSet->loudnessInfoAlbumCountV0[subStreamIndex], 32);
   for (i = 0; i < hLoudnessInfoSet->loudnessInfoAlbumCountV0[subStreamIndex]; i++) {
     LOUDNESS_INFO tmpLoud;
-    FDKmemclear(&tmpLoud, sizeof(LOUDNESS_INFO));
+    mpegh_FDKmemclear(&tmpLoud, sizeof(LOUDNESS_INFO));
     err = _readLoudnessInfo(hBs, 0, &tmpLoud);
     if (err) return err;
     if (startIndex + i >= 32) continue;
 
     /* insert the loudnessInfoAlbum element of this substream, starting from startIndex */
     if (!diff)
-      diff |= (FDKmemcmp(&tmpLoud, &(hLoudnessInfoSet->loudnessInfoAlbum[startIndex + i]),
+      diff |= (mpegh_FDKmemcmp(&tmpLoud, &(hLoudnessInfoSet->loudnessInfoAlbum[startIndex + i]),
                          sizeof(LOUDNESS_INFO)) != 0);
     hLoudnessInfoSet->loudnessInfoAlbum[startIndex + i] = tmpLoud;
   }
diff --git a/src/libDRCdec/src/drcDec_selectionProcess.cpp b/src/libDRCdec/src/drcDec_selectionProcess.cpp
index ec359d7..0bf45a3 100644
--- a/src/libDRCdec/src/drcDec_selectionProcess.cpp
+++ b/src/libDRCdec/src/drcDec_selectionProcess.cpp
@@ -387,7 +387,7 @@ struct s_drcdec_selection_process {
 DRCDEC_SELECTION_PROCESS_RETURN
 drcDec_SelectionProcess_Create(HANDLE_DRC_SELECTION_PROCESS* phInstance) {
   HANDLE_DRC_SELECTION_PROCESS hInstance;
-  hInstance = (HANDLE_DRC_SELECTION_PROCESS)FDKcalloc(1, sizeof(struct s_drcdec_selection_process));
+  hInstance = (HANDLE_DRC_SELECTION_PROCESS)mpegh_FDKcalloc(1, sizeof(struct s_drcdec_selection_process));
 
   if (!hInstance) return DRCDEC_SELECTION_PROCESS_OUTOFMEMORY;
 
@@ -635,7 +635,7 @@ DRCDEC_SELECTION_PROCESS_RETURN
 drcDec_SelectionProcess_Delete(HANDLE_DRC_SELECTION_PROCESS* phInstance) {
   if (phInstance == NULL || *phInstance == NULL) return DRCDEC_SELECTION_PROCESS_INVALID_HANDLE;
 
-  FDKfree(*phInstance);
+  mpegh_FDKfree(*phInstance);
   *phInstance = NULL;
   return DRCDEC_SELECTION_PROCESS_NO_ERROR;
 }
@@ -1977,7 +1977,7 @@ static DRCDEC_SELECTION_PROCESS_RETURN _generateVirtualDrcSets(HANDLE_SEL_PROC_I
     return DRCDEC_SELECTION_PROCESS_NOT_OK;
   }
 
-  FDKmemset(pDrcInstruction, 0, sizeof(DRC_INSTRUCTIONS_UNI_DRC));
+  mpegh_FDKmemset(pDrcInstruction, 0, sizeof(DRC_INSTRUCTIONS_UNI_DRC));
 
   pDrcInstruction->drcSetId = indexVirtual;
   index++;
@@ -1992,7 +1992,7 @@ static DRCDEC_SELECTION_PROCESS_RETURN _generateVirtualDrcSets(HANDLE_SEL_PROC_I
 
   for (i = 1; i < nMixes; i++) {
     pDrcInstruction = &(hUniDrcConfig->drcInstructionsUniDrc[index]);
-    FDKmemset(pDrcInstruction, 0, sizeof(DRC_INSTRUCTIONS_UNI_DRC));
+    mpegh_FDKmemset(pDrcInstruction, 0, sizeof(DRC_INSTRUCTIONS_UNI_DRC));
     pDrcInstruction->drcSetId = indexVirtual;
     pDrcInstruction->downmixId[0] = hUniDrcConfig->downmixInstructions[i - 1].downmixId;
     pDrcInstruction->downmixIdCount = 1;
@@ -2368,7 +2368,7 @@ static DRCDEC_SELECTION_PROCESS_RETURN _drcSetRequestSelection(
 static DRCDEC_SELECTION_DATA* _drcdec_selection_addNew(DRCDEC_SELECTION* pSelection) {
   if (pSelection->numData < (32 + 1)) {
     DRCDEC_SELECTION_DATA* pData = &(pSelection->data[pSelection->numData]);
-    FDKmemset(pData, 0, sizeof(DRCDEC_SELECTION_DATA));
+    mpegh_FDKmemset(pData, 0, sizeof(DRCDEC_SELECTION_DATA));
     pSelection->numData++;
 
     return pData;
@@ -2381,7 +2381,7 @@ static DRCDEC_SELECTION_DATA* _drcdec_selection_add(DRCDEC_SELECTION* pSelection
                                                     DRCDEC_SELECTION_DATA* pDataIn) {
   if (pSelection->numData < (32 + 1)) {
     DRCDEC_SELECTION_DATA* pData = &(pSelection->data[pSelection->numData]);
-    FDKmemcpy(pData, pDataIn, sizeof(DRCDEC_SELECTION_DATA));
+    mpegh_FDKmemcpy(pData, pDataIn, sizeof(DRCDEC_SELECTION_DATA));
     pSelection->numData++;
     return pData;
   } else {
diff --git a/src/libDRCdec/src/drcGainDec_init.cpp b/src/libDRCdec/src/drcGainDec_init.cpp
index 68f60e1..96ab81f 100644
--- a/src/libDRCdec/src/drcGainDec_init.cpp
+++ b/src/libDRCdec/src/drcGainDec_init.cpp
@@ -314,7 +314,7 @@ void addVirtualToActiveDrc(HANDLE_DRC_GAIN_DECODER hGainDec) {
     if (!virtualDrcActive) {
       /* add a virtual DRC set */
       pInst = &hGainDec->activeDrc[l][hGainDec->nActiveDrcs[l]].drcInst;
-      FDKmemclear(pInst, sizeof(DRC_INSTRUCTIONS_UNI_DRC));
+      mpegh_FDKmemclear(pInst, sizeof(DRC_INSTRUCTIONS_UNI_DRC));
       pInst->drcSetId = -1;
 
       if (l == 0) {
diff --git a/src/libDRCdec/src/drcGainDec_preprocess.cpp b/src/libDRCdec/src/drcGainDec_preprocess.cpp
index f8cbe5a..64a3ad0 100644
--- a/src/libDRCdec/src/drcGainDec_preprocess.cpp
+++ b/src/libDRCdec/src/drcGainDec_preprocess.cpp
@@ -216,7 +216,7 @@ prepareDrcGain(HANDLE_DRC_GAIN_DECODER hGainDec, HANDLE_UNI_DRC_GAIN hUniDrcGain
   int b, g, gainElementIndex;
   DRC_GAIN_BUFFERS* drcGainBuffers = &(hGainDec->drcGainBuffers);
   NODE_MODIFICATION nodeMod;
-  FDKmemclear(&nodeMod, sizeof(NODE_MODIFICATION));
+  mpegh_FDKmemclear(&nodeMod, sizeof(NODE_MODIFICATION));
   ACTIVE_DRC* pActiveDrc = &(hGainDec->activeDrc[activeDrcLocation][activeDrcIndex]);
   DRC_INSTRUCTIONS_UNI_DRC* pInst = &pActiveDrc->drcInst;
   if (pInst == NULL) return DE_NOT_OK;
diff --git a/src/libFDK/include/FDK_bitstream.h b/src/libFDK/include/FDK_bitstream.h
index c524d4b..58715dc 100644
--- a/src/libFDK/include/FDK_bitstream.h
+++ b/src/libFDK/include/FDK_bitstream.h
@@ -123,7 +123,7 @@ typedef FDK_BITSTREAM* HANDLE_FDK_BITSTREAM;
 FDK_INLINE
 HANDLE_FDK_BITSTREAM FDKcreateBitStream(UCHAR* pBuffer, UINT bufSize,
                                         FDK_BS_CFG config = BS_READER) {
-  HANDLE_FDK_BITSTREAM hBitStream = (HANDLE_FDK_BITSTREAM)FDKcalloc(1, sizeof(FDK_BITSTREAM));
+  HANDLE_FDK_BITSTREAM hBitStream = (HANDLE_FDK_BITSTREAM)mpegh_FDKcalloc(1, sizeof(FDK_BITSTREAM));
   if (hBitStream == NULL) return NULL;
   FDK_InitBitBuffer(&hBitStream->hBitBuf, pBuffer, bufSize, 0);
 
@@ -175,7 +175,7 @@ FDK_INLINE void FDKresetBitbuffer(HANDLE_FDK_BITSTREAM hBitStream, FDK_BS_CFG co
 */
 FDK_INLINE void FDKdeleteBitStream(HANDLE_FDK_BITSTREAM hBitStream) {
   FDK_DeleteBitBuffer(&hBitStream->hBitBuf);
-  FDKfree(hBitStream);
+  mpegh_FDKfree(hBitStream);
 }
 
 /**
diff --git a/src/libFDK/include/FDK_lpc.h b/src/libFDK/include/FDK_lpc.h
index 3a3b61f..002477d 100644
--- a/src/libFDK/include/FDK_lpc.h
+++ b/src/libFDK/include/FDK_lpc.h
@@ -150,7 +150,7 @@ void CLpc_Synthesis(FIXP_DBL* signal, const int signal_size, const int inc, cons
  * \param state state buffer of size LPC_MAX_ORDER
  */
 
-void CLpc_SynthesisLattice(FIXP_DBL* signal, const int signal_size, const int signal_e,
+void mpegh_CLpc_SynthesisLattice(FIXP_DBL* signal, const int signal_size, const int signal_e,
                            const int signal_e_out, const int inc, const FIXP_DBL* coeff,
                            const int order, FIXP_DBL* state);
 
@@ -177,7 +177,7 @@ INT CLpc_ParcorToLpc(const FIXP_LPC reflCoeff[], FIXP_LPC LpcCoeff[], const int
  * \param pPredictionGain_m prediction gain mantissa
  * \param pPredictionGain_e prediction gain exponent
  */
-void CLpc_AutoToParcor(FIXP_DBL acorr[], const int acorr_e, FIXP_LPC reflCoeff[], const int order,
+void mpegh_CLpc_AutoToParcor(FIXP_DBL acorr[], const int acorr_e, FIXP_LPC reflCoeff[], const int order,
                        FIXP_DBL* pPredictionGain_m, INT* pPredictionGain_e);
 
 /**
diff --git a/src/libFDK/include/FDK_matrixCalloc.h b/src/libFDK/include/FDK_matrixCalloc.h
index e9a5c40..2566363 100644
--- a/src/libFDK/include/FDK_matrixCalloc.h
+++ b/src/libFDK/include/FDK_matrixCalloc.h
@@ -94,12 +94,12 @@ amm-info@iis.fraunhofer.de
 #include "machine_type.h"
 #include "genericStds.h"
 
-void* fdkCallocMatrix1D(UINT dim1, UINT size);
-void* fdkCallocMatrix1D_aligned(UINT dim1, UINT size);
+void* mpegh_fdkCallocMatrix1D(UINT dim1, UINT size);
+void* mpegh_fdkCallocMatrix1D_aligned(UINT dim1, UINT size);
 void fdkFreeMatrix1D(void* p);
-void fdkFreeMatrix1D_aligned(void* p);
+void mpegh_fdkFreeMatrix1D_aligned(void* p);
 
-void** fdkCallocMatrix2D(UINT dim1, UINT dim2, UINT size);
-void fdkFreeMatrix2D(void** p);
+void** mpegh_fdkCallocMatrix2D(UINT dim1, UINT dim2, UINT size);
+void mpegh_fdkFreeMatrix2D(void** p);
 
 #endif /* FDK_MATRIXCALLOC_H */
diff --git a/src/libFDK/include/FDK_tools_rom.h b/src/libFDK/include/FDK_tools_rom.h
index 3891eb1..1f14aa2 100644
--- a/src/libFDK/include/FDK_tools_rom.h
+++ b/src/libFDK/include/FDK_tools_rom.h
@@ -107,20 +107,20 @@ extern RAM_ALIGN const LONG RotVector240[210];
 #endif /* USE_PACKED_ROTVECTOR_240 */
 
 /* Regular sine tables */
-extern RAM_ALIGN const FIXP_STP SineTable1024[];
-extern RAM_ALIGN const FIXP_STP SineTable512[];
+extern RAM_ALIGN const FIXP_STP mpegh_SineTable1024[];
+extern RAM_ALIGN const FIXP_STP mpegh_SineTable512[];
 
 /* AAC-LC windows */
-extern RAM_ALIGN const FIXP_WTP SineWindow1024[];
-extern RAM_ALIGN const FIXP_WTP KBDWindow1024[];
-extern RAM_ALIGN const FIXP_WTP SineWindow128[];
-extern RAM_ALIGN const FIXP_WTP KBDWindow128[];
+extern RAM_ALIGN const FIXP_WTP mpegh_SineWindow1024[];
+extern RAM_ALIGN const FIXP_WTP mpegh_KBDWindow1024[];
+extern RAM_ALIGN const FIXP_WTP mpegh_SineWindow128[];
+extern RAM_ALIGN const FIXP_WTP mpegh_KBDWindow128[];
 
 /* AAC-LD windows */
-extern RAM_ALIGN const FIXP_WTP SineWindow512[];
+extern RAM_ALIGN const FIXP_WTP mpegh_SineWindow512[];
 
 /* USAC TCX Window */
-extern RAM_ALIGN const FIXP_WTP SineWindow256[256];
+extern RAM_ALIGN const FIXP_WTP mpegh_SineWindow256[256];
 
 /* USAC 8/3 windows */
 
@@ -128,10 +128,10 @@ extern RAM_ALIGN const FIXP_WTP SineWindow256[256];
 
 /**
  * \brief Helper table for window slope mapping. You should prefer the usage of the
- * function FDKgetWindowSlope(), this table is only made public for some optimized
+ * function mpegh_FDKgetWindowSlope(), this table is only made public for some optimized
  * access inside dct.cpp.
  */
-extern const FIXP_WTP* const windowSlopes[2][4][10];
+extern const FIXP_WTP* const mpegh_windowSlopes[2][4][10];
 
 /**
  * \brief Window slope access helper. Obtain a window of given length and shape.
@@ -140,9 +140,9 @@ extern const FIXP_WTP* const windowSlopes[2][4][10];
  *              value is applied a mask of 1 to, mapping it to either 0 or 1.
  * \param Pointer to window slope or NULL if the requested window slope is not available.
  */
-const FIXP_WTP* FDKgetWindowSlope(int length, int shape);
+const FIXP_WTP* mpegh_FDKgetWindowSlope(int length, int shape);
 
-extern const FIXP_WTP sin_twiddle_L64[];
+extern const FIXP_WTP mpegh_sin_twiddle_L64[];
 
 /*
  * Raw Data Block list items.
@@ -213,7 +213,7 @@ typedef struct element_list element_list_t;
  * \param elFlags element specific flags.
  * \return element_list_t parser guidance structure.
  */
-const element_list_t* getBitstreamElementList(AUDIO_OBJECT_TYPE aot, SCHAR epConfig,
+const element_list_t* mpegh_getBitstreamElementList(AUDIO_OBJECT_TYPE aot, SCHAR epConfig,
                                               UCHAR nChannels, UCHAR layer, UINT elFlags);
 
 typedef enum {
diff --git a/src/libFDK/include/FDK_trigFcts.h b/src/libFDK/include/FDK_trigFcts.h
index fc11c23..5a6e5bb 100644
--- a/src/libFDK/include/FDK_trigFcts.h
+++ b/src/libFDK/include/FDK_trigFcts.h
@@ -95,15 +95,15 @@ amm-info@iis.fraunhofer.de
 
 #include "FDK_tools_rom.h"
 
-FIXP_DBL fixp_cos(FIXP_DBL x, int scale);
-FIXP_DBL fixp_sin(FIXP_DBL x, int scale);
-void fixp_cos_sin(FIXP_DBL x, int scale, FIXP_DBL* cos, FIXP_DBL* sin);
+FIXP_DBL mpegh_fixp_cos(FIXP_DBL x, int scale);
+FIXP_DBL mpegh_fixp_sin(FIXP_DBL x, int scale);
+void mpegh_fixp_cos_sin(FIXP_DBL x, int scale, FIXP_DBL* cos, FIXP_DBL* sin);
 
 #define FIXP_COS_SIN
 
 #include "FDK_tools_rom.h"
 
-#define SINETAB SineTable512
+#define SINETAB mpegh_SineTable512
 #define LD 9
 
 #ifndef FUNCTION_inline_fixp_cos_sin
diff --git a/src/libFDK/include/arm/FDK_aarch64_neon_funcs.h b/src/libFDK/include/arm/FDK_aarch64_neon_funcs.h
index 88f9010..5e47499 100644
--- a/src/libFDK/include/arm/FDK_aarch64_neon_funcs.h
+++ b/src/libFDK/include/arm/FDK_aarch64_neon_funcs.h
@@ -3224,11 +3224,11 @@ void FDK_check_s16_overflow(FIXP_DBL value)
 {
   if (value > (FIXP_DBL) 0x7FFF)
   {
-    FDKprintf("Error: 16-bit overflow: 0x%016X\n", value);
+    mpegh_FDKprintf("Error: 16-bit overflow: 0x%016X\n", value);
   }
   else if (value < (FIXP_DBL) 0x8000)
   {
-    FDKprintf("Error: 16-bit underflow: 0x%016X\n", value);
+    mpegh_FDKprintf("Error: 16-bit underflow: 0x%016X\n", value);
   }
 }
 
@@ -3237,11 +3237,11 @@ void FDK_check_s32_overflow(INT64 value)
 {
   if (value > (INT64) 0x7FFFFFFF)
   {
-    FDKprintf("Error: 32-bit overflow: 0x%016X\n", value);
+    mpegh_FDKprintf("Error: 32-bit overflow: 0x%016X\n", value);
   }
   else if (-value > (INT64) 2147483648 /* 0x8000.000 */)
   {
-    FDKprintf("Error: 32-bit underflow: 0x%016X\n", value);
+    mpegh_FDKprintf("Error: 32-bit underflow: 0x%016X\n", value);
   }
 }
 
@@ -3269,15 +3269,15 @@ void A64_check_move_immediate_sp(float immediate)
    if ( (imm > 31.f) || ((imm - (int) imm) != 0.f) )
    {
      /*  Mantissa exceeds */
-     FDKprintf("Error in float immediate mantissa: %f = %f *2^%d\n", immediate, imm, exponent);
+     mpegh_FDKprintf("Error in float immediate mantissa: %f = %f *2^%d\n", immediate, imm, exponent);
    }
    else if ( (exponent > 0) || (exponent < -7) )
    {
      /* Exponent exceeds */
-     FDKprintf("Error in float immediate exponent: %f = %f *2^%d\n", immediate, imm, exponent);
+     mpegh_FDKprintf("Error in float immediate exponent: %f = %f *2^%d\n", immediate, imm, exponent);
    }
    else
-     FDKprintf("Success in float immediate check: %f = %f *2^%d\n", immediate, imm, exponent);
+     mpegh_FDKprintf("Success in float immediate check: %f = %f *2^%d\n", immediate, imm, exponent);
 }
 
 void A64_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
@@ -3298,28 +3298,28 @@ void A64_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
     if (datatype == 8)
     {
       if (sign == -1)
-        FDKprintf ("Error in MVN instruction: I8 datatype not available\n");
+        mpegh_FDKprintf ("Error in MVN instruction: I8 datatype not available\n");
 
       else if (byte1 | byte2 | byte3 | byte4 | byte5 | byte6 | byte7)
       {
-        FDKprintf ("Error in 8-bit immediate: 0x%016X - upper bytes must be 0x00\n", immediate);
+        mpegh_FDKprintf ("Error in 8-bit immediate: 0x%016X - upper bytes must be 0x00\n", immediate);
       }
     }
     else if (datatype == 16)
     {
       if (byte2 | byte3 | byte4 | byte5 | byte6 | byte7)
       {
-        FDKprintf ("Error in 16-bit immediate: 0x%016X - upper bits (>16) must be unique\n", immediate);
+        mpegh_FDKprintf ("Error in 16-bit immediate: 0x%016X - upper bits (>16) must be unique\n", immediate);
       }
       else
       {
         if ((sign == 1) && !( (byte0 == 0x00) || (byte1 == 0x00) ))
         {
-          FDKprintf ("Error in 16-bit immediate: 0x%016X - one of the lower 2 bytes must be 0x00\n", immediate);
+          mpegh_FDKprintf ("Error in 16-bit immediate: 0x%016X - one of the lower 2 bytes must be 0x00\n", immediate);
         }
         else if ((sign == -1) && !( (byte0 == 0xFF) || (byte1 == 0xFF) ))
         {
-          FDKprintf ("Error in 16-bit immediate: 0x%016X - one of the lower 2 bytes must be 0xFF\n", immediate);
+          mpegh_FDKprintf ("Error in 16-bit immediate: 0x%016X - one of the lower 2 bytes must be 0xFF\n", immediate);
         }
       }
     }
@@ -3327,11 +3327,11 @@ void A64_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
     {
       if ( (sign == 1) && ((byte4 | byte5 | byte6 | byte7) != 0x00) )
       {
-        FDKprintf ("Error in 32-bit immediate: 0x%016X - upper 4 bytes must be 0x00\n", immediate);
+        mpegh_FDKprintf ("Error in 32-bit immediate: 0x%016X - upper 4 bytes must be 0x00\n", immediate);
       }
       else if ( (sign == -1) && !( ((byte4 & byte5 & byte6 & byte7) != 0xFF) || ((byte4 | byte5 | byte6 | byte7) != 0x00)) )
       {
-        FDKprintf ("Error in 32-bit immediate: 0x%016X - upper 4 bytes must be 0xFF/0x00\n", immediate);
+        mpegh_FDKprintf ("Error in 32-bit immediate: 0x%016X - upper 4 bytes must be 0xFF/0x00\n", immediate);
       }
       if (sign == 1)
       {
@@ -3340,7 +3340,7 @@ void A64_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
               (byte2 && !(byte0 | byte1 | byte3))   || (byte3 && !(byte0 | byte1 | byte2)) ||
               ((byte0 == 0xFF) && !(byte2 | byte3)) || (((byte0 & byte1) == 0xFF) && !byte3)))
         {
-          FDKprintf ("Error in 32-bit immediate: 0x%016X - upper fillbytes must be 0x00, lower fillbytes must be 0x00/0xFF\n", immediate);
+          mpegh_FDKprintf ("Error in 32-bit immediate: 0x%016X - upper fillbytes must be 0x00, lower fillbytes must be 0x00/0xFF\n", immediate);
         }
       }
       else
@@ -3350,21 +3350,21 @@ void A64_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
               ((byte2 != 0xFF) && ((byte1 & byte0 & byte3) == 0xFF)) || ((byte3 != 0xFF) && ((byte1 & byte2 & byte0) == 0xFF)) ||
               (!byte0 && ((byte2 & byte3) == 0xFF)) || (!(byte0 | byte1) && (byte3 == 0xFF)) ) )
         {
-          FDKprintf ("Error in 32-bit immediate: 0x%016X - upper fillbytes must be 0xFF, lower fillbytes must be 0xFF/0x00\n", immediate);
+          mpegh_FDKprintf ("Error in 32-bit immediate: 0x%016X - upper fillbytes must be 0xFF, lower fillbytes must be 0xFF/0x00\n", immediate);
         }
       }
     }
     else if (datatype == 64)
     {
       if (sign == -1)
-        FDKprintf ("Error in MVN instruction: I64 datatype not available\n");
+        mpegh_FDKprintf ("Error in MVN instruction: I64 datatype not available\n");
       // all bytes must match either 0x00 or 0xFF
       else if (!(( (byte0 == 0x00) || (byte0 == 0xFF) ) || ( (byte1 == 0x00) || (byte1 == 0xFF) ) ||
                  ( (byte2 == 0x00) || (byte2 == 0xFF) ) || ( (byte3 == 0x00) || (byte3 == 0xFF) ) ||
                  ( (byte4 == 0x00) || (byte4 == 0xFF) ) || ( (byte5 == 0x00) || (byte5 == 0xFF) ) ||
                  ( (byte6 == 0x00) || (byte6 == 0xFF) ) || ( (byte7 == 0x00) || (byte7 == 0xFF) ) ))
       {
-        FDKprintf ("Error in 64-bit immediate: 0x%16X - any byte must be either 0x00/0xFF\n", immediate);
+        mpegh_FDKprintf ("Error in 64-bit immediate: 0x%16X - any byte must be either 0x00/0xFF\n", immediate);
       }
     }
   }
@@ -3470,7 +3470,7 @@ static inline void __A64_mvni_i32_lsl(int size, A64_S *dst, INT64 imm, int lsl)
       }
     }
     else
-       FDKprintf ("Error in MVNI instruction: LSL operand (%d) must be in range [0,8,16,24]\n", lsl);
+       mpegh_FDKprintf ("Error in MVNI instruction: LSL operand (%d) must be in range [0,8,16,24]\n", lsl);
 }
 static inline void __A64_mvni_i32_msl(int size, A64_S *dst, INT64 imm, int msl)
 {
@@ -3484,7 +3484,7 @@ static inline void __A64_mvni_i32_msl(int size, A64_S *dst, INT64 imm, int msl)
       }
     }
     else
-       FDKprintf ("Error in MVNI instruction: MSL operand (%d) must be in range [8,16]\n", msl);
+       mpegh_FDKprintf ("Error in MVNI instruction: MSL operand (%d) must be in range [8,16]\n", msl);
 }
 
 /* MOVI Vn.<T>, #uimm8  <T> is 8B or 16B */
diff --git a/src/libFDK/include/arm/FDK_neon_funcs.h b/src/libFDK/include/arm/FDK_neon_funcs.h
index 5d0a4fe..5eb9598 100644
--- a/src/libFDK/include/arm/FDK_neon_funcs.h
+++ b/src/libFDK/include/arm/FDK_neon_funcs.h
@@ -2647,11 +2647,11 @@ void FDK_check_s16_overflow(FIXP_DBL value)
 {
   if (value > (FIXP_DBL) 0x7FFF)
   {
-    FDKprintf("Error: 16-bit overflow: 0x%016X\n", value);
+    mpegh_FDKprintf("Error: 16-bit overflow: 0x%016X\n", value);
   }
   else if (value < (FIXP_DBL) 0xFFFF8000)
   {
-    FDKprintf("Error: 16-bit underflow: 0x%016X\n", value);
+    mpegh_FDKprintf("Error: 16-bit underflow: 0x%016X\n", value);
   }
 }
 
@@ -2660,11 +2660,11 @@ void FDK_check_s32_overflow(INT64 value)
 {
   if (value > (INT64) 0x7FFFFFFF)
   {
-    FDKprintf("Error: 32-bit overflow: 0x%016X\n", value);
+    mpegh_FDKprintf("Error: 32-bit overflow: 0x%016X\n", value);
   }
   else if (-value > (INT64) 2147483648 /* 0x8000.000 */)
   {
-    FDKprintf("Error: 32-bit underflow: 0x%016X\n", value);
+    mpegh_FDKprintf("Error: 32-bit underflow: 0x%016X\n", value);
   }
 }
 
@@ -2685,7 +2685,7 @@ void FDK_check_move_float_immediate(FLOAT immediate)
       if (testFloat == immediate) return;
     }
 
-  FDKprintf("Error: %f can not expressed as  +/- n * 2^(-r), where n and r are integers, 16 <= n <= 31, 0 <= r <= 7 \n", immediate);
+  mpegh_FDKprintf("Error: %f can not expressed as  +/- n * 2^(-r), where n and r are integers, 16 <= n <= 31, 0 <= r <= 7 \n", immediate);
 }
 
 void FDK_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
@@ -2707,10 +2707,10 @@ void FDK_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
     if (datatype == 8)
     {
       if (sign == -1)
-        FDKprintf ("Error in 8-bit MVN immediate: 0x%16X - Use VMOV instead of VMVN for 8-bit constants\n", ~immediate);
+        mpegh_FDKprintf ("Error in 8-bit MVN immediate: 0x%16X - Use VMOV instead of VMVN for 8-bit constants\n", ~immediate);
       if (byte1 | byte2 | byte3 | byte4 | byte5 | byte6 | byte7)
       {
-        FDKprintf ("Error in 8-bit immediate: 0x%016X - upper bytes must be 0x00\n", immediate);
+        mpegh_FDKprintf ("Error in 8-bit immediate: 0x%016X - upper bytes must be 0x00\n", immediate);
       }
     }
     else if (datatype == 16)
@@ -2718,9 +2718,9 @@ void FDK_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
       if (byte2 | byte3 | byte4 | byte5 | byte6 | byte7)
       {
         if (sign == 1)
-          FDKprintf ("Error in 16-bit MOV immediate: 0x%016X - upper bits (>16) must be 0x00\n", immediate);
+          mpegh_FDKprintf ("Error in 16-bit MOV immediate: 0x%016X - upper bits (>16) must be 0x00\n", immediate);
         else
-          FDKprintf ("Error in 16-bit MVN immediate: 0x%016X - upper bits (>16) must be 0xFF\n", ~immediate);
+          mpegh_FDKprintf ("Error in 16-bit MVN immediate: 0x%016X - upper bits (>16) must be 0xFF\n", ~immediate);
       }
       else
       {
@@ -2730,9 +2730,9 @@ void FDK_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
               (((INT64) byte1 <<  8) == immediate) ))
         {
            if (sign == 1)
-             FDKprintf ("Error in 16-bit MOV immediate: 0x%016X - must be in range: 0x00XY, 0xXY00\n", immediate);
+             mpegh_FDKprintf ("Error in 16-bit MOV immediate: 0x%016X - must be in range: 0x00XY, 0xXY00\n", immediate);
            else
-             FDKprintf ("Error in 16-bit MVN immediate: 0x%016X - must be in range: 0xFFXY, 0xXYFF\n", ~immediate);
+             mpegh_FDKprintf ("Error in 16-bit MVN immediate: 0x%016X - must be in range: 0xFFXY, 0xXYFF\n", ~immediate);
         }
       }
     }
@@ -2743,9 +2743,9 @@ void FDK_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
         if (byte4 | byte5 | byte6 | byte7)
         {
            if (sign == 1)
-             FDKprintf ("Error in 32-bit MOV immediate: 0x%016X - upper fillbytes must be 0x00\n", immediate);
+             mpegh_FDKprintf ("Error in 32-bit MOV immediate: 0x%016X - upper fillbytes must be 0x00\n", immediate);
            else
-             FDKprintf ("Error in 32-bit MVN immediate: 0x%016X - upper fillbytes must be 0xFF\n", ~immediate);
+             mpegh_FDKprintf ("Error in 32-bit MVN immediate: 0x%016X - upper fillbytes must be 0xFF\n", ~immediate);
         }
         if (!((((INT64) byte0 <<  0) == immediate) ||
               (((INT64) byte1 <<  8) == immediate) ||
@@ -2755,15 +2755,15 @@ void FDK_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
               ((((INT64) byte2 << 16) | 0xFFFF) == immediate) ))
         {
            if (sign == 1)
-             FDKprintf ("Error in 32-bit MOV immediate: 0x%016X - must be in range: 0x000000XY, 0x0000XY00, 0x00XY0000, 0xXY000000, 0x0000XYFF, 0x00XYFFFF \n", immediate);
+             mpegh_FDKprintf ("Error in 32-bit MOV immediate: 0x%016X - must be in range: 0x000000XY, 0x0000XY00, 0x00XY0000, 0xXY000000, 0x0000XYFF, 0x00XYFFFF \n", immediate);
            else
-             FDKprintf ("Error in 32-bit MVN immediate: 0x%016X - must be in range: 0xFFFFFFXY, 0xFFFFXYFF, 0xFFXYFFFF, 0xXYFFFFFF, 0xFFFFXY00, 0xFFXY0000 \n",~immediate);
+             mpegh_FDKprintf ("Error in 32-bit MVN immediate: 0x%016X - must be in range: 0xFFFFFFXY, 0xFFFFXYFF, 0xFFXYFFFF, 0xXYFFFFFF, 0xFFFFXY00, 0xFFXY0000 \n",~immediate);
         }
     }
     else if (datatype == 64)
     {
       if (sign == -1)
-        FDKprintf ("Error in 64-bit MVN immediate: 0x%16X - Use VMOV instead of VMVN for 64-bit constants\n", ~immediate);
+        mpegh_FDKprintf ("Error in 64-bit MVN immediate: 0x%16X - Use VMOV instead of VMVN for 64-bit constants\n", ~immediate);
 
       /* all bytes must match either 0x00 or 0xFF */
       if (!(( (byte0 == 0x00) || (byte0 == 0xFF) ) || ( (byte1 == 0x00) || (byte1 == 0xFF) ) ||
@@ -2771,7 +2771,7 @@ void FDK_check_move_immediate(int size, int datatype, int sign, INT64 immediate)
             ( (byte4 == 0x00) || (byte4 == 0xFF) ) || ( (byte5 == 0x00) || (byte5 == 0xFF) ) ||
             ( (byte6 == 0x00) || (byte6 == 0xFF) ) || ( (byte7 == 0x00) || (byte7 == 0xFF) ) ))
       {
-        FDKprintf ("Error in 64-bit MOV immediate: 0x%16X - any byte must be either 0x00/0xFF\n", immediate);
+        mpegh_FDKprintf ("Error in 64-bit MOV immediate: 0x%16X - any byte must be either 0x00/0xFF\n", immediate);
       }
     }
   }
diff --git a/src/libFDK/include/fixpoint_math.h b/src/libFDK/include/fixpoint_math.h
index b0a2764..fa048a2 100644
--- a/src/libFDK/include/fixpoint_math.h
+++ b/src/libFDK/include/fixpoint_math.h
@@ -132,7 +132,7 @@ static const FIXP_SGL ldCoeff[MAX_LD_PRECISION] = {
 #define SQRT_BITS_MASK 0x7f
 #define SQRT_FRACT_BITS_MASK 0x007FFFFF
 
-extern const FIXP_DBL invSqrtTab[SQRT_VALUES];
+extern const FIXP_DBL mpegh_invSqrtTab[SQRT_VALUES];
 
 /*
  * Hardware specific implementations
@@ -242,7 +242,7 @@ FDK_INLINE FIXP_DBL CalcInvLdData(const FIXP_DBL x) {
 void InitLdInt();
 FIXP_DBL CalcLdInt(INT i);
 
-extern const USHORT sqrt_tab[49];
+extern const USHORT mpegh_sqrt_tab[49];
 
 inline FIXP_DBL sqrtFixp_lookup(FIXP_DBL x) {
   UINT y = (INT)x;
@@ -254,7 +254,7 @@ inline FIXP_DBL sqrtFixp_lookup(FIXP_DBL x) {
     UINT idx = (y >> 26) - 16;
     USHORT frac = (y >> 10) & 0xffff;
     USHORT nfrac = 0xffff ^ frac;
-    t = (UINT)nfrac * sqrt_tab[idx] + (UINT)frac * sqrt_tab[idx + 1];
+    t = (UINT)nfrac * mpegh_sqrt_tab[idx] + (UINT)frac * mpegh_sqrt_tab[idx + 1];
     t = t >> (zeros >> 1);
   }
   return t;
@@ -282,7 +282,7 @@ inline FIXP_DBL sqrtFixp_lookup(FIXP_DBL x, INT* x_e) {
   UINT idx = (y >> 26) - 16;
   USHORT frac = (y >> 10) & 0xffff;
   USHORT nfrac = 0xffff ^ frac;
-  UINT t = (UINT)nfrac * sqrt_tab[idx] + (UINT)frac * sqrt_tab[idx + 1];
+  UINT t = (UINT)nfrac * mpegh_sqrt_tab[idx] + (UINT)frac * mpegh_sqrt_tab[idx + 1];
 
   /* Write back exponent */
   *x_e = e >> 1;
@@ -327,15 +327,15 @@ static FDK_FORCEINLINE FIXP_DBL invSqrtNorm2(FIXP_DBL op, INT* shift) {
 #if defined(INVSQRTNORM2_LINEAR_INTERPOLATE)
   INT index = (INT)(val >> (DFRACT_BITS - 1 - (SQRT_BITS + 1))) & SQRT_BITS_MASK;
   FIXP_DBL Fract = (FIXP_DBL)(((INT)val & SQRT_FRACT_BITS_MASK) << (SQRT_BITS + 1));
-  FIXP_DBL diff = invSqrtTab[index + 1] - invSqrtTab[index];
-  reg1 = invSqrtTab[index] + (fMultDiv2(diff, Fract) << 1);
+  FIXP_DBL diff = mpegh_invSqrtTab[index + 1] - mpegh_invSqrtTab[index];
+  reg1 = mpegh_invSqrtTab[index] + (fMultDiv2(diff, Fract) << 1);
 #if defined(INVSQRTNORM2_LINEAR_INTERPOLATE_HQ)
   /* reg1 = t[i] + (t[i+1]-t[i])*fract ... already computed ...
                                        + (1-fract)fract*(t[i+2]-t[i+1])/2 */
   if (Fract != (FIXP_DBL)0) {
     /* fract = fract * (1 - fract) */
     Fract = fMultDiv2(Fract, (FIXP_DBL)((ULONG)0x80000000 - (LONG)Fract)) << 1;
-    diff = diff - (invSqrtTab[index + 2] - invSqrtTab[index + 1]);
+    diff = diff - (mpegh_invSqrtTab[index + 2] - mpegh_invSqrtTab[index + 1]);
     reg1 = fMultAddDiv2(reg1, Fract, diff);
   }
 #endif /* INVSQRTNORM2_LINEAR_INTERPOLATE_HQ */
@@ -919,7 +919,7 @@ FIXP_DBL fixp_round(FIXP_DBL f_inp, INT sf);
 
 ****************************************************************************/
 
-extern const FIXP_DBL invCount[80];
+extern const FIXP_DBL mpegh_invCount[80];
 
 LNK_SECTION_INITCODE
 inline void InitInvInt(void) {}
@@ -931,7 +931,7 @@ inline void InitInvInt(void) {}
  * \param FIXP_DBL representation of 1/intValue
  */
 inline FIXP_DBL GetInvInt(int intValue) {
-  return invCount[fMin(fMax(intValue, 0), 80 - 1)];
+  return mpegh_invCount[fMin(fMax(intValue, 0), 80 - 1)];
 }
 
 #endif /* FIXPOINT_MATH_H */
diff --git a/src/libFDK/include/mdct.h b/src/libFDK/include/mdct.h
index 3730930..a2a5ca3 100644
--- a/src/libFDK/include/mdct.h
+++ b/src/libFDK/include/mdct.h
@@ -147,7 +147,7 @@ typedef mdct_t* H_MDCT;
  * \param overlap pointer to FIXP_DBL overlap buffer.
  * \param overlapBufferSize size in FIXP_DBLs of the given overlap buffer.
  */
-void mdct_init(H_MDCT hMdct, FIXP_DBL* overlap, INT overlapBufferSize);
+void mpegh_mdct_init(H_MDCT hMdct, FIXP_DBL* overlap, INT overlapBufferSize);
 
 /**
  * \brief perform MDCT transform (time domain to frequency domain) with given parameters.
@@ -172,18 +172,18 @@ INT mdct_block(H_MDCT hMdct, const INT_PCM* RESTRICT pTimeData, const INT noInSa
  * \param pExponent pointer to the exponent of a gain factor to be applied to IMDCT data.
  * \param tl length of the IMDCT where the gain *pGain * (2 ^ *pExponent) will be applied to.
  */
-void imdct_gain(FIXP_DBL* pGain, int* pExponent, int tl);
+void mpegh_imdct_gain(FIXP_DBL* pGain, int* pExponent, int tl);
 
 /**
  * \brief drain buffered output samples into given buffer. Changes the MDCT state.
  */
-INT imdct_drain(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamplesRoom);
+INT mpegh_imdct_drain(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamplesRoom);
 
 /**
  * \brief Copy overlap time domain data to given buffer. Does not change the MDCT state.
  * \return number of actually copied samples (ov + nr).
  */
-INT imdct_copy_ov_and_nr(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamples);
+INT mpegh_imdct_copy_ov_and_nr(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamples);
 
 INT imdct_copy_full(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamples);
 
@@ -196,7 +196,7 @@ INT imdct_copy_full(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamples);
  * \param wls pointer to the left side overlap window coefficients.
  * \param noOutSamples desired number of output samples.
  */
-void imdct_adapt_parameters(H_MDCT hMdct, int* pfl, int* pnl, int tl, const FIXP_WTP* wls,
+void mpegh_imdct_adapt_parameters(H_MDCT hMdct, int* pfl, int* pnl, int tl, const FIXP_WTP* wls,
                             int noOutSamples);
 
 /**
@@ -218,7 +218,7 @@ void imdct_adapt_parameters(H_MDCT hMdct, int* pfl, int* pnl, int tl, const FIXP
  * \param flags flags controlling the type of transform
  * \return number of output samples returned.
  */
-INT imlt_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum, const SHORT scalefactor[],
+INT mpegh_imlt_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum, const SHORT scalefactor[],
                const INT nSpec, const INT noOutSamples, const INT tl, const FIXP_WTP* wls, INT fl,
                const FIXP_WTP* wrs, const INT fr, FIXP_DBL gain, int flags);
 
@@ -246,7 +246,7 @@ inline INT imdct_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum,
                        FIXP_DBL gain) {
   hMdct->prevAliasSymmetry = 0;
   hMdct->prevPrevAliasSymmetry = 0;
-  return imlt_block(hMdct, output, spectrum, scalefactor, nSpec, noOutSamples, tl, wls, fl, wrs, fr,
+  return mpegh_imlt_block(hMdct, output, spectrum, scalefactor, nSpec, noOutSamples, tl, wls, fl, wrs, fr,
                     gain, 0);
 }
 
@@ -274,7 +274,7 @@ inline INT imdst_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum,
                        FIXP_DBL gain) {
   hMdct->prevAliasSymmetry = 1;
   hMdct->prevPrevAliasSymmetry = 1;
-  return imlt_block(hMdct, output, spectrum, scalefactor, nSpec, noOutSamples, tl, wls, fl, wrs, fr,
+  return mpegh_imlt_block(hMdct, output, spectrum, scalefactor, nSpec, noOutSamples, tl, wls, fl, wrs, fr,
                     gain, MLT_FLAG_CURR_ALIAS_SYMMETRY);
 }
 
diff --git a/src/libFDK/include/scale.h b/src/libFDK/include/scale.h
index 5ee917d..7c5a449 100644
--- a/src/libFDK/include/scale.h
+++ b/src/libFDK/include/scale.h
@@ -102,25 +102,25 @@ amm-info@iis.fraunhofer.de
 
 #endif
 
-void scaleValues(FIXP_SGL* vector, INT len, INT scalefactor);
-void scaleValues(FIXP_DBL* vector, INT len, INT scalefactor);
-void scaleValues(FIXP_DBL* dst, const FIXP_DBL* src, INT len, INT scalefactor);
+void mpegh_scaleValues(FIXP_SGL* vector, INT len, INT scalefactor);
+void mpegh_scaleValues(FIXP_DBL* vector, INT len, INT scalefactor);
+void mpegh_scaleValues(FIXP_DBL* dst, const FIXP_DBL* src, INT len, INT scalefactor);
 #if (SAMPLE_BITS == 16)
-void scaleValues(FIXP_PCM* dst, const FIXP_DBL* src, INT len, INT scalefactor);
+void mpegh_scaleValues(FIXP_PCM* dst, const FIXP_DBL* src, INT len, INT scalefactor);
 #endif
-void scaleValues(FIXP_SGL* dst, const FIXP_SGL* src, INT len, INT scalefactor);
+void mpegh_scaleValues(FIXP_SGL* dst, const FIXP_SGL* src, INT len, INT scalefactor);
 void scaleCplxValues(FIXP_DBL* r_dst, FIXP_DBL* i_dst, const FIXP_DBL* r_src, const FIXP_DBL* i_src,
                      INT len, INT scalefactor);
-void scaleValuesWithFactor(FIXP_DBL* vector, FIXP_DBL factor, INT len, INT scalefactor);
-void scaleValuesSaturate(FIXP_DBL* vector, INT len, INT scalefactor);
-void scaleValuesSaturate(FIXP_DBL* dst, const FIXP_DBL* src, INT len, INT scalefactor);
-void scaleValuesSaturate(FIXP_SGL* dst, const FIXP_DBL* src, INT len, INT scalefactor);
-void scaleValuesSaturate(FIXP_SGL* vector, INT len, INT scalefactor);
-void scaleValuesSaturate(FIXP_SGL* dst, const FIXP_SGL* src, INT len, INT scalefactor);
-INT getScalefactorShort(const SHORT* vector, INT len);
+void mpegh_scaleValuesWithFactor(FIXP_DBL* vector, FIXP_DBL factor, INT len, INT scalefactor);
+void mpegh_scaleValuesSaturate(FIXP_DBL* vector, INT len, INT scalefactor);
+void mpegh_scaleValuesSaturate(FIXP_DBL* dst, const FIXP_DBL* src, INT len, INT scalefactor);
+void mpegh_scaleValuesSaturate(FIXP_SGL* dst, const FIXP_DBL* src, INT len, INT scalefactor);
+void mpegh_scaleValuesSaturate(FIXP_SGL* vector, INT len, INT scalefactor);
+void mpegh_scaleValuesSaturate(FIXP_SGL* dst, const FIXP_SGL* src, INT len, INT scalefactor);
+INT mpegh_getScalefactorShort(const SHORT* vector, INT len);
 INT getScalefactorPCM(const INT_PCM* vector, INT len, INT stride);
-INT getScalefactor(const FIXP_DBL* vector, INT len);
-INT getScalefactor(const FIXP_SGL* vector, INT len);
+INT mpegh_getScalefactor(const FIXP_DBL* vector, INT len);
+INT mpegh_getScalefactor(const FIXP_SGL* vector, INT len);
 
 #ifndef FUNCTION_scaleValue
 /*!
diff --git a/src/libFDK/src/FDK_bitbuffer.cpp b/src/libFDK/src/FDK_bitbuffer.cpp
index 6736a96..01b384e 100644
--- a/src/libFDK/src/FDK_bitbuffer.cpp
+++ b/src/libFDK/src/FDK_bitbuffer.cpp
@@ -104,7 +104,7 @@ const UINT BitMask[32 + 1] = {0x0,        0x1,        0x3,       0x7,       0xf,
 void FDK_CreateBitBuffer(HANDLE_FDK_BITBUF* hBitBuf, UCHAR* pBuffer, UINT bufSize) {
   FDK_InitBitBuffer(*hBitBuf, pBuffer, bufSize, 0);
 
-  FDKmemclear((*hBitBuf)->Buffer, bufSize * sizeof(UCHAR));
+  mpegh_FDKmemclear((*hBitBuf)->Buffer, bufSize * sizeof(UCHAR));
 }
 
 void FDK_DeleteBitBuffer(HANDLE_FDK_BITBUF hBitBuf) {
@@ -357,7 +357,7 @@ void FDK_Feed(HANDLE_FDK_BITBUF hBitBuf, const UCHAR* RESTRICT inputBuffer, cons
     bToRead = fMin(bToRead, noOfBytes);  //(bToRead < noOfBytes) ? bToRead : noOfBytes ;
 
     /* copy 'bToRead' bytes from 'ptr' to inputbuffer */
-    FDKmemcpy(&hBitBuf->Buffer[hBitBuf->ReadOffset], inputBuffer, bToRead * sizeof(UCHAR));
+    mpegh_FDKmemcpy(&hBitBuf->Buffer[hBitBuf->ReadOffset], inputBuffer, bToRead * sizeof(UCHAR));
 
     /* add noOfBits to number of valid bits in buffer */
     hBitBuf->ValidBits += (INT)(bToRead << 3);
@@ -434,7 +434,7 @@ void FDK_Fetch(HANDLE_FDK_BITBUF hBitBuf, UCHAR* outBuf, UINT* writeBytes) {
     bToWrite = fMin(bToWrite, noOfBytes);  //(bToWrite < noOfBytes) ? bToWrite : noOfBytes ;
 
     /* copy 'bToWrite' bytes from bitbuffer to outputbuffer */
-    FDKmemcpy(outputBuffer, &hBitBuf->Buffer[hBitBuf->WriteOffset], bToWrite * sizeof(UCHAR));
+    mpegh_FDKmemcpy(outputBuffer, &hBitBuf->Buffer[hBitBuf->WriteOffset], bToWrite * sizeof(UCHAR));
 
     /* sub noOfBits from number of valid bits in buffer */
     hBitBuf->ValidBits -= bToWrite << 3;
diff --git a/src/libFDK/src/FDK_lpc.cpp b/src/libFDK/src/FDK_lpc.cpp
index 8b881d1..4890ca5 100644
--- a/src/libFDK/src/FDK_lpc.cpp
+++ b/src/libFDK/src/FDK_lpc.cpp
@@ -104,7 +104,7 @@ static const SCHAR order_ld[LPC_MAX_ORDER] = {
 
 /* IIRLattice */
 #ifndef FUNCTION_CLpc_SynthesisLattice_SGL
-void CLpc_SynthesisLattice(FIXP_DBL* signal, const int signal_size, const int signal_e,
+void mpegh_CLpc_SynthesisLattice(FIXP_DBL* signal, const int signal_size, const int signal_e,
                            const int signal_e_out, const int inc, const FIXP_SGL* coeff,
                            const int order, FIXP_DBL* state) {
   int i, j;
@@ -154,7 +154,7 @@ void CLpc_SynthesisLattice(FIXP_DBL* signal, const int signal_size, const int si
 #endif
 
 #ifndef FUNCTION_CLpc_SynthesisLattice_DBL
-void CLpc_SynthesisLattice(FIXP_DBL* signal, const int signal_size, const int signal_e,
+void mpegh_CLpc_SynthesisLattice(FIXP_DBL* signal, const int signal_size, const int signal_e,
                            const int signal_e_out, const int inc, const FIXP_DBL* coeff,
                            const int order, FIXP_DBL* state) {
   int i, j;
@@ -208,8 +208,8 @@ void CLpc_Synthesis(FIXP_DBL* signal, const int signal_size, const int inc,
   int lpcCoeffShift = lpcCoeff_e + 1;
 
   FIXP_LPC_TNS coeff[2 * LPC_MAX_ORDER];
-  FDKmemcpy(&coeff[0], lpcCoeff_m, order * sizeof(FIXP_LPC_TNS));
-  FDKmemcpy(&coeff[order], lpcCoeff_m, order * sizeof(FIXP_LPC_TNS));
+  mpegh_FDKmemcpy(&coeff[0], lpcCoeff_m, order * sizeof(FIXP_LPC_TNS));
+  mpegh_FDKmemcpy(&coeff[order], lpcCoeff_m, order * sizeof(FIXP_LPC_TNS));
 
   FDK_ASSERT(lpcCoeffShift >= 0);
   FDK_ASSERT(order <= LPC_MAX_ORDER);
@@ -252,8 +252,8 @@ void CLpc_Synthesis(FIXP_DBL* signal, const int signal_size, const int inc,
   int lpcCoeffShift = lpcCoeff_e + 1;
 
   FIXP_LPC coeff[2 * LPC_MAX_ORDER];
-  FDKmemcpy(&coeff[0], lpcCoeff_m, order * sizeof(FIXP_LPC));
-  FDKmemcpy(&coeff[order], lpcCoeff_m, order * sizeof(FIXP_LPC));
+  mpegh_FDKmemcpy(&coeff[0], lpcCoeff_m, order * sizeof(FIXP_LPC));
+  mpegh_FDKmemcpy(&coeff[order], lpcCoeff_m, order * sizeof(FIXP_LPC));
 
   FDK_ASSERT(lpcCoeffShift >= 0);
   FDK_ASSERT(order <= LPC_MAX_ORDER);
@@ -404,7 +404,7 @@ INT CLpc_ParcorToLpc(const FIXP_LPC reflCoeff[], FIXP_LPC LpcCoeff[], const int
   return (shiftval);
 }
 
-void CLpc_AutoToParcor(FIXP_DBL acorr[], const int acorr_e, FIXP_LPC reflCoeff[],
+void mpegh_CLpc_AutoToParcor(FIXP_DBL acorr[], const int acorr_e, FIXP_LPC reflCoeff[],
                        const int numOfCoeff, FIXP_DBL* pPredictionGain_m, INT* pPredictionGain_e) {
   INT i, j, scale = 0;
   FIXP_DBL parcorWorkBuffer[LPC_MAX_ORDER];
@@ -412,7 +412,7 @@ void CLpc_AutoToParcor(FIXP_DBL acorr[], const int acorr_e, FIXP_LPC reflCoeff[]
   FIXP_DBL* workBuffer = parcorWorkBuffer;
   FIXP_DBL autoCorr_0 = acorr[0];
 
-  FDKmemclear(reflCoeff, numOfCoeff * sizeof(FIXP_LPC));
+  mpegh_FDKmemclear(reflCoeff, numOfCoeff * sizeof(FIXP_LPC));
 
   if (autoCorr_0 == FL2FXCONST_DBL(0.0)) {
     if (pPredictionGain_m != NULL) {
@@ -422,7 +422,7 @@ void CLpc_AutoToParcor(FIXP_DBL acorr[], const int acorr_e, FIXP_LPC reflCoeff[]
     return;
   }
 
-  FDKmemcpy(workBuffer, acorr + 1, numOfCoeff * sizeof(FIXP_DBL));
+  mpegh_FDKmemcpy(workBuffer, acorr + 1, numOfCoeff * sizeof(FIXP_DBL));
   for (i = 0; i < numOfCoeff; i++) {
     LONG sign = ((LONG)workBuffer[0] >> (DFRACT_BITS - 1));
     FIXP_DBL tmp = (FIXP_DBL)((LONG)workBuffer[0] ^ sign);
diff --git a/src/libFDK/src/FDK_matrixCalloc.cpp b/src/libFDK/src/FDK_matrixCalloc.cpp
index e133976..758dfc1 100644
--- a/src/libFDK/src/FDK_matrixCalloc.cpp
+++ b/src/libFDK/src/FDK_matrixCalloc.cpp
@@ -92,36 +92,36 @@ amm-info@iis.fraunhofer.de
 
 #include "genericStds.h"
 
-void* fdkCallocMatrix1D_aligned(UINT dim1, UINT size) {
-  return FDKaalloc(dim1 * size, ALIGNMENT_DEFAULT);
+void* mpegh_fdkCallocMatrix1D_aligned(UINT dim1, UINT size) {
+  return mpegh_FDKaalloc(dim1 * size, ALIGNMENT_DEFAULT);
 }
 
 void fdkFreeMatrix1D(void* p) {
   if (p != NULL) {
-    FDKfree_L(p);
+    mpegh_FDKfree_L(p);
   }
 }
 
-void fdkFreeMatrix1D_aligned(void* p) {
+void mpegh_fdkFreeMatrix1D_aligned(void* p) {
   if (p != NULL) {
-    FDKafree_L(p);
+    mpegh_FDKafree_L(p);
   }
 }
 
-void* fdkCallocMatrix1D(UINT dim1, UINT size) {
-  return FDKcalloc(dim1, size);
+void* mpegh_fdkCallocMatrix1D(UINT dim1, UINT size) {
+  return mpegh_FDKcalloc(dim1, size);
 }
 
 /* 2D */
-void** fdkCallocMatrix2D(UINT dim1, UINT dim2, UINT size) {
+void** mpegh_fdkCallocMatrix2D(UINT dim1, UINT dim2, UINT size) {
   void** p1;
   UINT i;
   char* p2;
   if (!dim1 || !dim2) return NULL;
-  if ((p1 = (void**)fdkCallocMatrix1D(dim1, sizeof(void*))) == NULL) {
+  if ((p1 = (void**)mpegh_fdkCallocMatrix1D(dim1, sizeof(void*))) == NULL) {
     goto bail;
   }
-  if ((p2 = (char*)fdkCallocMatrix1D(dim1 * dim2, size)) == NULL) {
+  if ((p2 = (char*)mpegh_fdkCallocMatrix1D(dim1 * dim2, size)) == NULL) {
     fdkFreeMatrix1D(p1);
     p1 = NULL;
     goto bail;
@@ -134,7 +134,7 @@ void** fdkCallocMatrix2D(UINT dim1, UINT dim2, UINT size) {
   return p1;
 }
 
-void fdkFreeMatrix2D(void** p) {
+void mpegh_fdkFreeMatrix2D(void** p) {
   if (!p) return;
   fdkFreeMatrix1D(p[0]);
   fdkFreeMatrix1D(p);
diff --git a/src/libFDK/src/FDK_stftfilterbank.cpp b/src/libFDK/src/FDK_stftfilterbank.cpp
index 7c88405..d25915a 100644
--- a/src/libFDK/src/FDK_stftfilterbank.cpp
+++ b/src/libFDK/src/FDK_stftfilterbank.cpp
@@ -126,7 +126,7 @@ int StftFilterbank_Open(const STFT_FILTERBANK_CONFIG* stftFilterbankConfig,
   stftFilterbankConfig_local.fftSize = stftFilterbankConfig->fftSize;
 
   /* no errors, allocate struct */
-  if ((stft_filterbank = (STFT_FILTERBANK*)FDKcalloc(1, sizeof(STFT_FILTERBANK))) == NULL) {
+  if ((stft_filterbank = (STFT_FILTERBANK*)mpegh_FDKcalloc(1, sizeof(STFT_FILTERBANK))) == NULL) {
     return STFT_ERR_MEM_ERROR;
   } else {
     /* copy validated config to internal struct */
@@ -160,34 +160,34 @@ void StftFilterbank_Process(FIXP_DBL* RESTRICT inputBuffer, FIXP_DBL* RESTRICT o
   if (h_stft_filterbank->stftFilterbankConfig.stftFilterbankMode ==
       STFT_FILTERBANK_MODE_TIME_TO_FREQ) {
     if (STFT_headroom != 0) {
-      scaleValues(inputBuffer, h_stft_filterbank->stftFilterbankConfig.frameSize, STFT_headroom);
-      scaleValues(h_stft_filterbank->prevAudioInput,
+      mpegh_scaleValues(inputBuffer, h_stft_filterbank->stftFilterbankConfig.frameSize, STFT_headroom);
+      mpegh_scaleValues(h_stft_filterbank->prevAudioInput,
                   h_stft_filterbank->stftFilterbankConfig.frameSize, STFT_headroom);
     }
 
     processAnalysisSTFT(inputBuffer, outputBuffer, h_stft_filterbank);
 
     if (STFT_headroom != 0) {
-      scaleValues(h_stft_filterbank->prevAudioInput,
+      mpegh_scaleValues(h_stft_filterbank->prevAudioInput,
                   h_stft_filterbank->stftFilterbankConfig.frameSize, -STFT_headroom);
     }
   } else {
     /* make sure we have one bit headroom for FFT */
-    if (getScalefactor(inputBuffer, h_stft_filterbank->stftFilterbankConfig.fftSize) == 0) {
-      scaleValues(inputBuffer, h_stft_filterbank->stftFilterbankConfig.fftSize, -1);
+    if (mpegh_getScalefactor(inputBuffer, h_stft_filterbank->stftFilterbankConfig.fftSize) == 0) {
+      mpegh_scaleValues(inputBuffer, h_stft_filterbank->stftFilterbankConfig.fftSize, -1);
       STFT_headroom--;
     }
     if (STFT_headroom != 0) {
-      scaleValues(h_stft_filterbank->prevAudioInput,
+      mpegh_scaleValues(h_stft_filterbank->prevAudioInput,
                   h_stft_filterbank->stftFilterbankConfig.frameSize, STFT_headroom);
-      scaleValues(outputBuffer, h_stft_filterbank->stftFilterbankConfig.frameSize, STFT_headroom);
+      mpegh_scaleValues(outputBuffer, h_stft_filterbank->stftFilterbankConfig.frameSize, STFT_headroom);
     }
 
     processSynthesisSTFT(inputBuffer, outputBuffer, h_stft_filterbank);
 
     if (STFT_headroom != 0) {
-      scaleValues(outputBuffer, h_stft_filterbank->stftFilterbankConfig.frameSize, -STFT_headroom);
-      scaleValues(h_stft_filterbank->prevAudioInput,
+      mpegh_scaleValues(outputBuffer, h_stft_filterbank->stftFilterbankConfig.frameSize, -STFT_headroom);
+      mpegh_scaleValues(h_stft_filterbank->prevAudioInput,
                   h_stft_filterbank->stftFilterbankConfig.frameSize, -STFT_headroom);
     }
   }
@@ -199,7 +199,7 @@ int StftFilterbank_Close(HANDLE_STFT_FILTERBANK* ph_stft_filterbank) {
   if (ph_stft_filterbank != NULL && *ph_stft_filterbank != NULL) {
     freeStftFilterbankData(*ph_stft_filterbank);
 
-    FDKfree(*ph_stft_filterbank);
+    mpegh_FDKfree(*ph_stft_filterbank);
     *ph_stft_filterbank = NULL;
   }
   return 0;
diff --git a/src/libFDK/src/FDK_stftfilterbank_data.cpp b/src/libFDK/src/FDK_stftfilterbank_data.cpp
index e455c32..be86b6f 100644
--- a/src/libFDK/src/FDK_stftfilterbank_data.cpp
+++ b/src/libFDK/src/FDK_stftfilterbank_data.cpp
@@ -96,7 +96,7 @@ amm-info@iis.fraunhofer.de
 /**********************************************************************************************************************************/
 
 int allocateStftFilterbankData(STFT_FILTERBANK* stft_filterbank) {
-  stft_filterbank->prevAudioInput = (FIXP_DBL*)fdkCallocMatrix1D_aligned(
+  stft_filterbank->prevAudioInput = (FIXP_DBL*)mpegh_fdkCallocMatrix1D_aligned(
       stft_filterbank->stftFilterbankConfig.frameSize, sizeof(FIXP_DBL));
   if (stft_filterbank->prevAudioInput == NULL) {
     return STFT_ERR_MEM_ERROR;
@@ -108,7 +108,7 @@ int allocateStftFilterbankData(STFT_FILTERBANK* stft_filterbank) {
 /**********************************************************************************************************************************/
 
 int freeStftFilterbankData(STFT_FILTERBANK* stft_filterbank) {
-  fdkFreeMatrix1D_aligned((void*)stft_filterbank->prevAudioInput);
+  mpegh_fdkFreeMatrix1D_aligned((void*)stft_filterbank->prevAudioInput);
   stft_filterbank->prevAudioInput = NULL;
 
   return 0;
diff --git a/src/libFDK/src/FDK_stftfilterbank_process.cpp b/src/libFDK/src/FDK_stftfilterbank_process.cpp
index 40697cf..2912753 100644
--- a/src/libFDK/src/FDK_stftfilterbank_process.cpp
+++ b/src/libFDK/src/FDK_stftfilterbank_process.cpp
@@ -176,7 +176,7 @@ INT processSynthesisSTFT(FIXP_DBL* RESTRICT inputBuffer, FIXP_DBL* RESTRICT outp
 static void filterbankSineWindowingSTFT(const FIXP_DBL* RESTRICT audioInputTime,
                                         FIXP_DBL* RESTRICT audioInputTimePrev,
                                         FIXP_DBL* RESTRICT audioOutputFreq, UINT fftSize) {
-  const FIXP_WTP* sinetab = FDKgetWindowSlope(fftSize / 2, 0 /* Shape = SINE */);
+  const FIXP_WTP* sinetab = mpegh_FDKgetWindowSlope(fftSize / 2, 0 /* Shape = SINE */);
 
 #ifdef FUNCTION_filterbankSineWindowingSTFT_func1
   filterbankSineWindowingSTFT_func1(audioInputTime, audioInputTimePrev, audioOutputFreq, fftSize,
@@ -255,7 +255,7 @@ static void filterbankOverlapAddAudioFrames(FIXP_DBL* audioInput, FIXP_DBL* prev
   FIXP_DBL* RESTRICT audioInputTime = audioInput;
   FIXP_DBL* RESTRICT audioInputTimePrev = prevAudioInput;
 
-  const FIXP_WTP* sinetab = FDKgetWindowSlope(fftSize / 2, 0 /* Shape = SINE */);
+  const FIXP_WTP* sinetab = mpegh_FDKgetWindowSlope(fftSize / 2, 0 /* Shape = SINE */);
 
 #ifdef FUNCTION_filterbankOverlapAddAudioFrames_func1
   filterbankOverlapAddAudioFrames_func1(audioInputTime, audioInputTimePrev, audioOutput, fftSize,
diff --git a/src/libFDK/src/FDK_tools_rom.cpp b/src/libFDK/src/FDK_tools_rom.cpp
index cb59459..cb94248 100644
--- a/src/libFDK/src/FDK_tools_rom.cpp
+++ b/src/libFDK/src/FDK_tools_rom.cpp
@@ -92,7 +92,7 @@ amm-info@iis.fraunhofer.de
 
 RAM_ALIGN
 LNK_SECTION_CONSTDATA
-const FIXP_STP SineTable512[] = {
+const FIXP_STP mpegh_SineTable512[] = {
     STCP(0x7fffffff, 0x00000000), STCP(0x7fffd886, 0x006487e3), STCP(0x7fff6216, 0x00c90f88),
     STCP(0x7ffe9cb2, 0x012d96b1), STCP(0x7ffd885a, 0x01921d20), STCP(0x7ffc250f, 0x01f6a297),
     STCP(0x7ffa72d1, 0x025b26d7), STCP(0x7ff871a2, 0x02bfa9a4), STCP(0x7ff62182, 0x03242abf),
@@ -183,7 +183,7 @@ const FIXP_STP SineTable512[] = {
 
 RAM_ALIGN
 LNK_SECTION_CONSTDATA
-const FIXP_STP SineTable1024[] = {
+const FIXP_STP mpegh_SineTable1024[] = {
     STCP(0x7fffffff, 0x00000000), STCP(0x7ffff621, 0x003243f5), STCP(0x7fffd886, 0x006487e3),
     STCP(0x7fffa72c, 0x0096cbc1), STCP(0x7fff6216, 0x00c90f88), STCP(0x7fff0943, 0x00fb5330),
     STCP(0x7ffe9cb2, 0x012d96b1), STCP(0x7ffe1c65, 0x015fda03), STCP(0x7ffd885a, 0x01921d20),
@@ -359,7 +359,7 @@ const FIXP_STP SineTable1024[] = {
 
 RAM_ALIGN
 LNK_SECTION_CONSTDATA
-const FIXP_WTP SineWindow128[] = {
+const FIXP_WTP mpegh_SineWindow128[] = {
     WTCP(0x7fff6216, 0x00c90f88), WTCP(0x7ffa72d1, 0x025b26d7), WTCP(0x7ff09478, 0x03ed26e6),
     WTCP(0x7fe1c76b, 0x057f0035), WTCP(0x7fce0c3e, 0x0710a345), WTCP(0x7fb563b3, 0x08a2009a),
     WTCP(0x7f97cebd, 0x0a3308bd), WTCP(0x7f754e80, 0x0bc3ac35), WTCP(0x7f4de451, 0x0d53db92),
@@ -386,7 +386,7 @@ const FIXP_WTP SineWindow128[] = {
 
 RAM_ALIGN
 LNK_SECTION_CONSTDATA
-const FIXP_WTP SineWindow256[] = {
+const FIXP_WTP mpegh_SineWindow256[] = {
     WTCP(0x7fffd886, 0x006487e3), WTCP(0x7ffe9cb2, 0x012d96b1), WTCP(0x7ffc250f, 0x01f6a297),
     WTCP(0x7ff871a2, 0x02bfa9a4), WTCP(0x7ff38274, 0x0388a9ea), WTCP(0x7fed5791, 0x0451a177),
     WTCP(0x7fe5f108, 0x051a8e5c), WTCP(0x7fdd4eec, 0x05e36ea9), WTCP(0x7fd37153, 0x06ac406f),
@@ -434,7 +434,7 @@ const FIXP_WTP SineWindow256[] = {
 
 RAM_ALIGN
 LNK_SECTION_CONSTDATA
-const FIXP_WTP SineWindow512[] = {
+const FIXP_WTP mpegh_SineWindow512[] = {
     WTCP(0x7ffff621, 0x003243f5), WTCP(0x7fffa72c, 0x0096cbc1), WTCP(0x7fff0943, 0x00fb5330),
     WTCP(0x7ffe1c65, 0x015fda03), WTCP(0x7ffce093, 0x01c45ffe), WTCP(0x7ffb55ce, 0x0228e4e2),
     WTCP(0x7ff97c18, 0x028d6870), WTCP(0x7ff75370, 0x02f1ea6c), WTCP(0x7ff4dbd9, 0x03566a96),
@@ -525,7 +525,7 @@ const FIXP_WTP SineWindow512[] = {
 
 RAM_ALIGN
 LNK_SECTION_CONSTDATA
-const FIXP_WTP SineWindow1024[] = {
+const FIXP_WTP mpegh_SineWindow1024[] = {
     WTCP(0x7ffffd88, 0x001921fb), WTCP(0x7fffe9cb, 0x004b65ee), WTCP(0x7fffc251, 0x007da9d4),
     WTCP(0x7fff8719, 0x00afeda8), WTCP(0x7fff3824, 0x00e23160), WTCP(0x7ffed572, 0x011474f6),
     WTCP(0x7ffe5f03, 0x0146b860), WTCP(0x7ffdd4d7, 0x0178fb99), WTCP(0x7ffd36ee, 0x01ab3e97),
@@ -717,7 +717,7 @@ const FIXP_WTP KBDWindow64[] = {
 
 RAM_ALIGN
 LNK_SECTION_CONSTDATA
-const FIXP_WTP KBDWindow128[] = {
+const FIXP_WTP mpegh_KBDWindow128[] = {
     WTCP(0x7ffffffe, 0x00016f63), WTCP(0x7ffffff1, 0x0003e382), WTCP(0x7fffffc7, 0x00078f64),
     WTCP(0x7fffff5d, 0x000cc323), WTCP(0x7ffffe76, 0x0013d9ed), WTCP(0x7ffffcaa, 0x001d3a9d),
     WTCP(0x7ffff953, 0x0029581f), WTCP(0x7ffff372, 0x0038b1bd), WTCP(0x7fffe98b, 0x004bd34d),
@@ -792,7 +792,7 @@ const FIXP_WTP KBDWindow256[] = {
 
 RAM_ALIGN
 LNK_SECTION_CONSTDATA
-const FIXP_WTP KBDWindow1024[] = {
+const FIXP_WTP mpegh_KBDWindow1024[] = {
     WTCP(0x7fffffa4, 0x0009962f), WTCP(0x7fffff39, 0x000e16fb), WTCP(0x7ffffebf, 0x0011ea65),
     WTCP(0x7ffffe34, 0x0015750e), WTCP(0x7ffffd96, 0x0018dc74), WTCP(0x7ffffce5, 0x001c332e),
     WTCP(0x7ffffc1f, 0x001f83f5), WTCP(0x7ffffb43, 0x0022d59a), WTCP(0x7ffffa4f, 0x00262cc2),
@@ -974,10 +974,10 @@ const FIXP_WTP KBDWindow1024[] = {
  * ][ceil(log2(length)) length 128    .. 1024 ] [1: 10ms raster          ][ceil(log2(length)) length
  * 120    ..  960 ] [2: 3/4 of radix 2 raster][ceil(log2(length)) length  96    ..  768 ]
  */
-const FIXP_WTP* const windowSlopes[2][4][10] = {
+const FIXP_WTP* const mpegh_windowSlopes[2][4][10] = {
     { /* Sine */
      {/* Radix 2 */
-      NULL, NULL, NULL, NULL, NULL, SineWindow128, SineWindow256, SineWindow512, SineWindow1024,
+      NULL, NULL, NULL, NULL, NULL, mpegh_SineWindow128, mpegh_SineWindow256, mpegh_SineWindow512, mpegh_SineWindow1024,
       NULL},
      {      /* 10ms raster */
       NULL, /* 3.25 */
@@ -1001,7 +1001,7 @@ const FIXP_WTP* const windowSlopes[2][4][10] = {
      }},
     { /* KBD */
      {/* Radix 2 */
-      KBDWindow64, KBDWindow128, KBDWindow256, SineWindow512, KBDWindow1024},
+      KBDWindow64, mpegh_KBDWindow128, KBDWindow256, mpegh_SineWindow512, mpegh_KBDWindow1024},
      {
          /* 10ms raster */
          NULL,
@@ -1014,7 +1014,7 @@ const FIXP_WTP* const windowSlopes[2][4][10] = {
       NULL, NULL, NULL, NULL, NULL},
      {NULL, NULL, NULL, NULL}}};
 
-const FIXP_WTP* FDKgetWindowSlope(int length, int shape) {
+const FIXP_WTP* mpegh_FDKgetWindowSlope(int length, int shape) {
   const FIXP_WTP* w = NULL;
   int raster, ld2_length;
 
@@ -1046,7 +1046,7 @@ const FIXP_WTP* FDKgetWindowSlope(int length, int shape) {
   }
 
   /* Look up table */
-  w = windowSlopes[shape & 1][raster][ld2_length];
+  w = mpegh_windowSlopes[shape & 1][raster][ld2_length];
 
   FDK_ASSERT(w != NULL);
 
@@ -1060,7 +1060,7 @@ const FIXP_WTP* FDKgetWindowSlope(int length, int shape) {
 /*! sin (3.14159265358979323 / (2*L) * n) , L=64*/
 LNK_SECTION_CONSTDATA
 RAM_ALIGN
-const FIXP_WTP sin_twiddle_L64[] = {
+const FIXP_WTP mpegh_sin_twiddle_L64[] = {
     WTCP(0x7fffffff, 0x00000000), WTCP(0x7ff62182, 0x03242abf), WTCP(0x7fd8878e, 0x0647d97c),
     WTCP(0x7fa736b4, 0x096a9049), WTCP(0x7f62368f, 0x0c8bd35e), WTCP(0x7f0991c4, 0x0fab272b),
     WTCP(0x7e9d55fc, 0x12c8106f), WTCP(0x7e1d93ea, 0x15e21445), WTCP(0x7d8a5f40, 0x18f8b83c),
@@ -1084,7 +1084,7 @@ const FIXP_WTP sin_twiddle_L64[] = {
     WTCP(0x0c8bd35e, 0x7f62368f), WTCP(0x096a9049, 0x7fa736b4), WTCP(0x0647d97c, 0x7fd8878e),
     WTCP(0x03242abf, 0x7ff62182)};
 
-const USHORT sqrt_tab[49] = {0x5a82, 0x5d4b, 0x6000, 0x62a1, 0x6531, 0x67b1, 0x6a21, 0x6c84, 0x6ed9,
+const USHORT mpegh_sqrt_tab[49] = {0x5a82, 0x5d4b, 0x6000, 0x62a1, 0x6531, 0x67b1, 0x6a21, 0x6c84, 0x6ed9,
                              0x7123, 0x7360, 0x7593, 0x77bb, 0x79da, 0x7bef, 0x7dfb, 0x8000, 0x81fc,
                              0x83f0, 0x85dd, 0x87c3, 0x89a3, 0x8b7c, 0x8d4e, 0x8f1b, 0x90e2, 0x92a4,
                              0x9460, 0x9617, 0x97ca, 0x9977, 0x9b20, 0x9cc4, 0x9e64, 0xa000, 0xa197,
@@ -1092,7 +1092,7 @@ const USHORT sqrt_tab[49] = {0x5a82, 0x5d4b, 0x6000, 0x62a1, 0x6531, 0x67b1, 0x6
                              0xb0b9, 0xb22b, 0xb399, 0xb504};
 
 LNK_SECTION_CONSTDATA_L1
-const FIXP_DBL invCount[80] = /* This could be 16-bit wide */
+const FIXP_DBL mpegh_invCount[80] = /* This could be 16-bit wide */
     {0x00000000, 0x7fffffff, 0x40000000, 0x2aaaaaab, 0x20000000, 0x1999999a, 0x15555555,
      0x12492492, 0x10000000, 0x0e38e38e, 0x0ccccccd, 0x0ba2e8ba, 0x0aaaaaab, 0x09d89d8a,
      0x09249249, 0x08888889, 0x08000000, 0x07878788, 0x071c71c7, 0x06bca1af, 0x06666666,
@@ -1326,7 +1326,7 @@ static const struct element_list node_usac_cpe_epc0 = {
 
 static const struct element_list node_usac_lfe_epc0 = {el_usac_lfe_epc0, {NULL, NULL}};
 
-const element_list_t* getBitstreamElementList(AUDIO_OBJECT_TYPE aot, SCHAR epConfig,
+const element_list_t* mpegh_getBitstreamElementList(AUDIO_OBJECT_TYPE aot, SCHAR epConfig,
                                               UCHAR nChannels, UCHAR layer, UINT elFlags) {
   switch (aot) {
     case AOT_MPEGH3DA:
@@ -1354,7 +1354,7 @@ const element_list_t* getBitstreamElementList(AUDIO_OBJECT_TYPE aot, SCHAR epCon
 /*           0x5A82799A = invSqrtNorm2 (0x4000.0000), exp=1        */
 
 LNK_SECTION_CONSTDATA_L1
-const FIXP_DBL invSqrtTab[SQRT_VALUES] = {
+const FIXP_DBL mpegh_invSqrtTab[SQRT_VALUES] = {
     0x5A827999, 0x5A287E03, 0x59CF8CBC, 0x5977A0AC, 0x5920B4DF, 0x58CAC480, 0x5875CADE, 0x5821C364,
     0x57CEA99D, 0x577C7930, 0x572B2DE0, 0x56DAC38E, 0x568B3632, 0x563C81E0, 0x55EEA2C4, 0x55A19522,
     0x55555555, 0x5509DFD0, 0x54BF311A, 0x547545D0, 0x542C1AA4, 0x53E3AC5B, 0x539BF7CD, 0x5354F9E7,
diff --git a/src/libFDK/src/FDK_trigFcts.cpp b/src/libFDK/src/FDK_trigFcts.cpp
index ac3ed5a..e0bc60f 100644
--- a/src/libFDK/src/FDK_trigFcts.cpp
+++ b/src/libFDK/src/FDK_trigFcts.cpp
@@ -94,7 +94,7 @@ amm-info@iis.fraunhofer.de
 
 #include "FDK_tools_rom.h"
 
-FIXP_DBL fixp_cos(FIXP_DBL x, int scale) {
+FIXP_DBL mpegh_fixp_cos(FIXP_DBL x, int scale) {
   FIXP_DBL residual, error, sine, cosine;
 
   residual = fixp_sin_cos_residual_inline(x, scale, &sine, &cosine);
@@ -108,7 +108,7 @@ FIXP_DBL fixp_cos(FIXP_DBL x, int scale) {
 #endif
 }
 
-FIXP_DBL fixp_sin(FIXP_DBL x, int scale) {
+FIXP_DBL mpegh_fixp_sin(FIXP_DBL x, int scale) {
   FIXP_DBL residual, error, sine, cosine;
 
   residual = fixp_sin_cos_residual_inline(x, scale, &sine, &cosine);
@@ -121,7 +121,7 @@ FIXP_DBL fixp_sin(FIXP_DBL x, int scale) {
 #endif
 }
 
-void fixp_cos_sin(FIXP_DBL x, int scale, FIXP_DBL* cos, FIXP_DBL* sin) {
+void mpegh_fixp_cos_sin(FIXP_DBL x, int scale, FIXP_DBL* cos, FIXP_DBL* sin) {
   FIXP_DBL residual, error0, error1, sine, cosine;
 
   residual = fixp_sin_cos_residual_inline(x, scale, &sine, &cosine);
diff --git a/src/libFDK/src/TD_upsampler.cpp b/src/libFDK/src/TD_upsampler.cpp
index 7dd7f96..cede196 100644
--- a/src/libFDK/src/TD_upsampler.cpp
+++ b/src/libFDK/src/TD_upsampler.cpp
@@ -339,7 +339,7 @@ static FIXP_DBL TD_applyFilter(FIXP_DBL sampleIn, const filter* sosData, FIXP_DB
 
 short TD_upsampler_init(TD_FAC_UPSAMPLE facUpsample, FIXP_DBL* states) {
   int delay = 0;
-  FDKmemclear(states, TD_STATES_MEM_SIZE * sizeof(FIXP_DBL));
+  mpegh_FDKmemclear(states, TD_STATES_MEM_SIZE * sizeof(FIXP_DBL));
 
   switch (facUpsample) {
     case TD_FAC_UPSAMPLE_1_1:
@@ -371,7 +371,7 @@ short TD_upsampler(TD_FAC_UPSAMPLE facUpsample, const FIXP_DBL* sigIn,
 
   switch (facUpsample) {
     case TD_FAC_UPSAMPLE_1_1: /* copy values from input to output as they are */
-      if (sigIn_ptr != sigOut) FDKmemmove(sigOut, sigIn, lenIn * sizeof(FIXP_DBL));
+      if (sigIn_ptr != sigOut) mpegh_FDKmemmove(sigOut, sigIn, lenIn * sizeof(FIXP_DBL));
       lenOut = lenIn;
       break;
 
diff --git a/src/libFDK/src/arm/FDK_lpc_arm.cpp b/src/libFDK/src/arm/FDK_lpc_arm.cpp
index 4ac42d2..2bfd86d 100644
--- a/src/libFDK/src/arm/FDK_lpc_arm.cpp
+++ b/src/libFDK/src/arm/FDK_lpc_arm.cpp
@@ -312,7 +312,7 @@ A64_ASM_ROUTINE_END()
 
 #define FUNCTION_CLpc_SynthesisLattice_DBL
 
-void CLpc_SynthesisLattice(
+void mpegh_CLpc_SynthesisLattice(
         FIXP_DBL *signal,
         const int signal_size,
         const int signal_e,
@@ -910,8 +910,8 @@ void CLpc_Synthesis(
   int lpcCoeffShift = lpcCoeff_e+1;
 
   FIXP_LPC_TNS  coeff[2*LPC_MAX_ORDER];
-  FDKmemcpy(&coeff[0],     lpcCoeff_m, order*sizeof(FIXP_LPC_TNS));
-  FDKmemcpy(&coeff[order], lpcCoeff_m, order*sizeof(FIXP_LPC_TNS));
+  mpegh_FDKmemcpy(&coeff[0],     lpcCoeff_m, order*sizeof(FIXP_LPC_TNS));
+  mpegh_FDKmemcpy(&coeff[order], lpcCoeff_m, order*sizeof(FIXP_LPC_TNS));
 
   FDK_ASSERT(lpcCoeffShift >= 0);
   /* y(n) = x(n) - lpc[1]*y(n-1) - ... - lpc[order]*y(n-order) */
@@ -1574,8 +1574,8 @@ void CLpc_Synthesis(
     int lpcCoeffShift = lpcCoeff_e + 1;
     FIXP_LPC_TNS coeff[2*LPC_MAX_ORDER];
 
-    FDKmemcpy(&coeff[0],     lpcCoeff_m, order*sizeof(FIXP_LPC_TNS));
-    FDKmemcpy(&coeff[order], lpcCoeff_m, order*sizeof(FIXP_LPC_TNS));
+    mpegh_FDKmemcpy(&coeff[0],     lpcCoeff_m, order*sizeof(FIXP_LPC_TNS));
+    mpegh_FDKmemcpy(&coeff[order], lpcCoeff_m, order*sizeof(FIXP_LPC_TNS));
 
     FDK_ASSERT(lpcCoeffShift >= 0);
 
diff --git a/src/libFDK/src/arm/fft_rad2_arm.cpp b/src/libFDK/src/arm/fft_rad2_arm.cpp
index bc12868..dc5dea8 100644
--- a/src/libFDK/src/arm/fft_rad2_arm.cpp
+++ b/src/libFDK/src/arm/fft_rad2_arm.cpp
@@ -1202,7 +1202,7 @@ FDK_label(dit_ifft_loop1)
 #ifdef DEBUG_dit_ifft
       for (int i = 0; i < (1 << ldn); i+= 4)
       {
-          FDKprintf("l1: 0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  %d..%d\n", x[2*i+0], x[2*i+1],  x[2*i+2], x[2*i+3],  x[2*i+4], x[2*i+5],  x[2*i+6], x[2*i+7], i, i+3);
+          mpegh_FDKprintf("l1: 0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  %d..%d\n", x[2*i+0], x[2*i+1],  x[2*i+2], x[2*i+3],  x[2*i+4], x[2*i+5],  x[2*i+6], x[2*i+7], i, i+3);
       }
 #endif
     //-----------------------------------------------------------------------------
@@ -1252,7 +1252,7 @@ FDK_label(dit_ifft_loop2)
 #ifdef DEBUG_dit_ifft
       for (int i = 0; i < (1 << ldn); i+= 4)
       {
-          FDKprintf("l2: 0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  %d..%d\n", x[2*i+0], x[2*i+1],  x[2*i+2], x[2*i+3],  x[2*i+4], x[2*i+5],  x[2*i+6], x[2*i+7], i, i+3);
+          mpegh_FDKprintf("l2: 0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  %d..%d\n", x[2*i+0], x[2*i+1],  x[2*i+2], x[2*i+3],  x[2*i+4], x[2*i+5],  x[2*i+6], x[2*i+7], i, i+3);
       }
 #endif    //-----------------------------------------------------------------------------
     FDK_asr_imm(r3, r3, 1)                // r3:  trigDataSize >>= 1
@@ -1378,7 +1378,7 @@ FDK_label(dit_ifft_loop3_outer_cont)
 #ifdef DEBUG_dit_ifft
       for (int i = 0; i < (1 << ldn); i+= 4)
       {
-          FDKprintf("l4: 0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  %d..%d\n", x[2*i+0], x[2*i+1],  x[2*i+2], x[2*i+3],  x[2*i+4], x[2*i+5],  x[2*i+6], x[2*i+7], i, i+3);
+          mpegh_FDKprintf("l4: 0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  0x%08X 0x%08X  %d..%d\n", x[2*i+0], x[2*i+1],  x[2*i+2], x[2*i+3],  x[2*i+4], x[2*i+5],  x[2*i+6], x[2*i+7], i, i+3);
       }
 #endif 
     FDK_mvpop(Q4,Q7)
diff --git a/src/libFDK/src/arm/scale_arm.cpp b/src/libFDK/src/arm/scale_arm.cpp
index bed78ef..4ca4ab8 100644
--- a/src/libFDK/src/arm/scale_arm.cpp
+++ b/src/libFDK/src/arm/scale_arm.cpp
@@ -111,7 +111,7 @@ amm-info@iis.fraunhofer.de
 #if defined(__GNUC__)
 #define FUNCTION_scaleValues_DBL
 /***************************************************/
-/******** scaleValues, in/out vector identical *****/
+/******** mpegh_scaleValues, in/out vector identical *****/
 /***************************************************/
 FDK_ASM_ROUTINE_START(void,scaleValuesDBL,(
         FIXP_DBL *vector,
@@ -287,7 +287,7 @@ FDK_label(scaleValues_DBL_end)
   FDK_return()
 FDK_ASM_ROUTINE_END()
 
-void scaleValues (
+void mpegh_scaleValues (
         FIXP_DBL *vector,
         INT len,
         INT scalefactor
@@ -303,7 +303,7 @@ void scaleValues (
 #if defined(__GNUC__)
 #define FUNCTION_scaleValues_DBLDBL
 /***************************************************/
-/******** scaleValues, in/out vector different *****/
+/******** mpegh_scaleValues, in/out vector different *****/
 /***************************************************/
 FDK_ASM_ROUTINE_START(void,scaleValuesDBLDBL,(
         FIXP_DBL *dst,
@@ -480,7 +480,7 @@ FDK_label(scaleValues_DBLDBL_end)
   FDK_return()
 FDK_ASM_ROUTINE_END()
 
-void scaleValues (
+void mpegh_scaleValues (
         FIXP_DBL *dst,
         const FIXP_DBL *src,
         INT len,
@@ -600,7 +600,7 @@ A64_label(getScalefactor_DBL_8x_end)
 
 A64_ASM_ROUTINE_RETURN(INT)
 
-INT getScalefactor(const FIXP_DBL *vector, INT len)
+INT mpegh_getScalefactor(const FIXP_DBL *vector, INT len)
 {
     return getScalefactor_DBL_NeonV8(vector, len);
 }
@@ -692,7 +692,7 @@ A64_label(scaleValuesSaturate_SGL_loop_8x_end)
 
 A64_ASM_ROUTINE_END()
 
-SCALE_INLINE void scaleValuesSaturate(
+SCALE_INLINE void mpegh_scaleValuesSaturate(
                   FIXP_SGL* dst,
                   const FIXP_DBL* src,
                   const INT len,
@@ -784,7 +784,7 @@ A64_label(scaleValuesSaturate_DBL_loop_8x_end)
 
 A64_ASM_ROUTINE_END()
 
-SCALE_INLINE void scaleValuesSaturate(
+SCALE_INLINE void mpegh_scaleValuesSaturate(
                   FIXP_DBL* dst,
                   const FIXP_DBL* src,
                   const INT len,
@@ -797,7 +797,7 @@ SCALE_INLINE void scaleValuesSaturate(
 
 #ifdef FUNCTION_scaleValuesSaturate_DBL
 
-SCALE_INLINE void scaleValuesSaturate(
+SCALE_INLINE void mpegh_scaleValuesSaturate(
                   FIXP_DBL* dst,
                   const INT len,
                   const INT scaleFactor    /* positive means: shift left */
@@ -880,7 +880,7 @@ A64_label(scaleValues_DBL_loop_8x_end)
 
 A64_ASM_ROUTINE_END()
 
-SCALE_INLINE void scaleValues(
+SCALE_INLINE void mpegh_scaleValues(
   FIXP_DBL* dst,
   const FIXP_DBL* src,
   const INT len,
@@ -893,7 +893,7 @@ SCALE_INLINE void scaleValues(
 
 #ifdef FUNCTION_scaleValues_DBL
 
-SCALE_INLINE void scaleValues(
+SCALE_INLINE void mpegh_scaleValues(
                   FIXP_DBL* dst,
                   const INT len,
                   const INT scaleFactor    /* positive means: shift left */
@@ -909,7 +909,7 @@ SCALE_INLINE void scaleValues(
 #if !defined(FUNCTION_scaleValuesWithFactor_DBL)
 #define FUNCTION_scaleValuesWithFactor_DBL
 SCALE_INLINE
-void scaleValuesWithFactor(
+void mpegh_scaleValuesWithFactor(
         FIXP_DBL *vector,
         FIXP_DBL factor,
         INT len,
diff --git a/src/libFDK/src/arm/scale_arm_neon.cpp b/src/libFDK/src/arm/scale_arm_neon.cpp
index 003f894..3970a98 100644
--- a/src/libFDK/src/arm/scale_arm_neon.cpp
+++ b/src/libFDK/src/arm/scale_arm_neon.cpp
@@ -200,7 +200,7 @@ FDK_ASM_ROUTINE_END()
 
 #ifdef FUNCTION_scaleValuesSaturate_DBL
 LNK_SECTION_CODE_L1
-SCALE_INLINE void scaleValuesSaturate(
+SCALE_INLINE void mpegh_scaleValuesSaturate(
                   FIXP_DBL *dst,
                   INT len,
             const INT scaleFactor)    /* positive means: shift left */
@@ -209,7 +209,7 @@ SCALE_INLINE void scaleValuesSaturate(
 }
 
 LNK_SECTION_CODE_L1
-SCALE_INLINE void scaleValuesSaturate(
+SCALE_INLINE void mpegh_scaleValuesSaturate(
   FIXP_DBL *dst,
   const FIXP_DBL *src,
   INT len,
@@ -335,7 +335,7 @@ FDK_label(scaleValues_func1_loop_8x_end)
   FDK_return()
 FDK_ASM_ROUTINE_END()
 
-void scaleValues(
+void mpegh_scaleValues(
         FIXP_DBL *dst,
   const FIXP_DBL *src,
         INT  len,
@@ -345,7 +345,7 @@ void scaleValues(
 }
 
 #ifdef FUNCTION_scaleValues_DBL
-void scaleValues(
+void mpegh_scaleValues(
         FIXP_DBL *dst,
         INT  len,
         INT scalefactor)
@@ -443,7 +443,7 @@ FDK_label(scaleValuesSaturate_loop_8x_end)
   FDK_return()
 FDK_ASM_ROUTINE_END()
 
-void scaleValuesSaturate(
+void mpegh_scaleValuesSaturate(
         FIXP_SGL *dst,
         const FIXP_DBL *src,
         INT  len,
@@ -633,7 +633,7 @@ FDK_label(getScalefactor_DBL_8x_end)
   FDK_return()
 FDK_ASM_ROUTINE_RETURN(INT)
 
-INT getScalefactor(const FIXP_DBL *vector, INT len)
+INT mpegh_getScalefactor(const FIXP_DBL *vector, INT len)
 {
    return getScalefactorDBL_neon(vector, len);
 }
@@ -714,7 +714,7 @@ FDK_label(getScalefactor_SGL_8x_end)
   FDK_return()
 FDK_ASM_ROUTINE_RETURN()
 
-INT getScalefactor(const FIXP_SGL *vector, INT len)
+INT mpegh_getScalefactor(const FIXP_SGL *vector, INT len)
 {
    return getScalefactorSGL_neon(vector, len);
 }
diff --git a/src/libFDK/src/dct.cpp b/src/libFDK/src/dct.cpp
index 1fa6e5e..ea200b5 100644
--- a/src/libFDK/src/dct.cpp
+++ b/src/libFDK/src/dct.cpp
@@ -123,9 +123,9 @@ void dct_getTables(const FIXP_WTP** ptwiddle, const FIXP_STP** sin_twiddle, int*
   /* Extract sort of "eigenvalue" (the 4 left most bits) of length. */
   switch ((length) >> (ld2_length - 1)) {
     case 0x4: /* radix 2 */
-      *sin_twiddle = SineTable1024;
+      *sin_twiddle = mpegh_SineTable1024;
       *sin_step = 1 << (10 - ld2_length);
-      twiddle = windowSlopes[0][0][ld2_length - 1];
+      twiddle = mpegh_windowSlopes[0][0][ld2_length - 1];
       break;
     default:
       *sin_twiddle = NULL;
diff --git a/src/libFDK/src/fft.cpp b/src/libFDK/src/fft.cpp
index b302d59..5997202 100644
--- a/src/libFDK/src/fft.cpp
+++ b/src/libFDK/src/fft.cpp
@@ -189,19 +189,19 @@ void fft(int length, FIXP_DBL* pInput, INT* pScalefactor) {
   {
     switch (length) {
       case 64:
-        dit_fft(pInput, 6, SineTable512, 512);
+        dit_fft(pInput, 6, mpegh_SineTable512, 512);
         *pScalefactor += SCALEFACTOR64;
         break;
       case 128:
-        dit_fft(pInput, 7, SineTable512, 512);
+        dit_fft(pInput, 7, mpegh_SineTable512, 512);
         *pScalefactor += SCALEFACTOR128;
         break;
       case 256:
-        dit_fft(pInput, 8, SineTable512, 512);
+        dit_fft(pInput, 8, mpegh_SineTable512, 512);
         *pScalefactor += SCALEFACTOR256;
         break;
       case 512:
-        dit_fft(pInput, 9, SineTable512, 512);
+        dit_fft(pInput, 9, mpegh_SineTable512, 512);
         *pScalefactor += SCALEFACTOR512;
         break;
       default:
diff --git a/src/libFDK/src/mdct.cpp b/src/libFDK/src/mdct.cpp
index 7b9cdf2..ae06936 100644
--- a/src/libFDK/src/mdct.cpp
+++ b/src/libFDK/src/mdct.cpp
@@ -98,9 +98,9 @@ amm-info@iis.fraunhofer.de
 #include "arm/mdct_arm.cpp"
 #endif
 
-void mdct_init(H_MDCT hMdct, FIXP_DBL* overlap, INT overlapBufferSize) {
+void mpegh_mdct_init(H_MDCT hMdct, FIXP_DBL* overlap, INT overlapBufferSize) {
   hMdct->overlap.freq = overlap;
-  // FDKmemclear(overlap, overlapBufferSize*sizeof(FIXP_DBL));
+  // mpegh_FDKmemclear(overlap, overlapBufferSize*sizeof(FIXP_DBL));
   hMdct->prev_fr = 0;
   hMdct->prev_nr = 0;
   hMdct->prev_tl = 0;
@@ -247,7 +247,7 @@ INT mdct_block(H_MDCT hMdct, const INT_PCM* RESTRICT timeData, const INT noInSam
   return nSpec * tl;
 }
 
-void imdct_gain(FIXP_DBL* pGain_m, int* pGain_e, int tl) {
+void mpegh_imdct_gain(FIXP_DBL* pGain_m, int* pGain_e, int tl) {
   FIXP_DBL gain_m = *pGain_m;
   int gain_e = *pGain_e;
   int log2_tl;
@@ -299,7 +299,7 @@ void imdct_gain(FIXP_DBL* pGain_m, int* pGain_e, int tl) {
   *pGain_e = gain_e;
 }
 
-INT imdct_drain(H_MDCT hMdct, FIXP_DBL* output, INT nrSamplesRoom) {
+INT mpegh_imdct_drain(H_MDCT hMdct, FIXP_DBL* output, INT nrSamplesRoom) {
   int buffered_samples = 0;
 
   if (nrSamplesRoom > 0) {
@@ -308,21 +308,21 @@ INT imdct_drain(H_MDCT hMdct, FIXP_DBL* output, INT nrSamplesRoom) {
     FDK_ASSERT(buffered_samples <= nrSamplesRoom);
 
     if (buffered_samples > 0) {
-      FDKmemcpy(output, hMdct->overlap.time, buffered_samples * sizeof(FIXP_DBL));
+      mpegh_FDKmemcpy(output, hMdct->overlap.time, buffered_samples * sizeof(FIXP_DBL));
       hMdct->ov_offset = 0;
     }
   }
   return buffered_samples;
 }
 
-INT imdct_copy_ov_and_nr(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamples) {
+INT mpegh_imdct_copy_ov_and_nr(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamples) {
   FIXP_DBL* pOvl;
   int nt, nf, i;
 
   nt = fMin(hMdct->ov_offset, nrSamples);
   nrSamples -= nt;
   nf = fMin(hMdct->prev_nr, nrSamples);
-  FDKmemcpy(pTimeData, hMdct->overlap.time, nt * sizeof(FIXP_DBL));
+  mpegh_FDKmemcpy(pTimeData, hMdct->overlap.time, nt * sizeof(FIXP_DBL));
   pTimeData += nt;
 
   pOvl = hMdct->overlap.freq + hMdct->ov_size - 1;
@@ -354,7 +354,7 @@ INT imdct_copy_full(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamples) {
   nf2 = fMin(hMdct->prev_tl >> 1, nrSamples);
   nrSamples -= nf2;
 
-  FDKmemcpy(pTimeData, hMdct->overlap.time, nt * sizeof(FIXP_DBL));
+  mpegh_FDKmemcpy(pTimeData, hMdct->overlap.time, nt * sizeof(FIXP_DBL));
   pTimeData += nt;
 
   pOvl = hMdct->overlap.freq + hMdct->ov_size - 1;
@@ -372,7 +372,7 @@ INT imdct_copy_full(H_MDCT hMdct, FIXP_DBL* pTimeData, INT nrSamples) {
   return (nt + nf + nf2);
 }
 
-void imdct_adapt_parameters(H_MDCT hMdct, int* pfl, int* pnl, int tl, const FIXP_WTP* wls,
+void mpegh_imdct_adapt_parameters(H_MDCT hMdct, int* pfl, int* pnl, int tl, const FIXP_WTP* wls,
                             int noOutSamples) {
   int fl = *pfl, nl = *pnl;
   int window_diff, use_current = 0, use_previous = 0;
@@ -456,7 +456,7 @@ respective segments with the appropriate window functions.
 
 Once we have obtained the C and D segments the overlap buffer is emptied and the current buffer is
 sent in it, so that the E and F segments are available for decoding in the next algorithm pass.*/
-INT imlt_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum, const SHORT scalefactor[],
+INT mpegh_imlt_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum, const SHORT scalefactor[],
                const INT nSpec, const INT noOutSamples, const INT tl, const FIXP_WTP* wls, INT fl,
                const FIXP_WTP* wrs, const INT fr, FIXP_DBL gain, int flags) {
   FIXP_DBL* pOvl;
@@ -470,11 +470,11 @@ INT imlt_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum, const SHORT s
   nl = (tl - fl) >> 1;
 
   /* Include 2/N IMDCT gain into gain factor and exponent. */
-  imdct_gain(&gain, &transform_gain_e, tl);
+  mpegh_imdct_gain(&gain, &transform_gain_e, tl);
 
   /* Detect FRprevious / FL mismatches and override parameters accordingly */
   if (hMdct->prev_fr != fl) {
-    imdct_adapt_parameters(hMdct, &fl, &nl, tl, wls, noOutSamples);
+    mpegh_imdct_adapt_parameters(hMdct, &fl, &nl, tl, wls, noOutSamples);
   }
 
   pOvl = hMdct->overlap.freq + hMdct->ov_size - 1;
@@ -495,7 +495,7 @@ INT imlt_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum, const SHORT s
 
     /* Detect FRprevious / FL mismatches and override parameters accordingly */
     if (hMdct->prev_fr != fl) {
-      imdct_adapt_parameters(hMdct, &fl, &nl, tl, wls, noOutSamples);
+      mpegh_imdct_adapt_parameters(hMdct, &fl, &nl, tl, wls, noOutSamples);
     }
 
     specShiftScale = transform_gain_e;
@@ -537,7 +537,7 @@ INT imlt_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum, const SHORT s
     }
     {
       int loc_scale = fixmin_I(scalefactor[w] + specShiftScale, (INT)DFRACT_BITS - 1);
-      scaleValuesSaturate(pSpec, tl, loc_scale);
+      mpegh_scaleValuesSaturate(pSpec, tl, loc_scale);
     }
 
     if (noOutSamples <= nrSamples) {
@@ -713,7 +713,7 @@ INT imlt_block(H_MDCT hMdct, FIXP_DBL* output, FIXP_DBL* spectrum, const SHORT s
   /* Save overlap */
 
   pOvl = hMdct->overlap.freq + hMdct->ov_size - tl / 2;
-  FDKmemcpy(pOvl, &spectrum[(nSpec - 1) * tl], (tl / 2) * sizeof(FIXP_DBL));
+  mpegh_FDKmemcpy(pOvl, &spectrum[(nSpec - 1) * tl], (tl / 2) * sizeof(FIXP_DBL));
 
   return nrSamples;
 }
diff --git a/src/libFDK/src/rfft.cpp b/src/libFDK/src/rfft.cpp
index bcae065..836cf80 100644
--- a/src/libFDK/src/rfft.cpp
+++ b/src/libFDK/src/rfft.cpp
@@ -158,19 +158,19 @@ INT irfft(const UINT fftLength, FIXP_DBL* const pBuffer, const UINT bufferSize,
 void getSineTab(const UINT length, const FIXP_STP** ppSineTab, UINT* pStep) {
   switch (length) {
     case 64:
-      *ppSineTab = SineTable512;
+      *ppSineTab = mpegh_SineTable512;
       *pStep = 1 << (9 - 4);
       break;
     case 128:
-      *ppSineTab = SineTable512;
+      *ppSineTab = mpegh_SineTable512;
       *pStep = 1 << (9 - 5);
       break;
     case 256:
-      *ppSineTab = SineTable512;
+      *ppSineTab = mpegh_SineTable512;
       *pStep = 1 << (9 - 6);
       break;
     case 512:
-      *ppSineTab = SineTable512;
+      *ppSineTab = mpegh_SineTable512;
       *pStep = 1 << (9 - 7);
       break;
     default:
diff --git a/src/libFDK/src/scale.cpp b/src/libFDK/src/scale.cpp
index 50cd9a1..aa7824b 100644
--- a/src/libFDK/src/scale.cpp
+++ b/src/libFDK/src/scale.cpp
@@ -113,7 +113,7 @@ amm-info@iis.fraunhofer.de
  */
 #define FUNCTION_scaleValues_SGL
 SCALE_INLINE
-void scaleValues(FIXP_SGL* vector, /*!< Vector */
+void mpegh_scaleValues(FIXP_SGL* vector, /*!< Vector */
                  INT len,          /*!< Length */
                  INT scalefactor   /*!< Scalefactor */
 ) {
@@ -158,7 +158,7 @@ void scaleValues(FIXP_SGL* vector, /*!< Vector */
  */
 #define FUNCTION_scaleValues_DBL
 SCALE_INLINE
-void scaleValues(FIXP_DBL* vector, /*!< Vector */
+void mpegh_scaleValues(FIXP_DBL* vector, /*!< Vector */
                  INT len,          /*!< Length */
                  INT scalefactor   /*!< Scalefactor */
 ) {
@@ -205,7 +205,7 @@ void scaleValues(FIXP_DBL* vector, /*!< Vector */
  */
 #define FUNCTION_scaleValuesSaturate_DBL
 SCALE_INLINE
-void scaleValuesSaturate(FIXP_DBL* vector, /*!< Vector */
+void mpegh_scaleValuesSaturate(FIXP_DBL* vector, /*!< Vector */
                          INT len,          /*!< Length */
                          INT scalefactor   /*!< Scalefactor */
 ) {
@@ -235,7 +235,7 @@ void scaleValuesSaturate(FIXP_DBL* vector, /*!< Vector */
  */
 #define FUNCTION_scaleValuesSaturate_DBL_DBL
 SCALE_INLINE
-void scaleValuesSaturate(FIXP_DBL* dst,       /*!< Output */
+void mpegh_scaleValuesSaturate(FIXP_DBL* dst,       /*!< Output */
                          const FIXP_DBL* src, /*!< Input   */
                          INT len,             /*!< Length */
                          INT scalefactor      /*!< Scalefactor */
@@ -244,7 +244,7 @@ void scaleValuesSaturate(FIXP_DBL* dst,       /*!< Output */
 
   /* Return if scalefactor is Zero */
   if (scalefactor == 0) {
-    if (dst != src) FDKmemmove(dst, src, len * sizeof(FIXP_DBL));
+    if (dst != src) mpegh_FDKmemmove(dst, src, len * sizeof(FIXP_DBL));
     return;
   }
 
@@ -269,7 +269,7 @@ void scaleValuesSaturate(FIXP_DBL* dst,       /*!< Output */
  */
 #define FUNCTION_scaleValuesSaturate_SGL_DBL
 SCALE_INLINE
-void scaleValuesSaturate(FIXP_SGL* dst,       /*!< Output */
+void mpegh_scaleValuesSaturate(FIXP_SGL* dst,       /*!< Output */
                          const FIXP_DBL* src, /*!< Input   */
                          INT len,             /*!< Length */
                          INT scalefactor)     /*!< Scalefactor */
@@ -295,7 +295,7 @@ void scaleValuesSaturate(FIXP_SGL* dst,       /*!< Output */
  */
 #define FUNCTION_scaleValuesSaturate_SGL
 SCALE_INLINE
-void scaleValuesSaturate(FIXP_SGL* vector, /*!< Vector */
+void mpegh_scaleValuesSaturate(FIXP_SGL* vector, /*!< Vector */
                          INT len,          /*!< Length */
                          INT scalefactor   /*!< Scalefactor */
 ) {
@@ -325,7 +325,7 @@ void scaleValuesSaturate(FIXP_SGL* vector, /*!< Vector */
  */
 #define FUNCTION_scaleValuesSaturate_SGL_SGL
 SCALE_INLINE
-void scaleValuesSaturate(FIXP_SGL* dst,       /*!< Output */
+void mpegh_scaleValuesSaturate(FIXP_SGL* dst,       /*!< Output */
                          const FIXP_SGL* src, /*!< Input */
                          INT len,             /*!< Length */
                          INT scalefactor      /*!< Scalefactor */
@@ -334,7 +334,7 @@ void scaleValuesSaturate(FIXP_SGL* dst,       /*!< Output */
 
   /* Return if scalefactor is Zero */
   if (scalefactor == 0) {
-    if (dst != src) FDKmemmove(dst, src, len * sizeof(FIXP_SGL));
+    if (dst != src) mpegh_FDKmemmove(dst, src, len * sizeof(FIXP_SGL));
     return;
   }
 
@@ -360,7 +360,7 @@ void scaleValuesSaturate(FIXP_SGL* dst,       /*!< Output */
  */
 #define FUNCTION_scaleValues_DBLDBL
 SCALE_INLINE
-void scaleValues(FIXP_DBL* dst,       /*!< dst Vector */
+void mpegh_scaleValues(FIXP_DBL* dst,       /*!< dst Vector */
                  const FIXP_DBL* src, /*!< src Vector */
                  INT len,             /*!< Length */
                  INT scalefactor      /*!< Scalefactor */
@@ -369,7 +369,7 @@ void scaleValues(FIXP_DBL* dst,       /*!< dst Vector */
 
   /* Return if scalefactor is Zero */
   if (scalefactor == 0) {
-    if (dst != src) FDKmemmove(dst, src, len * sizeof(FIXP_DBL));
+    if (dst != src) mpegh_FDKmemmove(dst, src, len * sizeof(FIXP_DBL));
   } else {
     if (scalefactor > 0) {
       scalefactor = fixmin_I(scalefactor, (INT)DFRACT_BITS - 1);
@@ -413,7 +413,7 @@ void scaleValues(FIXP_DBL* dst,       /*!< dst Vector */
  */
 #define FUNCTION_scaleValues_PCMDBL
 SCALE_INLINE
-void scaleValues(FIXP_PCM* dst,       /*!< dst Vector */
+void mpegh_scaleValues(FIXP_PCM* dst,       /*!< dst Vector */
                  const FIXP_DBL* src, /*!< src Vector */
                  INT len,             /*!< Length */
                  INT scalefactor      /*!< Scalefactor */
@@ -466,7 +466,7 @@ void scaleValues(FIXP_PCM* dst,       /*!< dst Vector */
  */
 #define FUNCTION_scaleValues_SGLSGL
 SCALE_INLINE
-void scaleValues(FIXP_SGL* dst,       /*!< dst Vector */
+void mpegh_scaleValues(FIXP_SGL* dst,       /*!< dst Vector */
                  const FIXP_SGL* src, /*!< src Vector */
                  INT len,             /*!< Length */
                  INT scalefactor      /*!< Scalefactor */
@@ -475,7 +475,7 @@ void scaleValues(FIXP_SGL* dst,       /*!< dst Vector */
 
   /* Return if scalefactor is Zero */
   if (scalefactor == 0) {
-    if (dst != src) FDKmemmove(dst, src, len * sizeof(FIXP_DBL));
+    if (dst != src) mpegh_FDKmemmove(dst, src, len * sizeof(FIXP_DBL));
   } else {
     if (scalefactor > 0) {
       scalefactor = fixmin_I(scalefactor, (INT)DFRACT_BITS - 1);
@@ -514,7 +514,7 @@ void scaleValues(FIXP_SGL* dst,       /*!< dst Vector */
  */
 #define FUNCTION_scaleValuesWithFactor_DBL
 SCALE_INLINE
-void scaleValuesWithFactor(FIXP_DBL* vector, FIXP_DBL factor, INT len, INT scalefactor) {
+void mpegh_scaleValuesWithFactor(FIXP_DBL* vector, FIXP_DBL factor, INT len, INT scalefactor) {
   INT i;
 
   /* Compensate fMultDiv2 */
@@ -558,7 +558,7 @@ void scaleValuesWithFactor(FIXP_DBL* vector, FIXP_DBL factor, INT len, INT scale
 
 /*******************************************
 
-IMPORTANT NOTE for usage of getScalefactor()
+IMPORTANT NOTE for usage of mpegh_getScalefactor()
 
 If the input array contains negative values too, then these functions may sometimes return
 the actual maximum value minus 1, due to the nature of the applied algorithm.
@@ -576,7 +576,7 @@ So be careful with possible fractional -1 values that may lead to overflows when
  */
 #define FUNCTION_getScalefactorShort
 SCALE_INLINE
-INT getScalefactorShort(const SHORT* vector, /*!< Pointer to input vector */
+INT mpegh_getScalefactorShort(const SHORT* vector, /*!< Pointer to input vector */
                         INT len              /*!< Length of input vector */
 ) {
   INT i;
@@ -628,7 +628,7 @@ INT getScalefactorPCM(const INT_PCM* vector, /*!< Pointer to input vector */
  */
 #define FUNCTION_getScalefactorShort
 SCALE_INLINE
-INT getScalefactorShort(const SHORT* vector, /*!< Pointer to input vector */
+INT mpegh_getScalefactorShort(const SHORT* vector, /*!< Pointer to input vector */
                         INT len,             /*!< Length of input vector */
                         INT stride) {
   INT i;
@@ -662,7 +662,7 @@ INT getScalefactorShort(const SHORT* vector, /*!< Pointer to input vector */
  */
 #define FUNCTION_getScalefactor_DBL
 SCALE_INLINE
-INT getScalefactor(const FIXP_DBL* vector, /*!< Pointer to input vector */
+INT mpegh_getScalefactor(const FIXP_DBL* vector, /*!< Pointer to input vector */
                    INT len)                /*!< Length of input vector */
 {
   INT i;
@@ -680,7 +680,7 @@ INT getScalefactor(const FIXP_DBL* vector, /*!< Pointer to input vector */
 #ifndef FUNCTION_getScalefactor_SGL
 #define FUNCTION_getScalefactor_SGL
 SCALE_INLINE
-INT getScalefactor(const FIXP_SGL* vector, /*!< Pointer to input vector */
+INT mpegh_getScalefactor(const FIXP_SGL* vector, /*!< Pointer to input vector */
                    INT len)                /*!< Length of input vector */
 {
   INT i;
diff --git a/src/libFormatConverter/src/FDK_dmxMatrixParser.cpp b/src/libFormatConverter/src/FDK_dmxMatrixParser.cpp
index a217c89..1f0da8e 100644
--- a/src/libFormatConverter/src/FDK_dmxMatrixParser.cpp
+++ b/src/libFormatConverter/src/FDK_dmxMatrixParser.cpp
@@ -191,7 +191,7 @@ INT EqualizerConfig(HANDLE_FDK_BITSTREAM hBs, SpeakerInformation* inputConfig, U
   equalizerPresent = FDKreadBit(hBs);
   if (equalizerPresent == 0) {
     eqConfig->numEQs = 0;
-    FDKmemclear(eqConfig->eqMap, sizeof(eqConfig->eqMap));
+    mpegh_FDKmemclear(eqConfig->eqMap, sizeof(eqConfig->eqMap));
     return 0;
   }
 
diff --git a/src/libFormatConverter/src/FDK_formatConverter.cpp b/src/libFormatConverter/src/FDK_formatConverter.cpp
index ce71317..e7abaf1 100644
--- a/src/libFormatConverter/src/FDK_formatConverter.cpp
+++ b/src/libFormatConverter/src/FDK_formatConverter.cpp
@@ -263,12 +263,12 @@ INT formatConverterOpen(const IIS_FORMATCONVERTER_MODE formatConverterMode,
   /**************************************************************************************/
   /* allocation */
 
-  fcInt->fcParams = (HANDLE_FORMAT_CONVERTER_PARAMS)FDKcalloc(1, sizeof *fcInt->fcParams);
+  fcInt->fcParams = (HANDLE_FORMAT_CONVERTER_PARAMS)mpegh_FDKcalloc(1, sizeof *fcInt->fcParams);
   if (fcInt->fcParams == NULL) {
     status = 1;
     goto bail;
   }
-  fcInt->fcState = (HANDLE_FORMAT_CONVERTER_STATE)FDKcalloc(1, sizeof *fcInt->fcState);
+  fcInt->fcState = (HANDLE_FORMAT_CONVERTER_STATE)mpegh_FDKcalloc(1, sizeof *fcInt->fcState);
   if (fcInt->fcState == NULL) {
     status = 1;
     goto bail;
@@ -324,9 +324,9 @@ INT formatConverterOpen(const IIS_FORMATCONVERTER_MODE formatConverterMode,
   /* on error clean up so far allocated structs and return */
   if (status == 1) {
   bail:
-    FDKfree(fcInt->fcParams);
+    mpegh_FDKfree(fcInt->fcParams);
     fcInt->fcParams = NULL;
-    FDKfree(fcInt->fcState);
+    mpegh_FDKfree(fcInt->fcState);
     fcInt->fcState = NULL;
     return 1;
   }
@@ -390,12 +390,12 @@ void formatConverterClose(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
   if (fcInt->fcState != NULL) {
     /* free buffers */
     freeFormatConverterState(fcInt);
-    FDKfree(fcInt->fcState);
+    mpegh_FDKfree(fcInt->fcState);
     fcInt->fcState = NULL;
   }
   if (fcInt->fcParams != NULL) {
     freeFormatConverterParams(fcInt);
-    FDKfree(fcInt->fcParams);
+    mpegh_FDKfree(fcInt->fcParams);
     fcInt->fcParams = NULL;
   }
 }
diff --git a/src/libFormatConverter/src/FDK_formatConverterLib.cpp b/src/libFormatConverter/src/FDK_formatConverterLib.cpp
index c27d6f8..15e68c5 100644
--- a/src/libFormatConverter/src/FDK_formatConverterLib.cpp
+++ b/src/libFormatConverter/src/FDK_formatConverterLib.cpp
@@ -146,10 +146,10 @@ INT IIS_FormatConverter_Create(IIS_FORMATCONVERTER_HANDLE* self, IIS_FORMATCONVE
     }
   }
 
-  if (((*self) = (IIS_FORMATCONVERTER_HANDLE)FDKcalloc(1, sizeof **self)) == NULL) {
+  if (((*self) = (IIS_FORMATCONVERTER_HANDLE)mpegh_FDKcalloc(1, sizeof **self)) == NULL) {
     return err = 1;
   }
-  if (((*self)->member = FDKcalloc(1, sizeof(IIS_FORMATCONVERTER_INTERNAL))) == NULL) {
+  if (((*self)->member = mpegh_FDKcalloc(1, sizeof(IIS_FORMATCONVERTER_INTERNAL))) == NULL) {
     return err = 1;
   }
   _p = (IIS_FORMATCONVERTER_INTERNAL*)(*self)->member;
@@ -166,10 +166,10 @@ INT IIS_FormatConverter_Create(IIS_FORMATCONVERTER_HANDLE* self, IIS_FORMATCONVE
     _p->fcNumFreqBands = _p->stftLength / 2 + 1;
     _p->fcCenterFrequencies = f_bands_nrm_stft_256_erb_58;
   }
-  FDKmemcpy(_p->GVH, GVH, 13 * 6 * sizeof(FIXP_DBL));
-  FDKmemcpy(_p->GVL, GVL, 13 * 6 * sizeof(FIXP_DBL));
-  FDKmemclear(_p->GVH_e, sizeof(_p->GVH_e));
-  FDKmemclear(_p->GVL_e, sizeof(_p->GVH_e));
+  mpegh_FDKmemcpy(_p->GVH, GVH, 13 * 6 * sizeof(FIXP_DBL));
+  mpegh_FDKmemcpy(_p->GVL, GVL, 13 * 6 * sizeof(FIXP_DBL));
+  mpegh_FDKmemclear(_p->GVH_e, sizeof(_p->GVH_e));
+  mpegh_FDKmemclear(_p->GVL_e, sizeof(_p->GVH_e));
 
   _p->frameSize = frameSize;
 
@@ -208,7 +208,7 @@ INT IIS_FormatConverter_Create(IIS_FORMATCONVERTER_HANDLE* self, IIS_FORMATCONVE
 
   FDK_ASSERT(outGeo != NULL);
 
-  FDKmemcpy(_p->outChannelGeo, outGeo, (sizeof *outGeo) * numOutChannels);
+  mpegh_FDKmemcpy(_p->outChannelGeo, outGeo, (sizeof *outGeo) * numOutChannels);
   (*self)->numLocalSpeaker = numOutChannels;
 
   return err;
@@ -236,7 +236,7 @@ INT IIS_FormatConverter_Config_AddInputSetup(IIS_FORMATCONVERTER_HANDLE self,
     return 1;
   }
 
-  FDKmemcpy(&(_p->inputChannelGeo[_p->numTotalInputChannels]), geo, numChannels * sizeof *geo);
+  mpegh_FDKmemcpy(&(_p->inputChannelGeo[_p->numTotalInputChannels]), geo, numChannels * sizeof *geo);
 
   _p->numTotalInputChannels += numChannels;
 
@@ -486,11 +486,11 @@ static int IIS_FormatConverter_Process_STFT(IIS_FORMATCONVERTER_HANDLE self,
     int STFT_headroom = 31;
     int STFT_headroom_prescaling = 0;
     for (ch = 0; ch < _p->numTotalInputChannels; ch++) {
-      STFT_headroom = fMin(STFT_headroom, getScalefactor(&(deinBuffer[ch][i * _p->stftFrameSize]),
+      STFT_headroom = fMin(STFT_headroom, mpegh_getScalefactor(&(deinBuffer[ch][i * _p->stftFrameSize]),
                                                          (_p->stftFrameSize)));
     }
     for (ch = 0; ch < _p->numOutputChannels; ch++) {
-      STFT_headroom = fMin(STFT_headroom, getScalefactor(&(deoutBuffer[ch][i * _p->stftFrameSize]),
+      STFT_headroom = fMin(STFT_headroom, mpegh_getScalefactor(&(deoutBuffer[ch][i * _p->stftFrameSize]),
                                                          (_p->stftFrameSize)));
     }
 
@@ -586,7 +586,7 @@ int IIS_FormatConverter_Close(IIS_FORMATCONVERTER_HANDLE* self) {
 
   IIS_FORMATCONVERTER_INTERNAL* _p = (IIS_FORMATCONVERTER_INTERNAL*)(*self)->member;
   if (_p == NULL) {
-    FDKfree(*self);
+    mpegh_FDKfree(*self);
     *self = NULL;
     return 0;
   }
@@ -602,34 +602,34 @@ int IIS_FormatConverter_Close(IIS_FORMATCONVERTER_HANDLE* self) {
   if (_p->prevInputBufferStft) {
     for (i = 0; i < (TFRA + 1); i++) {
       if (_p->prevInputBufferStft[i]) {
-        FDKafree(_p->prevInputBufferStft[i]);
+        mpegh_FDKafree(_p->prevInputBufferStft[i]);
       }
     }
-    FDKfree(_p->prevInputBufferStft);
+    mpegh_FDKfree(_p->prevInputBufferStft);
   }
 
   if (_p->inputBufferStft) {
     for (i = 0; i < _p->numTotalInputChannels; i++) {
       if (_p->inputBufferStft[i]) {
-        FDKafree(_p->inputBufferStft[i]);
+        mpegh_FDKafree(_p->inputBufferStft[i]);
       }
     }
-    FDKfree(_p->inputBufferStft);
+    mpegh_FDKfree(_p->inputBufferStft);
   }
 
   if (_p->outputBufferStft) {
     for (i = 0; i < _p->numOutputChannels; i++) {
       if (_p->outputBufferStft[i]) {
-        FDKafree(_p->outputBufferStft[i]);
+        mpegh_FDKafree(_p->outputBufferStft[i]);
       }
     }
-    FDKfree(_p->outputBufferStft);
+    mpegh_FDKfree(_p->outputBufferStft);
   }
   formatConverterClose(_p);
 
-  FDKfree(_p);
+  mpegh_FDKfree(_p);
 
-  FDKfree(*self);
+  mpegh_FDKfree(*self);
   *self = NULL;
 
   return 0;
@@ -738,7 +738,7 @@ static INT gVBAPRenderer_GetStaticGains(CICP2GEOMETRY_CHANNEL_GEOMETRY* inGeomet
   /* Calculate inverse matrices */
   /* generateInverseMatrices(*phgVBAPRenderer); */
 
-  if ((gains = (FIXP_DBL*)FDKcalloc(outChannels, sizeof(FIXP_DBL))) == NULL) {
+  if ((gains = (FIXP_DBL*)mpegh_FDKcalloc(outChannels, sizeof(FIXP_DBL))) == NULL) {
     err = 1; /* memory allocation error */
     goto bail;
   }
@@ -771,7 +771,7 @@ static INT gVBAPRenderer_GetStaticGains(CICP2GEOMETRY_CHANNEL_GEOMETRY* inGeomet
     hgVBAPRenderer = NULL;
   }
 
-  if (gains) FDKfree(gains);
+  if (gains) mpegh_FDKfree(gains);
 
   return err;
 }
@@ -783,30 +783,30 @@ static INT _applyPartialVbapInputFallback(IIS_FORMATCONVERTER_INTERNAL* _p, UINT
   FIXP_DMX_H** tmpDmxMtx = NULL;
   FIXP_DMX_H** dmxMtx = NULL;
 
-  if ((dmxMtx = (FIXP_DMX_H**)FDKcalloc(_p->numTotalInputChannels, sizeof *dmxMtx)) == NULL) {
+  if ((dmxMtx = (FIXP_DMX_H**)mpegh_FDKcalloc(_p->numTotalInputChannels, sizeof *dmxMtx)) == NULL) {
     err = 1; /* memory allocation error */
     goto bail;
   }
   for (ch = 0; ch < (INT)_p->numTotalInputChannels; ch++) {
-    if ((dmxMtx[ch] = (FIXP_DMX_H*)FDKcalloc(_p->numOutputChannels, sizeof *dmxMtx[ch])) == NULL) {
+    if ((dmxMtx[ch] = (FIXP_DMX_H*)mpegh_FDKcalloc(_p->numOutputChannels, sizeof *dmxMtx[ch])) == NULL) {
       err = 1; /* memory allocation error */
       goto bail;
     }
   }
 
   /* allocate temporary memory */
-  if ((unknownChannelsGeo = (CICP2GEOMETRY_CHANNEL_GEOMETRY*)FDKcalloc(
+  if ((unknownChannelsGeo = (CICP2GEOMETRY_CHANNEL_GEOMETRY*)mpegh_FDKcalloc(
            numUnknownInCh, sizeof *unknownChannelsGeo)) == NULL) {
     err = 1; /* memory allocation error */
     goto bail;
   }
 
-  if ((tmpDmxMtx = (FIXP_DMX_H**)FDKcalloc(numUnknownInCh, sizeof *tmpDmxMtx)) == NULL) {
+  if ((tmpDmxMtx = (FIXP_DMX_H**)mpegh_FDKcalloc(numUnknownInCh, sizeof *tmpDmxMtx)) == NULL) {
     err = 1; /* memory allocation error */
     goto bail;
   }
   for (ch = 0; ch < (INT)numUnknownInCh; ch++) {
-    if ((tmpDmxMtx[ch] = (FIXP_DMX_H*)FDKcalloc(_p->numOutputChannels, sizeof *tmpDmxMtx[ch])) ==
+    if ((tmpDmxMtx[ch] = (FIXP_DMX_H*)mpegh_FDKcalloc(_p->numOutputChannels, sizeof *tmpDmxMtx[ch])) ==
         NULL) {
       err = 1; /* memory allocation error */
       goto bail;
@@ -849,26 +849,26 @@ static INT _applyPartialVbapInputFallback(IIS_FORMATCONVERTER_INTERNAL* _p, UINT
 bail:
   /* free memory */
   if (unknownChannelsGeo != NULL) {
-    FDKfree(unknownChannelsGeo);
+    mpegh_FDKfree(unknownChannelsGeo);
     unknownChannelsGeo = NULL;
   }
   if (tmpDmxMtx != NULL) {
     for (ch = 0; ch < (INT)numUnknownInCh; ch++) {
       if (tmpDmxMtx[ch] != NULL) {
-        FDKfree(tmpDmxMtx[ch]);
+        mpegh_FDKfree(tmpDmxMtx[ch]);
       }
     }
-    FDKfree(tmpDmxMtx);
+    mpegh_FDKfree(tmpDmxMtx);
     tmpDmxMtx = NULL;
   }
 
   if (dmxMtx != NULL) {
     for (ch = 0; ch < (INT)_p->numTotalInputChannels; ch++) {
       if (dmxMtx[ch] != NULL) {
-        FDKfree(dmxMtx[ch]);
+        mpegh_FDKfree(dmxMtx[ch]);
       }
     }
-    FDKfree(dmxMtx);
+    mpegh_FDKfree(dmxMtx);
     dmxMtx = NULL;
   }
 
@@ -891,12 +891,12 @@ static INT _applyFullVbapFallback(IIS_FORMATCONVERTER_INTERNAL* _p) {
   formatConverterPostprocessDmxMtx(_p->fcParams->dmxMtx, _p->numTotalInputChannels,
                                    _p->numOutputChannels);
 
-  if ((tmpDmxMtx = (FIXP_DMX_H**)FDKcalloc(_p->numTotalInputChannels, sizeof(tmpDmxMtx))) == NULL) {
+  if ((tmpDmxMtx = (FIXP_DMX_H**)mpegh_FDKcalloc(_p->numTotalInputChannels, sizeof(tmpDmxMtx))) == NULL) {
     err = 1; /* memory allocation error */
     goto bail;
   }
   for (int ch = 0; ch < (INT)_p->numTotalInputChannels; ch++) {
-    if ((tmpDmxMtx[ch] = (FIXP_DMX_H*)FDKcalloc(_p->numOutputChannels, sizeof(tmpDmxMtx[ch]))) ==
+    if ((tmpDmxMtx[ch] = (FIXP_DMX_H*)mpegh_FDKcalloc(_p->numOutputChannels, sizeof(tmpDmxMtx[ch]))) ==
         NULL) {
       err = 1; /* memory allocation error */
       goto bail;
@@ -912,10 +912,10 @@ static INT _applyFullVbapFallback(IIS_FORMATCONVERTER_INTERNAL* _p) {
   if (tmpDmxMtx != NULL) {
     for (int ch = 0; ch < (INT)_p->numTotalInputChannels; ch++) {
       if (tmpDmxMtx[ch] != NULL) {
-        FDKfree(tmpDmxMtx[ch]);
+        mpegh_FDKfree(tmpDmxMtx[ch]);
       }
     }
-    FDKfree(tmpDmxMtx);
+    mpegh_FDKfree(tmpDmxMtx);
     tmpDmxMtx = NULL;
   }
 
@@ -937,18 +937,18 @@ static INT _initSTFT(IIS_FORMATCONVERTER_INTERNAL* _p) {
   _p->stftFilterbankConfigAnalysis.fftSize = _p->stftLength;
   _p->stftFilterbankConfigAnalysis.stftFilterbankMode = STFT_FILTERBANK_MODE_TIME_TO_FREQ;
 
-  FDKmemcpy(&_p->stftFilterbankConfigSynthesis, &_p->stftFilterbankConfigAnalysis,
+  mpegh_FDKmemcpy(&_p->stftFilterbankConfigSynthesis, &_p->stftFilterbankConfigAnalysis,
             sizeof(_p->stftFilterbankConfigAnalysis));
   _p->stftFilterbankConfigSynthesis.stftFilterbankMode = STFT_FILTERBANK_MODE_FREQ_TO_TIME;
 
   /*Initialize Analysis filterbank*/
-  _p->inputBufferStft = (FIXP_DBL**)FDKcalloc(_p->numTotalInputChannels, sizeof(FIXP_DBL*));
+  _p->inputBufferStft = (FIXP_DBL**)mpegh_FDKcalloc(_p->numTotalInputChannels, sizeof(FIXP_DBL*));
   if (_p->inputBufferStft == NULL) {
     return status = -1;
   }
   for (ch = 0; ch < _p->numTotalInputChannels; ch++) {
     _p->inputBufferStft[ch] =
-        (FIXP_DBL*)FDKaalloc(_p->stftLength * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
+        (FIXP_DBL*)mpegh_FDKaalloc(_p->stftLength * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
     if (_p->inputBufferStft[ch] == NULL) {
       return status = -1;
     }
@@ -956,13 +956,13 @@ static INT _initSTFT(IIS_FORMATCONVERTER_INTERNAL* _p) {
 
   if (_p->immersiveDownmixFlag) {
     /* Initialize prevInputBufferStft */
-    _p->prevInputBufferStft = (FIXP_DBL**)FDKcalloc((TFRA + 1), sizeof(FIXP_DBL*));
+    _p->prevInputBufferStft = (FIXP_DBL**)mpegh_FDKcalloc((TFRA + 1), sizeof(FIXP_DBL*));
     if (_p->prevInputBufferStft == NULL) {
       return status = -1;
     }
     for (ch = 0; ch < (TFRA + 1); ch++) {
       _p->prevInputBufferStft[ch] =
-          (FIXP_DBL*)FDKaalloc(_p->stftLength * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
+          (FIXP_DBL*)mpegh_FDKaalloc(_p->stftLength * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
       if (_p->prevInputBufferStft[ch] == NULL) {
         status = -1;
       }
@@ -979,13 +979,13 @@ static INT _initSTFT(IIS_FORMATCONVERTER_INTERNAL* _p) {
   }
 
   /*Initialize Synthesis filterbank*/
-  _p->outputBufferStft = (FIXP_DBL**)FDKcalloc(_p->numOutputChannels, sizeof(FIXP_DBL*));
+  _p->outputBufferStft = (FIXP_DBL**)mpegh_FDKcalloc(_p->numOutputChannels, sizeof(FIXP_DBL*));
   if (_p->outputBufferStft == NULL) {
     return status = -1;
   }
   for (ch = 0; ch < _p->numOutputChannels; ch++) {
     _p->outputBufferStft[ch] =
-        (FIXP_DBL*)FDKaalloc(_p->stftLength * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
+        (FIXP_DBL*)mpegh_FDKaalloc(_p->stftLength * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
     if (_p->outputBufferStft[ch] == NULL) {
       status = -1;
     }
diff --git a/src/libFormatConverter/src/FDK_formatConverter_activeDmx_stft.cpp b/src/libFormatConverter/src/FDK_formatConverter_activeDmx_stft.cpp
index c6a0700..4545804 100644
--- a/src/libFormatConverter/src/FDK_formatConverter_activeDmx_stft.cpp
+++ b/src/libFormatConverter/src/FDK_formatConverter_activeDmx_stft.cpp
@@ -129,7 +129,7 @@ INT activeDmxStftInit(void** handle, UINT numInChans, UINT numOutChans, FIXP_DBL
   FDK_ASSERT(numInChans <= MAX_CHANNELS);
   FDK_ASSERT(numOutChans <= MAX_CHANNELS);
 
-  *handle = (activeDownmixer*)FDKaalloc(sizeof(activeDownmixer), ALIGNMENT_DEFAULT);
+  *handle = (activeDownmixer*)mpegh_FDKaalloc(sizeof(activeDownmixer), ALIGNMENT_DEFAULT);
   if (*handle == NULL) {
     return status = -1;
   }
@@ -146,28 +146,28 @@ INT activeDmxStftInit(void** handle, UINT numInChans, UINT numOutChans, FIXP_DBL
     h->realizedSigHeadroomPrev[erb] = 31; /* start value */
   }
 
-  h->targetEnePrev = (FIXP_DBL**)FDKcalloc(numOutChans, sizeof(FIXP_DBL*));
+  h->targetEnePrev = (FIXP_DBL**)mpegh_FDKcalloc(numOutChans, sizeof(FIXP_DBL*));
   if (h->targetEnePrev == NULL) {
     return status = -1;
   }
-  h->realizedEnePrev = (FIXP_DBL**)FDKcalloc(numOutChans, sizeof(FIXP_DBL*));
+  h->realizedEnePrev = (FIXP_DBL**)mpegh_FDKcalloc(numOutChans, sizeof(FIXP_DBL*));
   if (h->realizedEnePrev == NULL) {
     return status = -1;
   }
   for (ch = 0; ch < numOutChans; ch++) {
     h->targetEnePrev[ch] =
-        (FIXP_DBL*)FDKaalloc(STFT_ERB_BANDS * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
+        (FIXP_DBL*)mpegh_FDKaalloc(STFT_ERB_BANDS * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
     if (h->targetEnePrev[ch] == NULL) {
       status = -1;
     }
     h->realizedEnePrev[ch] =
-        (FIXP_DBL*)FDKaalloc(STFT_ERB_BANDS * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
+        (FIXP_DBL*)mpegh_FDKaalloc(STFT_ERB_BANDS * sizeof(FIXP_DBL), ALIGNMENT_DEFAULT);
     if (h->realizedEnePrev[ch] == NULL) {
       status = -1;
     }
   }
 
-  h->targetEnePrevExp = (INT*)FDKaalloc(STFT_ERB_BANDS * sizeof(INT), ALIGNMENT_DEFAULT);
+  h->targetEnePrevExp = (INT*)mpegh_FDKaalloc(STFT_ERB_BANDS * sizeof(INT), ALIGNMENT_DEFAULT);
   if (h->targetEnePrevExp == NULL) {
     status = -1;
   }
@@ -192,23 +192,23 @@ void activeDmxClose_STFT(void* handle) {
     for (ch = 0; ch < h->numOutChans; ch++) {
       if (h->targetEnePrev) {
         if (h->targetEnePrev[ch]) {
-          FDKafree(h->targetEnePrev[ch]);
+          mpegh_FDKafree(h->targetEnePrev[ch]);
         }
       }
       if (h->realizedEnePrev) {
         if (h->realizedEnePrev[ch]) {
-          FDKafree(h->realizedEnePrev[ch]);
+          mpegh_FDKafree(h->realizedEnePrev[ch]);
         }
       }
     }
 
-    FDKfree(h->targetEnePrev);
-    FDKfree(h->realizedEnePrev);
+    mpegh_FDKfree(h->targetEnePrev);
+    mpegh_FDKfree(h->realizedEnePrev);
     if (h->targetEnePrevExp) {
-      FDKafree(h->targetEnePrevExp);
+      mpegh_FDKafree(h->targetEnePrevExp);
     }
 
-    FDKafree(h);
+    mpegh_FDKafree(h);
   }
 }
 
@@ -418,7 +418,7 @@ void activeDmxProcess_STFT(void* handle) {
       erb_stop_ix = erb_freq_idx_256_58[erb];
       inBufStftHeadroom[erb] =
           fMin(inBufStftHeadroom[erb],
-               getScalefactor(&inBuf[2 * erb_start_ix], 2 * (erb_stop_ix - erb_start_ix)));
+               mpegh_getScalefactor(&inBuf[2 * erb_start_ix], 2 * (erb_stop_ix - erb_start_ix)));
       erb_start_ix = erb_stop_ix; /* for next loop iteration */
     }
   }
@@ -436,7 +436,7 @@ void activeDmxProcess_STFT(void* handle) {
         erb_stop_ix = erb_freq_idx_256_58[erb];
         inBufStftHeadroom[erb] =
             fMin(inBufStftHeadroom[erb],
-                 getScalefactor(&inBuf[2 * erb_start_ix], 2 * (erb_stop_ix - erb_start_ix)));
+                 mpegh_getScalefactor(&inBuf[2 * erb_start_ix], 2 * (erb_stop_ix - erb_start_ix)));
         erb_start_ix = erb_stop_ix; /* for next loop iteration */
       }
     }
@@ -446,9 +446,9 @@ void activeDmxProcess_STFT(void* handle) {
   /*               Clear Buffer                */
   /*********************************************/
   for (chOut = 0; chOut < numOutChans; chOut++) {
-    FDKmemclear(realizedSig[chOut], STFT_LENGTH * sizeof(FIXP_DBL));
+    mpegh_FDKmemclear(realizedSig[chOut], STFT_LENGTH * sizeof(FIXP_DBL));
   }
-  FDKmemclear(targetEneArr, STFT_ERB_BANDS * numOutChans * sizeof(FIXP_DBL));
+  mpegh_FDKmemclear(targetEneArr, STFT_ERB_BANDS * numOutChans * sizeof(FIXP_DBL));
 
   UINT erb_is4GVH_L = 58, erb_is4GVH_H = 58;
 
@@ -585,7 +585,7 @@ void activeDmxProcess_STFT(void* handle) {
       erb_stop_ix = erb_freq_idx_256_58[erb];
       realizedSigHeadroom[erb] = fMin(
           realizedSigHeadroom[erb],
-          getScalefactor(&realizedSig[chOut][2 * erb_start_ix], 2 * (erb_stop_ix - erb_start_ix)));
+          mpegh_getScalefactor(&realizedSig[chOut][2 * erb_start_ix], 2 * (erb_stop_ix - erb_start_ix)));
       erb_start_ix = erb_stop_ix; /* for next loop iteration */
     }
   }
@@ -607,19 +607,19 @@ void activeDmxProcess_STFT(void* handle) {
   if (immersiveMode) {
     for (chIn = 0; chIn < h->numInChans; chIn++) {
       if (chIn == (UINT)_p->topIn[TFL])
-        FDKmemcpy(h->prevInputBufferStft[TFL], h->inputBufferStft[chIn],
+        mpegh_FDKmemcpy(h->prevInputBufferStft[TFL], h->inputBufferStft[chIn],
                   STFT_LENGTH * sizeof(FIXP_DBL));
       if (chIn == (UINT)_p->topIn[TFC])
-        FDKmemcpy(h->prevInputBufferStft[TFC], h->inputBufferStft[chIn],
+        mpegh_FDKmemcpy(h->prevInputBufferStft[TFC], h->inputBufferStft[chIn],
                   STFT_LENGTH * sizeof(FIXP_DBL));
       if (chIn == (UINT)_p->topIn[TFR])
-        FDKmemcpy(h->prevInputBufferStft[TFR], h->inputBufferStft[chIn],
+        mpegh_FDKmemcpy(h->prevInputBufferStft[TFR], h->inputBufferStft[chIn],
                   STFT_LENGTH * sizeof(FIXP_DBL));
       if (chIn == (UINT)_p->topIn[TFLA])
-        FDKmemcpy(h->prevInputBufferStft[TFLA], h->inputBufferStft[chIn],
+        mpegh_FDKmemcpy(h->prevInputBufferStft[TFLA], h->inputBufferStft[chIn],
                   STFT_LENGTH * sizeof(FIXP_DBL));
       if (chIn == (UINT)_p->topIn[TFRA])
-        FDKmemcpy(h->prevInputBufferStft[TFRA], h->inputBufferStft[chIn],
+        mpegh_FDKmemcpy(h->prevInputBufferStft[TFRA], h->inputBufferStft[chIn],
                   STFT_LENGTH * sizeof(FIXP_DBL));
     }
   }
@@ -767,7 +767,7 @@ void activeDmxProcess_STFT(void* handle) {
     for (chOut = 0; chOut < numOutChans; chOut++) {
       if (chOut_count[chOut] != 0) {
         /* Passive downmix, AES == 0. EQ = 1.0 */
-        scaleValues(realizedSig[chOut], 2 * erb_freq_idx_256_58[STFT_ERB_BANDS - 1], eq_e);
+        mpegh_scaleValues(realizedSig[chOut], 2 * erb_freq_idx_256_58[STFT_ERB_BANDS - 1], eq_e);
       }
     }
   } else
diff --git a/src/libFormatConverter/src/FDK_formatConverter_data.cpp b/src/libFormatConverter/src/FDK_formatConverter_data.cpp
index 3756065..bde5324 100644
--- a/src/libFormatConverter/src/FDK_formatConverter_data.cpp
+++ b/src/libFormatConverter/src/FDK_formatConverter_data.cpp
@@ -165,13 +165,13 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
   INT status = 0;
   /* dmx mtx */
   fcInt->fcParams->dmxMtx =
-      (FIXP_DMX_H**)FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->dmxMtx);
+      (FIXP_DMX_H**)mpegh_FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->dmxMtx);
   if (fcInt->fcParams->dmxMtx == NULL) {
     return status = -1;
   }
   for (i = 0; i < fcInt->numTotalInputChannels; i++) {
     fcInt->fcParams->dmxMtx[i] =
-        (FIXP_DMX_H*)FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->dmxMtx[i]);
+        (FIXP_DMX_H*)mpegh_FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->dmxMtx[i]);
     if (fcInt->fcParams->dmxMtx[i] == NULL) {
       status = -1;
     }
@@ -179,7 +179,7 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* dmx mtx sorted */
   fcInt->fcParams->dmxMtx_sorted =
-      (FIXP_DMX_H*)FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
+      (FIXP_DMX_H*)mpegh_FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
                              sizeof *fcInt->fcParams->dmxMtx_sorted);
   if (fcInt->fcParams->dmxMtx_sorted == NULL) {
     status = -1;
@@ -187,13 +187,13 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* dmx mtx L */
   fcInt->fcParams->dmxMtxL =
-      (FIXP_DMX_H**)FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->dmxMtxL);
+      (FIXP_DMX_H**)mpegh_FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->dmxMtxL);
   if (fcInt->fcParams->dmxMtxL == NULL) {
     return -1;
   }
   for (i = 0; i < fcInt->numTotalInputChannels; i++) {
     fcInt->fcParams->dmxMtxL[i] =
-        (FIXP_DMX_H*)FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->dmxMtxL[i]);
+        (FIXP_DMX_H*)mpegh_FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->dmxMtxL[i]);
     if (fcInt->fcParams->dmxMtxL[i] == NULL) {
       return -1;
     }
@@ -201,7 +201,7 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* dmx mtx L sorted */
   fcInt->fcParams->dmxMtxL_sorted =
-      (FIXP_DMX_H*)FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
+      (FIXP_DMX_H*)mpegh_FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
                              sizeof *fcInt->fcParams->dmxMtxL_sorted);
   if (fcInt->fcParams->dmxMtxL_sorted == NULL) {
     return -1;
@@ -209,13 +209,13 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* dmx mtx 2 */
   fcInt->fcParams->dmxMtx2 =
-      (FIXP_DMX_H**)FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->dmxMtx2);
+      (FIXP_DMX_H**)mpegh_FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->dmxMtx2);
   if (fcInt->fcParams->dmxMtx2 == NULL) {
     return -1;
   }
   for (i = 0; i < fcInt->numTotalInputChannels; i++) {
     fcInt->fcParams->dmxMtx2[i] =
-        (FIXP_DMX_H*)FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->dmxMtx2[i]);
+        (FIXP_DMX_H*)mpegh_FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->dmxMtx2[i]);
     if (fcInt->fcParams->dmxMtx2[i] == NULL) {
       return -1;
     }
@@ -223,7 +223,7 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* dmx mtx 2 sorted */
   fcInt->fcParams->dmxMtx2_sorted =
-      (FIXP_DMX_H*)FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
+      (FIXP_DMX_H*)mpegh_FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
                              sizeof *fcInt->fcParams->dmxMtx2_sorted);
   if (fcInt->fcParams->dmxMtx2_sorted == NULL) {
     return -1;
@@ -231,26 +231,26 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* Eq index vector */
   fcInt->fcParams->eqIndexVec =
-      (INT**)FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->eqIndexVec);
+      (INT**)mpegh_FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->eqIndexVec);
   if (fcInt->fcParams->eqIndexVec == NULL) {
     return status = -1;
   }
   for (i = 0; i < fcInt->numTotalInputChannels; i++) {
     fcInt->fcParams->eqIndexVec[i] =
-        (INT*)FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->eqIndexVec[i]);
+        (INT*)mpegh_FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->eqIndexVec[i]);
     if (fcInt->fcParams->eqIndexVec[i] == NULL) {
       status = -1;
     }
   }
   /* Eq index vector 2 */
   fcInt->fcParams->eqIndexVec2 =
-      (INT**)FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->eqIndexVec2);
+      (INT**)mpegh_FDKcalloc(fcInt->numTotalInputChannels, sizeof *fcInt->fcParams->eqIndexVec2);
   if (fcInt->fcParams->eqIndexVec2 == NULL) {
     return -1;
   }
   for (i = 0; i < fcInt->numTotalInputChannels; i++) {
     fcInt->fcParams->eqIndexVec2[i] =
-        (INT*)FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->eqIndexVec2[i]);
+        (INT*)mpegh_FDKcalloc(fcInt->numOutputChannels, sizeof *fcInt->fcParams->eqIndexVec2[i]);
     if (fcInt->fcParams->eqIndexVec2[i] == NULL) {
       return -1;
     }
@@ -258,7 +258,7 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* Eq index vector sorted */
   fcInt->fcParams->eqIndexVec_sorted =
-      (INT*)FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
+      (INT*)mpegh_FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
                       sizeof *fcInt->fcParams->eqIndexVec_sorted);
   if (fcInt->fcParams->eqIndexVec_sorted == NULL) {
     status = -1;
@@ -266,7 +266,7 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* Eq index vector sorted 2 */
   fcInt->fcParams->eqIndexVec2_sorted =
-      (INT*)FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
+      (INT*)mpegh_FDKcalloc(fcInt->numTotalInputChannels * fcInt->numOutputChannels,
                       sizeof *fcInt->fcParams->eqIndexVec2_sorted);
   if (fcInt->fcParams->eqIndexVec2_sorted == NULL) {
     return -1;
@@ -274,7 +274,7 @@ int allocateFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
 
   /* internal structure */
   fcInt->fcParams->formatConverterParams_internal =
-      (converter_pr_t*)FDKcalloc(1, sizeof *fcInt->fcParams->formatConverterParams_internal);
+      (converter_pr_t*)mpegh_FDKcalloc(1, sizeof *fcInt->fcParams->formatConverterParams_internal);
   if (fcInt->fcParams->formatConverterParams_internal == NULL) {
     status = -1;
   }
@@ -290,7 +290,7 @@ int allocateFormatConverterEQs(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
   /* eqGains */
   if (fcInt->eqGains[0] == NULL) {
     for (INT i = 0; i < (INT)numInputChannels; i++) {
-      fcInt->eqGains[i] = (FIXP_EQ_H*)FDKcalloc(STFT_ERB_BANDS, sizeof *fcInt->eqGains[i]);
+      fcInt->eqGains[i] = (FIXP_EQ_H*)mpegh_FDKcalloc(STFT_ERB_BANDS, sizeof *fcInt->eqGains[i]);
       if (fcInt->eqGains[i] == NULL) {
         return -1;
       }
@@ -312,16 +312,16 @@ void freeFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
       /*
       if( fcInt->fcParams->dmxMtx[i] != NULL && fcInt->fcParams->dmxMtxIsSet )
       {*/
-      FDKfree(fcInt->fcParams->dmxMtx[i]);
+      mpegh_FDKfree(fcInt->fcParams->dmxMtx[i]);
       /*}*/
     }
   }
-  FDKfree(fcInt->fcParams->dmxMtx);
+  mpegh_FDKfree(fcInt->fcParams->dmxMtx);
   fcInt->fcParams->dmxMtx = NULL;
 
   /* dmx mtx sorted */
 
-  FDKfree(fcInt->fcParams->dmxMtx_sorted);
+  mpegh_FDKfree(fcInt->fcParams->dmxMtx_sorted);
   fcInt->fcParams->dmxMtx_sorted = NULL;
 
   /* dmx mtx L */
@@ -331,16 +331,16 @@ void freeFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
       /*
       if( fcInt->fcParams->dmxMtxL[i] != NULL && fcInt->fcParams->dmxMtxLIsSet )
       {*/
-      FDKfree(fcInt->fcParams->dmxMtxL[i]);
+      mpegh_FDKfree(fcInt->fcParams->dmxMtxL[i]);
       /*}*/
     }
   }
-  FDKfree(fcInt->fcParams->dmxMtxL);
+  mpegh_FDKfree(fcInt->fcParams->dmxMtxL);
   fcInt->fcParams->dmxMtxL = NULL;
 
   /* dmx mtx L sorted */
 
-  FDKfree(fcInt->fcParams->dmxMtxL_sorted);
+  mpegh_FDKfree(fcInt->fcParams->dmxMtxL_sorted);
   fcInt->fcParams->dmxMtxL_sorted = NULL;
 
   /* dmx mtx 2 */
@@ -349,53 +349,53 @@ void freeFormatConverterParams(IIS_FORMATCONVERTER_INTERNAL_HANDLE fcInt) {
       /*
       if( fcInt->fcParams->dmxMtx2[i] != NULL && fcInt->fcParams->dmxMtx2IsSet )
       {*/
-      FDKfree(fcInt->fcParams->dmxMtx2[i]);
+      mpegh_FDKfree(fcInt->fcParams->dmxMtx2[i]);
       /*}*/
     }
   }
-  FDKfree(fcInt->fcParams->dmxMtx2);
+  mpegh_FDKfree(fcInt->fcParams->dmxMtx2);
   fcInt->fcParams->dmxMtx2 = NULL;
 
   /* dmx mtx 2 sorted */
 
-  FDKfree(fcInt->fcParams->dmxMtx2_sorted);
+  mpegh_FDKfree(fcInt->fcParams->dmxMtx2_sorted);
   fcInt->fcParams->dmxMtx2_sorted = NULL;
 
   /* eqIndexVec */
   if (fcInt->fcParams->eqIndexVec != NULL) {
     for (i = 0; i < fcInt->numTotalInputChannels; i++) {
-      FDKfree(fcInt->fcParams->eqIndexVec[i]);
+      mpegh_FDKfree(fcInt->fcParams->eqIndexVec[i]);
     }
   }
-  FDKfree(fcInt->fcParams->eqIndexVec);
+  mpegh_FDKfree(fcInt->fcParams->eqIndexVec);
   fcInt->fcParams->eqIndexVec = NULL;
   /* eqIndexVec sorted */
 
-  FDKfree(fcInt->fcParams->eqIndexVec_sorted);
+  mpegh_FDKfree(fcInt->fcParams->eqIndexVec_sorted);
 
   /* eqIndexVec 2 */
   if (fcInt->fcParams->eqIndexVec2 != NULL) {
     for (i = 0; i < fcInt->numTotalInputChannels; i++) {
-      FDKfree(fcInt->fcParams->eqIndexVec2[i]);
+      mpegh_FDKfree(fcInt->fcParams->eqIndexVec2[i]);
     }
   }
-  FDKfree(fcInt->fcParams->eqIndexVec2);
+  mpegh_FDKfree(fcInt->fcParams->eqIndexVec2);
   fcInt->fcParams->eqIndexVec2 = NULL; /* eqIndexVec sorted */
 
-  FDKfree(fcInt->fcParams->eqIndexVec2_sorted);
+  mpegh_FDKfree(fcInt->fcParams->eqIndexVec2_sorted);
 
   fcInt->fcParams->eqIndexVec2_sorted = NULL;
 
   /* eqGains */
   for (i = 0; i < FDK_FORMAT_CONVERTER_MAX_INPUT_CHANNELS; i++) {
     if (fcInt->eqGains[i] != NULL) {
-      FDKfree(fcInt->eqGains[i]);
+      mpegh_FDKfree(fcInt->eqGains[i]);
     }
   }
 
   /* internal structure */
   if (fcInt->fcParams->formatConverterParams_internal != NULL) {
-    FDKfree(fcInt->fcParams->formatConverterParams_internal);
+    mpegh_FDKfree(fcInt->fcParams->formatConverterParams_internal);
     fcInt->fcParams->formatConverterParams_internal = NULL;
   }
 }
diff --git a/src/libFormatConverter/src/FDK_formatConverter_init.cpp b/src/libFormatConverter/src/FDK_formatConverter_init.cpp
index 2e89943..04c02af 100644
--- a/src/libFormatConverter/src/FDK_formatConverter_init.cpp
+++ b/src/libFormatConverter/src/FDK_formatConverter_init.cpp
@@ -1260,9 +1260,9 @@ converter_status_t converter_init(
 
   if ((fcInt->immersiveDownmixFlag == 1) && ((nchanout == 5) || (nchanout == 6))) {
     initElevSptlParms(fcInt, sfreq_Hz, nchanout);
-    FDKmemcpy(dmx_rules, dmx_rules_immersive, sizeof(dmx_rules_immersive));
+    mpegh_FDKmemcpy(dmx_rules, dmx_rules_immersive, sizeof(dmx_rules_immersive));
   } else {
-    FDKmemcpy(dmx_rules, dmx_rules_classic, sizeof(dmx_rules_classic));
+    mpegh_FDKmemcpy(dmx_rules, dmx_rules_classic, sizeof(dmx_rules_classic));
   }
 
   /* more parameter error checking */
@@ -1465,11 +1465,11 @@ converter_status_t converter_init(
               alpha = fMult(alpha, FX_PI);
               INT alpha_e = 3;
 
-              FIXP_DBL sin_alpha0_m = fixp_sin(alpha0, alpha0_e);
-              FIXP_DBL cos_alpha0_m = fixp_cos(alpha0, alpha0_e);
+              FIXP_DBL sin_alpha0_m = mpegh_fixp_sin(alpha0, alpha0_e);
+              FIXP_DBL cos_alpha0_m = mpegh_fixp_cos(alpha0, alpha0_e);
 
-              FIXP_DBL sin_alpha_m = fixp_sin(alpha, alpha_e);
-              FIXP_DBL cos_alpha_m = fixp_cos(alpha, alpha_e);
+              FIXP_DBL sin_alpha_m = mpegh_fixp_sin(alpha, alpha_e);
+              FIXP_DBL cos_alpha_m = mpegh_fixp_cos(alpha, alpha_e);
 
               FIXP_DBL tan_alpha0_m = fDivNormSigned(sin_alpha0_m, cos_alpha0_m, &alpha0_e);
               FIXP_DBL tan_alpha_m = fDivNormSigned(sin_alpha_m, cos_alpha_m, &alpha_e);
@@ -1753,11 +1753,11 @@ converter_status_t converter_init(
                 alpha = fMult(alpha, FX_PI);
                 INT alpha_e = 3;
 
-                FIXP_DBL sin_alpha0_m = fixp_sin(alpha0, alpha0_e);
-                FIXP_DBL cos_alpha0_m = fixp_cos(alpha0, alpha0_e);
+                FIXP_DBL sin_alpha0_m = mpegh_fixp_sin(alpha0, alpha0_e);
+                FIXP_DBL cos_alpha0_m = mpegh_fixp_cos(alpha0, alpha0_e);
 
-                FIXP_DBL sin_alpha_m = fixp_sin(alpha, alpha_e);
-                FIXP_DBL cos_alpha_m = fixp_cos(alpha, alpha_e);
+                FIXP_DBL sin_alpha_m = mpegh_fixp_sin(alpha, alpha_e);
+                FIXP_DBL cos_alpha_m = mpegh_fixp_cos(alpha, alpha_e);
 
                 FIXP_DBL tan_alpha0_m = fDivNormSigned(sin_alpha0_m, cos_alpha0_m, &alpha0_e);
                 FIXP_DBL tan_alpha_m = fDivNormSigned(sin_alpha_m, cos_alpha_m, &alpha_e);
diff --git a/src/libIGFdec/src/FDK_igfDec.cpp b/src/libIGFdec/src/FDK_igfDec.cpp
index 625720e..21c9164 100644
--- a/src/libIGFdec/src/FDK_igfDec.cpp
+++ b/src/libIGFdec/src/FDK_igfDec.cpp
@@ -419,7 +419,7 @@ resets the internal decoder memory (context memory)
 **************************************************************************/
 static void iisIGFDecLibResetSCF(IGF_PRIVATE_STATIC_DATA* hPrivateStaticData,
                                  IGF_PRIVATE_DATA* hPrivateData, const INT frameType) {
-  FDKmemclear(hPrivateData->bitstreamData[frameType].sfe,
+  mpegh_FDKmemclear(hPrivateData->bitstreamData[frameType].sfe,
               sizeof(hPrivateData->bitstreamData[frameType].sfe));
 
   iisIGFSCFDecoderReset(&(hPrivateStaticData->hIGFSCFDecoder));
@@ -510,7 +510,7 @@ static void getWhiteSpectralData(FIXP_DBL* in, FIXP_DBL* out, FIXP_DBL* working_
   INT n_min;
 
   /* Find available headroom in input signal */
-  shl1 = getScalefactor(&in[start - 3], stop - start + 3);
+  shl1 = mpegh_getScalefactor(&in[start - 3], stop - start + 3);
 
   /* Generate 1e-3 in Q-10.41 */
   env = (ULONG)0x83126E98;        /* 0x4189374c<<1 */
@@ -647,7 +647,7 @@ static void getWhiteSpectralData(FIXP_DBL* in, FIXP_DBL* out, FIXP_DBL* working_
   /* Check, if all in[i] are zero, ... */
   if (n_min == 1000) {
     /* Obviously all in[i] are ZERO, let's quit after clearing the output */
-    FDKmemclear(&out[start], sizeof(FIXP_DBL) * (stop - start));
+    mpegh_FDKmemclear(&out[start], sizeof(FIXP_DBL) * (stop - start));
     hWorkMem->Initial_exp[0] = 0;
   } else {
     /* make n_min even */
@@ -741,7 +741,7 @@ static void iisIGFDecoderApplyWhitening(
           keep_tile_num = tile;
           run_once = 1;
         } else { /* when run once, then just copy  for the other tiles */
-          FDKmemcpy(hMap->fSpectrumTab[0], (&hGrid->sIGFMapInfoTab[keep_tile_num])->fSpectrumTab[0],
+          mpegh_FDKmemcpy(hMap->fSpectrumTab[0], (&hGrid->sIGFMapInfoTab[keep_tile_num])->fSpectrumTab[0],
                     sizeof(FIXP_DBL) * (hGrid->iIGFStartLine));
           hWorkMem->Initial_exp[0] = keep_initial_value;
         }
@@ -758,7 +758,7 @@ static void iisIGFDecoderApplyWhitening(
       width = hMap->iWidth;
 
       FIXP_DBL* p2_tile = hMap->fSpectrumTab[0];
-      FDKmemclear(p2_tile, sizeof(FIXP_DBL) * width);
+      mpegh_FDKmemclear(p2_tile, sizeof(FIXP_DBL) * width);
 
       /* The RNG acts differently for mono and stereo */
       if (mono_or_stereo_flag == 0) {
@@ -1085,7 +1085,7 @@ static void iisIGFDecoderCollectEnergiesMono(
 
       *temp_IGF_band += width;
 
-      shift = getScalefactor(pSpectralData_tb, width);
+      shift = mpegh_getScalefactor(pSpectralData_tb, width);
       shift1 = hWorkMem->intermediate_shift[win * IGF_MAX_SFB_SHORT + sfb];
 
       /*Calculate the normalization necessary due to addition*/
@@ -1264,7 +1264,7 @@ static void iisIGFDecoderMappingMono(
                               hMap->iDesStart, hGrid->iIGFStartLine, hGrid->iIGFMinLine,
                               &hMap->fSpectrumTab[0][0] + win * 128, *temp_IGF_band);
     } else {
-      FDKmemcpy(*temp_IGF_band, &hMap->fSpectrumTab[0][0] + win * 128,
+      mpegh_FDKmemcpy(*temp_IGF_band, &hMap->fSpectrumTab[0][0] + win * 128,
                 sizeof(FIXP_DBL) * (int)width);
     }
 
@@ -1275,7 +1275,7 @@ static void iisIGFDecoderMappingMono(
       FIXP_DBL* p2_temp_IGF_band = *temp_IGF_band;
 
       hWorkMem->intermediate_shift[win * IGF_MAX_SFB_SHORT + sfb] =
-          getScalefactor(p2_temp_IGF_band, width);
+          mpegh_getScalefactor(p2_temp_IGF_band, width);
 
       hWorkMem->Initial_exp[win * IGF_MAX_SFB_SHORT + sfb] =
           hWorkMem->Initial_exp[win * IGF_MAX_SFB_SHORT];
@@ -1352,7 +1352,7 @@ static void iisIGFDecoderMappingAndMSStereo(
                               hMapL->iDesStart, hGridL->iIGFStartLine, hGridL->iIGFMinLine,
                               &hMapL->fSpectrumTab[0][0] + win * 128, *temp_IGF_bandL);
     } else {
-      FDKmemcpy(*temp_IGF_bandL, &hMapL->fSpectrumTab[0][0] + win * 128,
+      mpegh_FDKmemcpy(*temp_IGF_bandL, &hMapL->fSpectrumTab[0][0] + win * 128,
                 sizeof(FIXP_DBL) * (int)width);
     }
 
@@ -1363,7 +1363,7 @@ static void iisIGFDecoderMappingAndMSStereo(
                               hMapL->iDesStart, hGridR->iIGFStartLine, hGridR->iIGFMinLine,
                               &hMapR->fSpectrumTab[0][0] + win * 128, *temp_IGF_bandR);
     } else {
-      FDKmemcpy(*temp_IGF_bandR, &hMapR->fSpectrumTab[0][0] + win * 128,
+      mpegh_FDKmemcpy(*temp_IGF_bandR, &hMapR->fSpectrumTab[0][0] + win * 128,
                 sizeof(FIXP_DBL) * (int)width);
     }
 
@@ -1402,7 +1402,7 @@ static void iisIGFDecoderMappingAndMSStereo(
           *p2_temp_IGF_bandR++ = val1R;
         } /* while(width--) */
 
-        FDKmemset(TNF_mask, 0x01, sizeof(UCHAR) * width);
+        mpegh_FDKmemset(TNF_mask, 0x01, sizeof(UCHAR) * width);
 
         if (delta >= 0) {
           hWorkMemR->Initial_exp[win * IGF_MAX_SFB_SHORT + sfb] += delta;
@@ -1416,9 +1416,9 @@ static void iisIGFDecoderMappingAndMSStereo(
 
       /* Find leading zeroes */
       hWorkMemL->intermediate_shift[win * IGF_MAX_SFB_SHORT + sfb] =
-          getScalefactor(*temp_IGF_bandL, width);
+          mpegh_getScalefactor(*temp_IGF_bandL, width);
       hWorkMemR->intermediate_shift[win * IGF_MAX_SFB_SHORT + sfb] =
-          getScalefactor(*temp_IGF_bandR, width);
+          mpegh_getScalefactor(*temp_IGF_bandR, width);
 
       *temp_IGF_bandL += width;
       *temp_IGF_bandR += width;
@@ -2136,7 +2136,7 @@ void CIgf_apply_stereo(IGF_PRIVATE_STATIC_DATA_HANDLE hPrivateStaticDataL,
                                    (hPrivateDataR->bitstreamData[frameType].igfUseEnfFlat)));
 
   UCHAR TNF_mask[1024];
-  FDKmemclear(TNF_mask + IGFstartLine, sizeof(UCHAR) * (IGFstopLine - IGFstartLine));
+  mpegh_FDKmemclear(TNF_mask + IGFstartLine, sizeof(UCHAR) * (IGFstopLine - IGFstartLine));
 
   for (group = 0; group < numOfGroups; group++) {
     /* memorize the offset of windows in a group: */
@@ -2250,7 +2250,7 @@ static void iisIGFDecLibInjectSourceSpectrum(
     hMap = &hGrid->sIGFMapInfoTab[t];
 
     /* copy from pSpectralData to the internal representation: */
-    FDKmemcpy(hMap->fSpectrumTab[0], pSpectralData, sizeof(FIXP_DBL) * copyNr);
+    mpegh_FDKmemcpy(hMap->fSpectrumTab[0], pSpectralData, sizeof(FIXP_DBL) * copyNr);
   }
 
   for (UCHAR t = 0; t < hGrid->iIGFNumTile; t++) {
@@ -2278,7 +2278,7 @@ void iisIGFDecLibInjectSourceSpectrumNew(
 
   for (t = 0; t < hGrid->iIGFNumTile; t++) {
     /* copy from pSpectralData scaling to the internal representation: */
-    FDKmemcpy(hPrivateStaticData->fSpectrumTab_sfb_exp[t], pSpectralData_exp,
+    mpegh_FDKmemcpy(hPrivateStaticData->fSpectrumTab_sfb_exp[t], pSpectralData_exp,
               sizeof(SHORT) * IGF_MAX_WIN * IGF_MAX_SFB_SHORT);
 
   } /* for( t = 0; t < hGrid->iIGFNumTile; t++ ) */
@@ -2287,7 +2287,7 @@ void iisIGFDecLibInjectSourceSpectrumNew(
     hMap = &hGrid->sIGFMapInfoTab[t];
 
     /* copy from pSpectralData to the internal representation: */
-    FDKmemcpy(hMap->fSpectrumTab[0], pSpectralData, sizeof(FIXP_DBL) * 1024);
+    mpegh_FDKmemcpy(hMap->fSpectrumTab[0], pSpectralData, sizeof(FIXP_DBL) * 1024);
 
   } /* for( t = 0; t < hGrid->iIGFNumTile; t++ ) */
 }
@@ -2526,7 +2526,7 @@ INT iisIGFDecLibGetNumberOfTiles(IGF_PRIVATE_STATIC_DATA_HANDLE hPrivateStaticDa
 
 static void DotProduct(FIXP_DBL* Output, INT* Output_exp, FIXP_DBL* Input, INT Input_exp,
                        INT length) {
-  INT shift = getScalefactor(Input, length);
+  INT shift = mpegh_getScalefactor(Input, length);
 
   const int loop_shift = DFRACT_BITS - fNormz((FIXP_DBL)length);
 
@@ -2546,7 +2546,7 @@ static void DotProduct(FIXP_DBL* Output, INT* Output_exp, FIXP_DBL* Input, INT I
 
 static FIXP_DBL Same_Exponent_Correlation(FIXP_DBL* X, FIXP_DBL* Y, INT* Exp, INT signal_length,
                                           INT correlation_length) {
-  INT shift = getScalefactor(X, signal_length);
+  INT shift = mpegh_getScalefactor(X, signal_length);
 
   /* Find a suitable shift for dmx addition */
   INT loop_shift = 31 - fixnorm_D(correlation_length);
@@ -2698,7 +2698,7 @@ static void iisIGF_TNFdetect(FIXP_DBL* p2_spectrum, const SHORT* specScale, cons
   StoreValues_Exp = maxExp - min_rxx_headroom;
 
   /* Allign maximum left for high precision */
-  INT shiftStV = getScalefactor(StoreValues + 1, (INT)maxOrder);
+  INT shiftStV = mpegh_getScalefactor(StoreValues + 1, (INT)maxOrder);
   for (int i = 1; i <= (INT)maxOrder; i++) {
     StoreValues[i] <<= shiftStV;
   }
@@ -2728,7 +2728,7 @@ static void iisIGF_TNFdetect(FIXP_DBL* p2_spectrum, const SHORT* specScale, cons
 static void iisIGF_TNFfilter(FIXP_DBL* p2_spectrum, const SHORT specScale, const SHORT numOfLines,
                              const UCHAR FilterOrder, const FIXP_DBL* Aarray, const INT AarrayExp) {
   /* Find the available headroom of the downmix signal and a suitable shift value*/
-  INT head_shift = getScalefactor(p2_spectrum, numOfLines);
+  INT head_shift = mpegh_getScalefactor(p2_spectrum, numOfLines);
 
   if (head_shift == 31) head_shift = 0;
 
@@ -2781,7 +2781,7 @@ void CIgf_TNF_apply(IGF_PRIVATE_STATIC_DATA_HANDLE hPrivateStaticData,
     UCHAR curr_order = 0;
 
     /* Filter coefficient array. The first value is always 1 */
-    FDKmemclear(Aarray, (TNF_MAX_FILTER_ORDER + 1) * sizeof(FIXP_DBL));
+    mpegh_FDKmemclear(Aarray, (TNF_MAX_FILTER_ORDER + 1) * sizeof(FIXP_DBL));
 
     /* "virtualSpec" contains a modified IGF spectrum values.  Typically IGF fills the zero-gaps
     with values from the base spectrum and leaves the non-zero values intact. In this spectrum
diff --git a/src/libIGFdec/src/FDK_igfSCFDecoder.cpp b/src/libIGFdec/src/FDK_igfSCFDecoder.cpp
index d65804c..dc1bb97 100644
--- a/src/libIGFdec/src/FDK_igfSCFDecoder.cpp
+++ b/src/libIGFdec/src/FDK_igfSCFDecoder.cpp
@@ -111,7 +111,7 @@ void iisIGFSCFDecLibInit(IGFSCFDEC_PRIVATE_DATA* hPrivateData, INT scfCountLongB
     scfCountTCX = scfCountShortBlock;
   }
 
-  FDKmemclear(hPrivateData, size);
+  mpegh_FDKmemclear(hPrivateData, size);
 
   /* init ptrs to qBuffers, this avoids allocating each buffer seperate: */
   hPrivateData->prevLB = &hPrivateData->prevBuffer[0];
@@ -557,10 +557,10 @@ void iisIGFSCFDecoderReset(
                                             no instance created */
 ) {
   /* reset of coder */
-  FDKmemset(hPrivateData->prevLB, 0, sizeof(SCHAR) * hPrivateData->scfCountLongBlock);
-  FDKmemset(hPrivateData->prevSB, 0, sizeof(SCHAR) * hPrivateData->scfCountShortBlock);
-  FDKmemset(hPrivateData->prevTCXmedium, 0, sizeof(SCHAR) * hPrivateData->scfCountTCXBlock);
-  FDKmemset(hPrivateData->prevTCXlong, 0, sizeof(SCHAR) * hPrivateData->scfCountTCXBlock);
+  mpegh_FDKmemset(hPrivateData->prevLB, 0, sizeof(SCHAR) * hPrivateData->scfCountLongBlock);
+  mpegh_FDKmemset(hPrivateData->prevSB, 0, sizeof(SCHAR) * hPrivateData->scfCountShortBlock);
+  mpegh_FDKmemset(hPrivateData->prevTCXmedium, 0, sizeof(SCHAR) * hPrivateData->scfCountTCXBlock);
+  mpegh_FDKmemset(hPrivateData->prevTCXlong, 0, sizeof(SCHAR) * hPrivateData->scfCountTCXBlock);
   hPrivateData->t = 0;
   hPrivateData->prevDLB = 0;
   hPrivateData->prevDSB = 0;
@@ -602,7 +602,7 @@ void iisIGFSCFDecoderDecode(
                         sfeReducePrecisionEnabled);
       /* advancing history: */
       hPrivateData->prevDLB = hPrivateData->prevLB[0];
-      FDKmemmove(hPrivateData->prevLB, sfe, sizeof(SCHAR) * hPrivateData->scfCountLongBlock);
+      mpegh_FDKmemmove(hPrivateData->prevLB, sfe, sizeof(SCHAR) * hPrivateData->scfCountLongBlock);
 
       if (sfeReducePrecisionEnabled) {
         INT tt;
@@ -640,7 +640,7 @@ void iisIGFSCFDecoderDecode(
                           sfeReducePrecisionEnabled);
         /* advancing history: */
         hPrivateData->prevDSB = hPrivateData->prevSB[0];
-        FDKmemmove(hPrivateData->prevSB, sfe, sizeof(SCHAR) * hPrivateData->scfCountShortBlock);
+        mpegh_FDKmemmove(hPrivateData->prevSB, sfe, sizeof(SCHAR) * hPrivateData->scfCountShortBlock);
 
         if (sfeReducePrecisionEnabled) {
           INT tt;
diff --git a/src/libIGFdec/src/arm/FDK_igfDec_arm.cpp b/src/libIGFdec/src/arm/FDK_igfDec_arm.cpp
index efc78e8..5690b0a 100644
--- a/src/libIGFdec/src/arm/FDK_igfDec_arm.cpp
+++ b/src/libIGFdec/src/arm/FDK_igfDec_arm.cpp
@@ -636,7 +636,7 @@ void iisIGFDecLibInjectSourceSpectrumTCX_func2(
 #ifdef FUNCTION_DotProduct_func1
 FDK_ASM_ROUTINE_START(FIXP_DBL, DotProduct_func1,
  (  const FIXP_DBL *Input,   /* r0: Input   */
-    INT shift,               /* r1: shift=getScalefactor(Input,length)   */
+    INT shift,               /* r1: shift=mpegh_getScalefactor(Input,length)   */
     INT loop_shift,          /* r1: loop_shift */
     INT length))             /* r2: length  */
 
diff --git a/src/libMpegTPDec/src/tpdec_asc.cpp b/src/libMpegTPDec/src/tpdec_asc.cpp
index 3ff8260..b2e821e 100644
--- a/src/libMpegTPDec/src/tpdec_asc.cpp
+++ b/src/libMpegTPDec/src/tpdec_asc.cpp
@@ -102,7 +102,7 @@ void CProgramConfig_Reset(CProgramConfig* pPce) {
 }
 
 void CProgramConfig_Init(CProgramConfig* pPce) {
-  FDKmemclear(pPce, sizeof(CProgramConfig));
+  mpegh_FDKmemclear(pPce, sizeof(CProgramConfig));
 }
 
 int CProgramConfig_IsValid(const CProgramConfig* pPce) {
@@ -980,7 +980,7 @@ static TRANSPORTDEC_ERROR MpegHConfig_Parse(CSAudioSpecificConfig* asc, AUDIO_SC
  */
 
 void AudioSpecificConfig_Init(CSAudioSpecificConfig* asc) {
-  FDKmemclear(asc, sizeof(CSAudioSpecificConfig));
+  mpegh_FDKmemclear(asc, sizeof(CSAudioSpecificConfig));
 
   /* Init all values that should not be zero. */
   asc->m_aot = AOT_NONE;
diff --git a/src/libMpegTPDec/src/tpdec_asi.cpp b/src/libMpegTPDec/src/tpdec_asi.cpp
index 0221bd1..327b09c 100644
--- a/src/libMpegTPDec/src/tpdec_asi.cpp
+++ b/src/libMpegTPDec/src/tpdec_asi.cpp
@@ -186,17 +186,17 @@ void asiReset(AUDIO_SCENE_INFO* asi) {
   ASI_DESCRIPTIONS* pDescriptions_old = asi->pDescriptions;
 
   for (i = 0; i < ASI_MAX_PREF_DESCR_LANGUAGES; i++) {
-    FDKstrncpy(prefDescrLanguages_old[i], asi->prefDescrLanguages[i], 3);
+    mpegh_FDKstrncpy(prefDescrLanguages_old[i], asi->prefDescrLanguages[i], 3);
   }
 
-  FDKmemclear(asi, sizeof(AUDIO_SCENE_INFO));
+  mpegh_FDKmemclear(asi, sizeof(AUDIO_SCENE_INFO));
 
-  if (pDescriptions_old) FDKmemclear(pDescriptions_old, sizeof(ASI_DESCRIPTIONS));
+  if (pDescriptions_old) mpegh_FDKmemclear(pDescriptions_old, sizeof(ASI_DESCRIPTIONS));
   asi->pDescriptions = pDescriptions_old;
 
   asi->activeDmxId = activeDmxId_old;
   for (i = 0; i < ASI_MAX_PREF_DESCR_LANGUAGES; i++) {
-    FDKstrncpy(asi->prefDescrLanguages[i], prefDescrLanguages_old[i], 3);
+    mpegh_FDKstrncpy(asi->prefDescrLanguages[i], prefDescrLanguages_old[i], 3);
   }
   for (i = 0; i < TPDEC_MAX_TRACKS; i++) {
     asi->metaDataElementIDmaxAvail[i] = -1;
@@ -604,7 +604,7 @@ void asiMapISO639_2_T2B_and_tolower(char* buf) {
   for (int i = 0; i < NUM_SPECIAL_LANG_CODES; i++) {
     if ((buf[0] == langCodes[i][1][0]) && (buf[1] == langCodes[i][1][1]) &&
         (buf[2] == langCodes[i][1][2])) {
-      FDKmemcpy(buf, langCodes[i][0], 3);
+      mpegh_FDKmemcpy(buf, langCodes[i][0], 3);
       return;
     }
   }
@@ -661,10 +661,10 @@ static TRANSPORTDEC_ERROR mae_Description(int type, AUDIO_SCENE_INFO* asi,
       for (currPrio = 0; currPrio < ASI_MAX_PREF_DESCR_LANGUAGES; currPrio++) {
 #ifndef ASI_MAX_DESCRIPTION_LANGUAGES
         if (descr->language[0] &&
-            (FDKstrncmp(descr->language, asi->prefDescrLanguages[currPrio], 3) == 0)) {
+            (mpegh_FDKstrncmp(descr->language, asi->prefDescrLanguages[currPrio], 3) == 0)) {
 #else
         if (descr->language[descr->prefLangIdx][0] &&
-            (FDKstrncmp(descr->language[descr->prefLangIdx], asi->prefDescrLanguages[currPrio],
+            (mpegh_FDKstrncmp(descr->language[descr->prefLangIdx], asi->prefDescrLanguages[currPrio],
                         3) == 0)) {
 #endif
           break;
@@ -692,7 +692,7 @@ static TRANSPORTDEC_ERROR mae_Description(int type, AUDIO_SCENE_INFO* asi,
       /* get priority of language */
       if (descr) {
         for (prio = 0; prio < ASI_MAX_PREF_DESCR_LANGUAGES; prio++) {
-          if (language[0] && (FDKstrncmp(language, asi->prefDescrLanguages[prio], 3) == 0)) {
+          if (language[0] && (mpegh_FDKstrncmp(language, asi->prefDescrLanguages[prio], 3) == 0)) {
             break;
           }
         }
@@ -700,10 +700,10 @@ static TRANSPORTDEC_ERROR mae_Description(int type, AUDIO_SCENE_INFO* asi,
           prio += i; /* if not in preferred list select first transmitted */
         if (prio == ASI_MAX_PREF_DESCR_LANGUAGES) {
 #ifndef ASI_MAX_DESCRIPTION_LANGUAGES
-          if (descr && descr->present && (FDKstrncmp(language, descr->language, 3) != 0)) {
+          if (descr && descr->present && (mpegh_FDKstrncmp(language, descr->language, 3) != 0)) {
 #else
           if (descr && descr->present &&
-              (FDKstrncmp(language, descr->language[descr->prefLangIdx], 3) != 0)) {
+              (mpegh_FDKstrncmp(language, descr->language[descr->prefLangIdx], 3) != 0)) {
 #endif
             prio++;
           }
diff --git a/src/libMpegTPDec/src/tpdec_lib.cpp b/src/libMpegTPDec/src/tpdec_lib.cpp
index 2d75cea..abf9ecc 100644
--- a/src/libMpegTPDec/src/tpdec_lib.cpp
+++ b/src/libMpegTPDec/src/tpdec_lib.cpp
@@ -234,7 +234,7 @@ TRANSPORTDEC_ERROR transportDec_OutOfBandConfig(HANDLE_TRANSPORTDEC hTp, UCHAR*
   if (length > 1024) {
     return TRANSPORTDEC_UNSUPPORTED_FORMAT;
   }
-  FDKmemcpy(tmpConf, conf, length);
+  mpegh_FDKmemcpy(tmpConf, conf, length);
   FDKinitBitStream(hBs, tmpConf, 1024, length << 3, BS_READER);
 
   for (i = 0; i < 2; i++) {
@@ -263,13 +263,13 @@ TRANSPORTDEC_ERROR transportDec_OutOfBandConfig(HANDLE_TRANSPORTDEC hTp, UCHAR*
         }
 
         if (configMode & AC_CM_DET_CFG_CHANGE) {
-          if (FDKmemcmp(hTp->ctrlCFGChange[layer].Mpegh3daConfig, conf, length) != 0) {
+          if (mpegh_FDKmemcmp(hTp->ctrlCFGChange[layer].Mpegh3daConfig, conf, length) != 0) {
             hTp->asc[layer].AacConfigChanged |= 1;
           }
         }
 
         hTp->ctrlCFGChange[layer].Mpegh3daConfigLen = length;
-        FDKmemcpy(hTp->ctrlCFGChange[layer].Mpegh3daConfig, conf, length);
+        mpegh_FDKmemcpy(hTp->ctrlCFGChange[layer].Mpegh3daConfig, conf, length);
         break;
       default:
         err = TRANSPORTDEC_UNSUPPORTED_FORMAT;
@@ -326,7 +326,7 @@ TRANSPORTDEC_ERROR transportDec_InBandConfig(HANDLE_TRANSPORTDEC hTp, UCHAR* new
         }
         if (hTp->ctrlCFGChange[layer].Mpegh3daConfigLen == newConfigLength) {
           if (0 ==
-              FDKmemcmp(newConfig, hTp->ctrlCFGChange[layer].Mpegh3daConfig, newConfigLength)) {
+              mpegh_FDKmemcmp(newConfig, hTp->ctrlCFGChange[layer].Mpegh3daConfig, newConfigLength)) {
             *configChanged = 0;
             return err;
           }
@@ -448,7 +448,7 @@ TRANSPORTDEC_ERROR transportDec_InBandConfig(HANDLE_TRANSPORTDEC hTp, UCHAR* new
     if (err == TRANSPORTDEC_OK) {
       if (hTp->asc->m_aot == AOT_MPEGH3DA) {
         hTp->ctrlCFGChange[layer].Mpegh3daConfigLen = newConfigLength;
-        FDKmemcpy(hTp->ctrlCFGChange[layer].Mpegh3daConfig, newConfig, newConfigLength);
+        mpegh_FDKmemcpy(hTp->ctrlCFGChange[layer].Mpegh3daConfig, newConfig, newConfigLength);
       }
     } else {
       hTp->numberOfRawDataBlocks = 0;
@@ -1606,7 +1606,7 @@ static TRANSPORTDEC_ERROR synchronization(HANDLE_TRANSPORTDEC hTp, INT* pHeaderB
           rawDataBlockLengthFirstFrame = rawDataBlockLength;
           headerBitsFirstFrame = headerBits;
           errFirstFrame = err;
-          FDKmemcpy(contextFirstFrame, &hTp->parser, sizeof(transportdec_parser_t));
+          mpegh_FDKmemcpy(contextFirstFrame, &hTp->parser, sizeof(transportdec_parser_t));
         }
 
         /* Break when config was found or it is not possible anymore to find a config */
@@ -1635,7 +1635,7 @@ static TRANSPORTDEC_ERROR synchronization(HANDLE_TRANSPORTDEC hTp, INT* pHeaderB
   /* Restore context in case of ECD frame traversal */
   if (startPosFirstFrame != -1 && (fConfigFound || err != TRANSPORTDEC_OK)) {
     FDKpushBiDirectional(hBs, FDKgetValidBits(hBs) - startPosFirstFrame);
-    FDKmemcpy(&hTp->parser, contextFirstFrame, sizeof(transportdec_parser_t));
+    mpegh_FDKmemcpy(&hTp->parser, contextFirstFrame, sizeof(transportdec_parser_t));
     hTp->numberOfRawDataBlocks = numRawDataBlocksFirstFrame;
     hTp->globalFramePos = globalFramePosFirstFrame;
     rawDataBlockLength = rawDataBlockLengthFirstFrame;
diff --git a/src/libMpeghDec/src/FDK_delay.cpp b/src/libMpeghDec/src/FDK_delay.cpp
index 7d7ca08..2c2da2d 100644
--- a/src/libMpeghDec/src/FDK_delay.cpp
+++ b/src/libMpeghDec/src/FDK_delay.cpp
@@ -99,7 +99,7 @@ INT FDK_Delay_Create(FDK_SignalDelay* data, const USHORT delay, const UCHAR num_
   FDK_ASSERT(num_channels > 0);
 
   if (delay > 0) {
-    data->delay_line = (PCM_DEC*)FDKcalloc(num_channels * delay, sizeof(PCM_DEC));
+    data->delay_line = (PCM_DEC*)mpegh_FDKcalloc(num_channels * delay, sizeof(PCM_DEC));
     if (data->delay_line == NULL) {
       return -1;
     }
@@ -114,7 +114,7 @@ INT FDK_Delay_Create(FDK_SignalDelay* data, const USHORT delay, const UCHAR num_
 
 void FDK_Delay_Destroy(FDK_SignalDelay* data) {
   if (data->delay_line != NULL) {
-    FDKfree(data->delay_line);
+    mpegh_FDKfree(data->delay_line);
   }
   data->delay_line = NULL;
   data->delay = 0;
diff --git a/src/libMpeghDec/src/aacdec_tns.cpp b/src/libMpeghDec/src/aacdec_tns.cpp
index cd7aacb..2873bab 100644
--- a/src/libMpeghDec/src/aacdec_tns.cpp
+++ b/src/libMpeghDec/src/aacdec_tns.cpp
@@ -107,9 +107,9 @@ amm-info@iis.fraunhofer.de
   \return  none
 */
 void CTns_Reset(CTnsData* pTnsData) {
-  /* Note: the following FDKmemclear should not be required. */
-  FDKmemclear(pTnsData->Filter, TNS_MAX_WINDOWS * TNS_MAXIMUM_FILTERS * sizeof(CFilter));
-  FDKmemclear(pTnsData->NumberOfFilters, TNS_MAX_WINDOWS * sizeof(UCHAR));
+  /* Note: the following mpegh_FDKmemclear should not be required. */
+  mpegh_FDKmemclear(pTnsData->Filter, TNS_MAX_WINDOWS * TNS_MAXIMUM_FILTERS * sizeof(CFilter));
+  mpegh_FDKmemclear(pTnsData->NumberOfFilters, TNS_MAX_WINDOWS * sizeof(UCHAR));
   pTnsData->DataPresent = 0;
   pTnsData->Active = 0;
 }
@@ -338,13 +338,13 @@ void CTns_Apply(CTnsData* RESTRICT pTnsData, /*!< pointer to aac decoder info */
           if (size) {
             C_ALLOC_SCRATCH_START(state, FIXP_DBL, TNS_MAXIMUM_ORDER)
 
-            FDKmemclear(state, TNS_MAXIMUM_ORDER * sizeof(FIXP_DBL));
+            mpegh_FDKmemclear(state, TNS_MAXIMUM_ORDER * sizeof(FIXP_DBL));
 #ifdef LPC_SYNTHESIS_IIR
             lpcCoeff_e = CLpc_ParcorToLpc(coeff, lpcCoeff_m, filter->Order, temp);
             CLpc_Synthesis(pSpectrum + start, size, filter->Direction, lpcCoeff_m, lpcCoeff_e,
                            filter->Order, state, &synStateIndex);
 #else
-            CLpc_SynthesisLattice(pSpectrum + start, size, 0, 0, filter->Direction, coeff,
+            mpegh_CLpc_SynthesisLattice(pSpectrum + start, size, 0, 0, filter->Direction, coeff,
                                   filter->Order, state);
 #endif
 
diff --git a/src/libMpeghDec/src/aacdecoder.cpp b/src/libMpeghDec/src/aacdecoder.cpp
index b51b482..df4980b 100644
--- a/src/libMpeghDec/src/aacdecoder.cpp
+++ b/src/libMpeghDec/src/aacdecoder.cpp
@@ -723,7 +723,7 @@ static AAC_DECODER_ERROR CAacDecoder_InitRenderer(HANDLE_AACDECODER self, const
           goto bail;
         }
 
-        FDKmemclear(outGeo, sizeof(outGeo));
+        mpegh_FDKmemclear(outGeo, sizeof(outGeo));
         cicpErr = cicp2geometry_get_geometry_from_cicp(cicpIndexOut, outGeo, &chan, &lfe);
         if (cicpErr) {
           err = AAC_DEC_UNSUPPORTED_CHANNELCONFIG;
@@ -1011,7 +1011,7 @@ static void CAacDecoder_DeInit(HANDLE_AACDECODER self, const int subStreamIndex)
   for (ch = aacChannelOffset; ch < aacChannelOffset + aacChannels; ch++) {
     if (self->pAacDecoderChannelInfo[ch] != NULL) {
       if (self->pAacDecoderChannelInfo[ch]->pDynData != NULL) {
-        FDKfree(self->pAacDecoderChannelInfo[ch]->pDynData);
+        mpegh_FDKfree(self->pAacDecoderChannelInfo[ch]->pDynData);
       }
       if (self->pAacDecoderChannelInfo[ch]->pComStaticData != NULL) {
         if (self->pAacDecoderChannelInfo[ch]->pComStaticData->pWorkBufferCore1 != NULL) {
@@ -1032,12 +1032,12 @@ static void CAacDecoder_DeInit(HANDLE_AACDECODER self, const int subStreamIndex)
             self->pAacDecoderChannelInfo[ch + 1]->pComStaticData = NULL;
           }
         }
-        FDKfree(self->pAacDecoderChannelInfo[ch]->pComStaticData);
+        mpegh_FDKfree(self->pAacDecoderChannelInfo[ch]->pComStaticData);
         self->pAacDecoderChannelInfo[ch]->pComStaticData = NULL;
       }
       if (self->pAacDecoderChannelInfo[ch]->pComData != NULL) {
         if (self->pAacDecoderChannelInfo[ch]->pComData->pJointStereoData != NULL) {
-          FDKfree(self->pAacDecoderChannelInfo[ch]->pComData->pJointStereoData);
+          mpegh_FDKfree(self->pAacDecoderChannelInfo[ch]->pComData->pJointStereoData);
         }
         /* Avoid double free of linked pComData in case of CPE by settings pointer to NULL. */
         if (ch < (28) - 1) {
@@ -1050,7 +1050,7 @@ static void CAacDecoder_DeInit(HANDLE_AACDECODER self, const int subStreamIndex)
         if (ch == aacChannelOffset) {
           FreeWorkBufferCore6((FIXP_DBL**)&self->pAacDecoderChannelInfo[ch]->pComData);
         } else {
-          FDKafree(self->pAacDecoderChannelInfo[ch]->pComData);
+          mpegh_FDKafree(self->pAacDecoderChannelInfo[ch]->pComData);
         }
         self->pAacDecoderChannelInfo[ch]->pComData = NULL;
       }
@@ -1131,7 +1131,7 @@ static void CAacDecoder_AcceptFlags(HANDLE_AACDECODER self, const CSAudioSpecifi
       self->elFlags[el] = elFlags[el];
     }
   } else {
-    FDKmemcpy(self->elFlags, elFlags,
+    mpegh_FDKmemcpy(self->elFlags, elFlags,
               sizeof(*elFlags) * (3 * ((28) * 2) + (((28) * 2)) / 2 + 4 * (1) + 1));
   }
 
@@ -1365,7 +1365,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_Init(HANDLE_AACDECODER self,
       elFlags[el] = 0;
     }
   } else {
-    FDKmemclear(elFlags, sizeof(elFlags));
+    mpegh_FDKmemclear(elFlags, sizeof(elFlags));
   }
 
   if ((asc->m_channelConfiguration > 0) || (asc->m_aot == AOT_MPEGH3DA) ||
@@ -1595,7 +1595,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_Init(HANDLE_AACDECODER self,
           goto bail;
         }
         self->pAacDecoderChannelInfo[ch]->pDynData =
-            (CAacDecoderDynamicData*)FDKmalloc(sizeof(CAacDecoderDynamicData));
+            (CAacDecoderDynamicData*)mpegh_FDKmalloc(sizeof(CAacDecoderDynamicData));
         if (self->pAacDecoderChannelInfo[ch]->pDynData == NULL) {
           goto bail;
         }
@@ -1639,7 +1639,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_Init(HANDLE_AACDECODER self,
                 goto bail;
               }
               self->pAacDecoderChannelInfo[ch]->pComStaticData =
-                  (CAacDecoderCommonStaticData*)FDKcalloc(1, sizeof(CAacDecoderCommonStaticData));
+                  (CAacDecoderCommonStaticData*)mpegh_FDKcalloc(1, sizeof(CAacDecoderCommonStaticData));
               if (self->pAacDecoderChannelInfo[ch]->pComStaticData == NULL) {
                 goto bail;
               }
@@ -1649,7 +1649,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_Init(HANDLE_AACDECODER self,
                 self->pAacDecoderChannelInfo[ch]->pComStaticData->pWorkBufferCore1 =
                     GetWorkBufferCore1();
               } else {
-                self->pAacDecoderChannelInfo[ch]->pComData = (CAacDecoderCommonData*)FDKaalloc(
+                self->pAacDecoderChannelInfo[ch]->pComData = (CAacDecoderCommonData*)mpegh_FDKaalloc(
                     sizeof(CAacDecoderCommonData), ALIGNMENT_DEFAULT);
                 self->pAacDecoderChannelInfo[ch]->pComStaticData->pWorkBufferCore1 =
                     self->pAacDecoderChannelInfo[aacChannelsOffset]
@@ -1661,7 +1661,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_Init(HANDLE_AACDECODER self,
               }
               if (el_channels == 2) {
                 self->pAacDecoderChannelInfo[ch]->pComData->pJointStereoData =
-                    (CJointStereoData*)FDKmalloc(sizeof(CJointStereoData));
+                    (CJointStereoData*)mpegh_FDKmalloc(sizeof(CJointStereoData));
                 if (self->pAacDecoderChannelInfo[ch]->pComData->pJointStereoData == NULL) {
                   goto bail;
                 }
@@ -1887,7 +1887,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_Init(HANDLE_AACDECODER self,
       self->pAacDecoderChannelInfo[ch]->granuleLength = self->streamInfo.aacSamplesPerFrame / 8;
       self->pAacDecoderChannelInfo[ch]->renderMode = initRenderMode;
 
-      mdct_init(&self->pAacDecoderStaticChannelInfo[ch]->IMdct,
+      mpegh_mdct_init(&self->pAacDecoderStaticChannelInfo[ch]->IMdct,
                 self->pAacDecoderStaticChannelInfo[ch]->pOverlapBuffer, OverlapBufferSize);
 
       /* Reset concealment only if ASC changed. Otherwise it will be done with any config callback.
@@ -2098,7 +2098,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_DecodeFrame(HANDLE_AACDECODER self, c
           &self->pAacDecoderStaticChannelInfo[ch]->concealmentInfo, &self->concealCommonData,
           self->pAacDecoderChannelInfo[0]->renderMode, self->streamInfo.aacSamplesPerFrame);
       /* Clear overlap-add buffers to avoid clicks. */
-      FDKmemclear(self->pAacDecoderStaticChannelInfo[ch]->pOverlapBuffer,
+      mpegh_FDKmemclear(self->pAacDecoderStaticChannelInfo[ch]->pOverlapBuffer,
                   OverlapBufferSize * sizeof(FIXP_DBL));
     }
     if (self->streamInfo.channelConfig > 0) {
@@ -2118,7 +2118,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_DecodeFrame(HANDLE_AACDECODER self, c
 
   if (self->flags[streamIndex] & AC_MPEGH3DA) {
     /* Clear the MCT element flags */
-    FDKmemclear(MCT_elFlags, sizeof(UINT) * (3 * ((28) * 2) + (((28) * 2)) / 2 + 4 * (1) + 1));
+    mpegh_FDKmemclear(MCT_elFlags, sizeof(UINT) * (3 * ((28) * 2) + (((28) * 2)) / 2 + 4 * (1) + 1));
     /* Assign a pointer to MCT_elFlags array*/
     p2_MCT_elFlags = MCT_elFlags;
   }
@@ -2740,16 +2740,16 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_DecodeFrame(HANDLE_AACDECODER self, c
     aacChannels = self->aacChannelsPrev;
     /* Because the downmix could be active, its necessary to restore the channel type and indices.
      */
-    FDKmemcpy(self->channelType, self->channelTypePrev,
+    mpegh_FDKmemcpy(self->channelType, self->channelTypePrev,
               (28) * sizeof(AUDIO_CHANNEL_TYPE));                                    /* restore */
-    FDKmemcpy(self->channelIndices, self->channelIndicesPrev, (28) * sizeof(UCHAR)); /* restore */
+    mpegh_FDKmemcpy(self->channelIndices, self->channelIndicesPrev, (28) * sizeof(UCHAR)); /* restore */
   } else {
     /* store or restore the number of channels and the corresponding info */
     if (self->frameOK && !(flags & AACDEC_CONCEAL)) {
       self->aacChannelsPrev = aacChannels; /* store */
-      FDKmemcpy(self->channelTypePrev, self->channelType,
+      mpegh_FDKmemcpy(self->channelTypePrev, self->channelType,
                 (28) * sizeof(AUDIO_CHANNEL_TYPE));                                    /* store */
-      FDKmemcpy(self->channelIndicesPrev, self->channelIndices, (28) * sizeof(UCHAR)); /* store */
+      mpegh_FDKmemcpy(self->channelIndicesPrev, self->channelIndices, (28) * sizeof(UCHAR)); /* store */
     } else {
       if (self->aacChannels > 0) {
         if ((self->buildUpStatus == AACDEC_MPEGH_BUILD_UP_ON) ||
@@ -2760,9 +2760,9 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_DecodeFrame(HANDLE_AACDECODER self, c
         } else {
           aacChannels = self->aacChannelsPrev; /* restore */
         }
-        FDKmemcpy(self->channelType, self->channelTypePrev,
+        mpegh_FDKmemcpy(self->channelType, self->channelTypePrev,
                   (28) * sizeof(AUDIO_CHANNEL_TYPE)); /* restore */
-        FDKmemcpy(self->channelIndices, self->channelIndicesPrev,
+        mpegh_FDKmemcpy(self->channelIndices, self->channelIndicesPrev,
                   (28) * sizeof(UCHAR)); /* restore */
       }
     }
@@ -2867,7 +2867,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_DecodeFrame(HANDLE_AACDECODER self, c
           /* Clear audio data for sub streams which are currently not available. */
           if (transportDec_GetAuBitsTotal(self->hInput, streamIndex) <= 0 &&
               !(flags & (AACDEC_FLUSH | AACDEC_CONCEAL))) {
-            FDKmemclear(pTimeData + offset, sizeof(PCM_DEC) * self->streamInfo.aacSamplesPerFrame);
+            mpegh_FDKmemclear(pTimeData + offset, sizeof(PCM_DEC) * self->streamInfo.aacSamplesPerFrame);
             continue;
           }
         }
@@ -2875,7 +2875,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_DecodeFrame(HANDLE_AACDECODER self, c
         if (flags & AACDEC_FLUSH) {
           /* Clear pAacDecoderChannelInfo->pSpectralCoefficient because with AACDEC_FLUSH set it
            * contains undefined data. */
-          FDKmemclear(pAacDecoderChannelInfo->pSpectralCoefficient,
+          mpegh_FDKmemclear(pAacDecoderChannelInfo->pSpectralCoefficient,
                       sizeof(FIXP_DBL) * self->streamInfo.aacSamplesPerFrame);
         }
 
@@ -2921,7 +2921,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecoder_DecodeFrame(HANDLE_AACDECODER self, c
           break;
         }
         if (self->flushStatus && (self->flushCnt > 0) && !(flags & AACDEC_CONCEAL)) {
-          FDKmemclear(pTimeData + offset, sizeof(PCM_DEC) * self->streamInfo.aacSamplesPerFrame);
+          mpegh_FDKmemclear(pTimeData + offset, sizeof(PCM_DEC) * self->streamInfo.aacSamplesPerFrame);
         } else
           switch (pAacDecoderChannelInfo->renderMode) {
             case AACDEC_RENDER_IMDCT:
@@ -3333,7 +3333,7 @@ TRANSPORTDEC_ERROR PcmDataPayload(EarconDecoder* earconDecoder, FIXP_DBL* TimeDa
         earconDecoder->AccumulatedFrameSize = 0;
       }
       FDK_ASSERT((earconDecoder->AccumulatedFrameSize + OverallSamplesUsed) <= EARCON_BUFFER_SIZE);
-      FDKmemmove(&earconDecoder->EarconData[0], &earconDecoder->EarconData[OverallSamplesUsed],
+      mpegh_FDKmemmove(&earconDecoder->EarconData[0], &earconDecoder->EarconData[OverallSamplesUsed],
                  sizeof(FIXP_SGL) * earconDecoder->AccumulatedFrameSize);
       earconDecoder->numPcmSignals_old = numSpeakers;
 
diff --git a/src/libMpeghDec/src/aacdecoder_lib.cpp b/src/libMpeghDec/src/aacdecoder_lib.cpp
index 9008298..39404ee 100644
--- a/src/libMpeghDec/src/aacdecoder_lib.cpp
+++ b/src/libMpeghDec/src/aacdecoder_lib.cpp
@@ -327,9 +327,9 @@ static INT aacDecoder_TruncationMsgCallback(void* handle, INT nTruncSamples, INT
     /* The truncation segment list is required to be ordered. Reorder in case required. */
     if (q < (TRUNC_QUEUE_SIZE - 1) &&
         (self->truncateStartOffset[q + 1] > 0 || self->truncateStopOffset[q + 1] > 0)) {
-      FDKmemmove(self->truncateStartOffset + q, self->truncateStartOffset + q + 1,
+      mpegh_FDKmemmove(self->truncateStartOffset + q, self->truncateStartOffset + q + 1,
                  sizeof(SHORT) * (TRUNC_QUEUE_SIZE - q - 1));
-      FDKmemmove(self->truncateStopOffset + q, self->truncateStopOffset + q + 1,
+      mpegh_FDKmemmove(self->truncateStopOffset + q, self->truncateStopOffset + q + 1,
                  sizeof(SHORT) * (TRUNC_QUEUE_SIZE - q - 1));
       self->truncateStartOffset[TRUNC_QUEUE_SIZE - 1] = -128;
       self->truncateStopOffset[TRUNC_QUEUE_SIZE - 1] = -128;
@@ -430,7 +430,7 @@ static INT aacDecoder_ParseDmxMatrixCallback(void* handle, HANDLE_FDK_BITSTREAM
    * CAacDecoder_InitRenderer() */
   FDK_DOWNMIX_GROUPS_MATRIX_SET* groupsDownmixMatrixSet =
       (FDK_DOWNMIX_GROUPS_MATRIX_SET*)hAacDecoder->pTimeData2;
-  FDKmemclear(groupsDownmixMatrixSet, sizeof(FDK_DOWNMIX_GROUPS_MATRIX_SET));
+  mpegh_FDKmemclear(groupsDownmixMatrixSet, sizeof(FDK_DOWNMIX_GROUPS_MATRIX_SET));
 
   err = DownmixMatrixSet(hBs, groupsDownmixMatrixSet, targetLayout, downmixConfigType,
                          &(hAacDecoder->downmixId), hUniDrcDecoder);
@@ -584,7 +584,7 @@ static INT aacDecoder_EarconSetBSCallback(void* handle, HANDLE_FDK_BITSTREAM bs)
       return 0;
     }
     if (diff) {
-      FDKmemclear(EarconDataPointer, sizeof(FIXP_SGL) * diff * numPcmSignalsInFrame);
+      mpegh_FDKmemclear(EarconDataPointer, sizeof(FIXP_SGL) * diff * numPcmSignalsInFrame);
     }
 
     /*Increase the accumulated frame size*/
@@ -607,7 +607,7 @@ static INT aacDecoder_EarconSetBSCallback(void* handle, HANDLE_FDK_BITSTREAM bs)
       return 0;
     }
     FIXP_SGL* EarconDataPointer = &hAacDecoder->earconDecoder.EarconData[WriteIndex];
-    FDKmemclear(EarconDataPointer, sizeof(FIXP_SGL) * FillSize);
+    mpegh_FDKmemclear(EarconDataPointer, sizeof(FIXP_SGL) * FillSize);
 
     /*Increase the accumulated frame size*/
     hAacDecoder->earconDecoder.AccumulatedFrameSize += FillSize;
@@ -1473,7 +1473,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
               for (ch = 0; ch < transportNumChannels; ch++) {
                 STFT_headroom =
                     fMin(STFT_headroom,
-                         getScalefactor(&(pTimeData2[(transportStartChannel + ch) *
+                         mpegh_getScalefactor(&(pTimeData2[(transportStartChannel + ch) *
                                                          (self->streamInfo.frameSize + 256) +
                                                      i * self->stftFrameSize + 256]),
                                         self->stftFrameSize));
@@ -1504,7 +1504,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
 
                 /* clear output buffer first, as StftFilterbank_Process accumulates its output
                  * signal to the buffer */
-                FDKmemclear(
+                mpegh_FDKmemclear(
                     &(pTimeData2[(transportStartChannel + ch) * (self->streamInfo.frameSize + 256) +
                                  i * self->stftFrameSize + 256]),
                     self->stftFrameSize * sizeof(FIXP_DBL));
@@ -1526,10 +1526,10 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
           /* Compensate STFT delay in object and HOA signal path in case of time domain DRC. */
           if (processTimeDomainDrc) {
             for (int ch = 0; ch < transportNumChannels; ch++) {
-              FDKmemcpy(
+              mpegh_FDKmemcpy(
                   pTimeData2 + (transportStartChannel + ch) * (self->streamInfo.frameSize + 256),
                   self->delayBuffer[transportStartChannel + ch], sizeof(PCM_DEC) * 256);
-              FDKmemcpy(self->delayBuffer[transportStartChannel + ch],
+              mpegh_FDKmemcpy(self->delayBuffer[transportStartChannel + ch],
                         pTimeData2 +
                             (transportStartChannel + ch) * (self->streamInfo.frameSize + 256) +
                             self->streamInfo.frameSize,
@@ -1550,7 +1550,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
 
       /* Clear output buffer, were each renderer will mix its output into. */
       if ((self->flags[0] & AC_MPEGH3DA) && (self->targetLayout_config > -1)) {
-        FDKmemclear(self->workBufferCore2, (self->streamInfo.numChannels) *
+        mpegh_FDKmemclear(self->workBufferCore2, (self->streamInfo.numChannels) *
                                                (self->streamInfo.frameSize) * sizeof(FIXP_DBL));
       }
 
@@ -1675,7 +1675,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
 
         /* Copy delayed samples from delay buffer to time buffer */
         if (self->mpegH_rendered_delay.delay) {
-          FDKmemcpy(pTimeData2 + newFrameSize * ch,
+          mpegh_FDKmemcpy(pTimeData2 + newFrameSize * ch,
                     &self->mpegH_rendered_delay.delay_line[self->mpegH_rendered_delay.delay * ch],
                     self->mpegH_rendered_delay.delay * sizeof(FIXP_DBL));
         }
@@ -1688,7 +1688,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
 
         /* Copy hang over samples from the time buffer to the delay buffer */
         if (ovSamples) {
-          FDKmemcpy(&self->mpegH_rendered_delay.delay_line[self->mpegH_rendered_delay.delay * ch],
+          mpegh_FDKmemcpy(&self->mpegH_rendered_delay.delay_line[self->mpegH_rendered_delay.delay * ch],
                     pTimeData2 + newFrameSize * ch + newFrameSize, ovSamples * sizeof(FIXP_DBL));
         }
 
@@ -1781,7 +1781,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
             l = fMin(frameSizeRemaining, (INT)self->truncateStartOffset[q] + 128) - truncStart;
 
             for (ch = 0; ch < self->streamInfo.numChannels; ch++) {
-              FDKmemcpy(self->crossfadeMem + 128 * ch + truncStart - self->truncateStartOffset[q],
+              mpegh_FDKmemcpy(self->crossfadeMem + 128 * ch + truncStart - self->truncateStartOffset[q],
                         pTimeData2 + self->streamInfo.frameSize * ch + truncStart,
                         l * sizeof(PCM_DEC));
             }
@@ -1838,7 +1838,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
               if (truncStop < frameSizeRemaining) {
                 /* Truncate first samples [0..truncStop-1]: move remaining to start at 0 for each
                  * channel */
-                FDKmemmove(pTimeData2 + self->streamInfo.frameSize * ch,
+                mpegh_FDKmemmove(pTimeData2 + self->streamInfo.frameSize * ch,
                            pTimeData2 + self->streamInfo.frameSize * ch + truncStop,
                            truncateFrameSizeCurrent * sizeof(PCM_DEC));
               }
@@ -1887,7 +1887,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
     } else {
       {
         for (int ii = 0; ii < self->streamInfo.aacNumChannels; ii++) {
-          FDKmemmove(pTimeData3 + ii * (self->streamInfo.frameSize),
+          mpegh_FDKmemmove(pTimeData3 + ii * (self->streamInfo.frameSize),
                      pTimeData2 + ii * (self->streamInfo.aacSamplesPerFrame + 256) + 256,
                      self->streamInfo.frameSize * sizeof(PCM_AAC));
         }
@@ -1901,7 +1901,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
     if (!((self->flags[0] & AC_MPEGH3DA) && (self->targetLayout_config >= 0) &&
           (self->streamInfo.numChannels > 0))) {
       if ((INT)PCM_OUT_HEADROOM != timeDataHeadroom) {
-        scaleValues(pTimeData2, (PCM_DEC*)pTimeData3,
+        mpegh_scaleValues(pTimeData2, (PCM_DEC*)pTimeData3,
                     self->streamInfo.frameSize * self->streamInfo.numChannels,
                     -(PCM_OUT_HEADROOM - timeDataHeadroom));
       }
@@ -1991,7 +1991,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
 
     /* applyLimiter requests for interleaved data and doesn't support in-place processing */
     /* Interleave output buffer */
-    FDK_interleave(pTimeData2, pInterleaveBuffer, self->streamInfo.numChannels, blockLength,
+    MPEGH_interleave(pTimeData2, pInterleaveBuffer, self->streamInfo.numChannels, blockLength,
                    self->streamInfo.frameSize);
 
     if (truncateFrameSize != -1) {
@@ -2035,7 +2035,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
               self->discardSamplesAtStartCnt -= self->streamInfo.frameSize;
               self->streamInfo.frameSize = 0;
             } else {
-              FDKmemmove(pTimeData,
+              mpegh_FDKmemmove(pTimeData,
                          &pTimeData[self->discardSamplesAtStartCnt * self->streamInfo.numChannels],
                          (self->streamInfo.frameSize - self->discardSamplesAtStartCnt) *
                              self->streamInfo.numChannels * sizeof(INT_PCM));
@@ -2052,7 +2052,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecoder_DecodeFrame(HANDLE_AACDECODER self, IN
         self->streamInfo.outputDelay += pcmLimiter_GetDelay(self->hLimiter);
       }
     } else {
-      scaleValuesSaturate(pTimeData, (PCM_DEC*)pInterleaveBuffer,
+      mpegh_scaleValuesSaturate(pTimeData, (PCM_DEC*)pInterleaveBuffer,
                           self->streamInfo.frameSize * self->streamInfo.numChannels,
                           pcmLimiterScale);
     }
diff --git a/src/libMpeghDec/src/block.cpp b/src/libMpeghDec/src/block.cpp
index 9d2551e..738f03e 100644
--- a/src/libMpeghDec/src/block.cpp
+++ b/src/libMpeghDec/src/block.cpp
@@ -161,7 +161,7 @@ void CBlock_ScaleSpectralData(CAacDecoderChannelInfo* pAacDecoderChannelInfo, UC
       GetScaleFactorBandOffsets(&pAacDecoderChannelInfo->icsInfo, pSamplingRateInfo);
   SPECTRAL_PTR RESTRICT pSpectralCoefficient = pAacDecoderChannelInfo->pSpectralCoefficient;
 
-  FDKmemclear(pSpecScale, 8 * sizeof(SHORT));
+  mpegh_FDKmemclear(pSpecScale, 8 * sizeof(SHORT));
 
   for (window = 0, group = 0; group < GetWindowGroups(&pAacDecoderChannelInfo->icsInfo); group++) {
     for (groupwin = 0; groupwin < GetWindowGroupLength(&pAacDecoderChannelInfo->icsInfo, group);
@@ -207,7 +207,7 @@ void CBlock_ScaleSpectralData(CAacDecoderChannelInfo* pAacDecoderChannelInfo, UC
             SpecScale_window_tns + pAacDecoderChannelInfo->pDynData->TnsData.GainLd;
         FDK_ASSERT(tns_stop >= tns_start);
         /* Consider existing headroom of all MDCT lines inside the TNS bands. */
-        SpecScale_window_tns -= getScalefactor(pSpectrum + BandOffsets[tns_start],
+        SpecScale_window_tns -= mpegh_getScalefactor(pSpectrum + BandOffsets[tns_start],
                                                BandOffsets[tns_stop] - BandOffsets[tns_start]);
         if (SpecScale_window <= 17) {
           SpecScale_window_tns++;
@@ -317,7 +317,7 @@ void CBlock_ScaleTileData(CAacDecoderStaticChannelInfo* pAacDecoderStaticChannel
               SpecScale_window_tns + pAacDecoderChannelInfo->pDynData->TnsData.GainLd;
           FDK_ASSERT(tns_stop >= tns_start);
           /* Consider existing headroom of all MDCT lines inside the TNS bands. */
-          SpecScale_window_tns -= getScalefactor(tile_spectrum + BandOffsets[tns_start],
+          SpecScale_window_tns -= mpegh_getScalefactor(tile_spectrum + BandOffsets[tns_start],
                                                  BandOffsets[tns_stop] - BandOffsets[tns_start]);
           if (SpecScale_window <= 17) {
             SpecScale_window_tns++;
@@ -468,7 +468,7 @@ AAC_DECODER_ERROR CBlock_InverseQuantizeSpectralData(CAacDecoderChannelInfo* pAa
       GetScaleFactorBandOffsets(&pAacDecoderChannelInfo->icsInfo, pSamplingRateInfo);
   const SHORT total_bands = GetScaleFactorBandsTotal(&pAacDecoderChannelInfo->icsInfo);
 
-  FDKmemclear(pAacDecoderChannelInfo->pDynData->aSfbScale, (8 * 16) * sizeof(SHORT));
+  mpegh_FDKmemclear(pAacDecoderChannelInfo->pDynData->aSfbScale, (8 * 16) * sizeof(SHORT));
 
   for (window = 0, group = 0; group < GetWindowGroups(&pAacDecoderChannelInfo->icsInfo); group++) {
     for (groupwin = 0; groupwin < GetWindowGroupLength(&pAacDecoderChannelInfo->icsInfo, group);
@@ -551,7 +551,7 @@ AAC_DECODER_ERROR CBlock_InverseQuantizeSpectralData(CAacDecoderChannelInfo* pAa
       FIXP_DBL* pSpectralCoefficient = SPEC(pAacDecoderChannelInfo->pSpectralCoefficient, window,
                                             pAacDecoderChannelInfo->granuleLength) +
                                        start_clear;
-      FDKmemclear(pSpectralCoefficient, diff_clear * sizeof(FIXP_DBL));
+      mpegh_FDKmemclear(pSpectralCoefficient, diff_clear * sizeof(FIXP_DBL));
 
     } /* for (groupwin=0; groupwin < GetWindowGroupLength(&pAacDecoderChannelInfo->icsInfo,group);
          groupwin++, window++) */
@@ -748,13 +748,13 @@ void CBlock_ApplyNoise(CAacDecoderStaticChannelInfo* pAacDecoderStaticChannelInf
             &pAacDecoderStaticChannelInfo->IGF_StaticData
                  .sGridInfoTab[GetWindowSequence(&pAacDecoderChannelInfo->icsInfo) == BLOCK_SHORT];
         IGF_MAP_INFO_HANDLE hMap = &hGrid->sIGFMapInfoTab[tileIdx];
-        FDKmemcpy(pAacDecoderStaticChannelInfo->IGF_StaticData.fSpectrumTab_sfb_exp[tileIdx],
+        mpegh_FDKmemcpy(pAacDecoderStaticChannelInfo->IGF_StaticData.fSpectrumTab_sfb_exp[tileIdx],
                   pAacDecoderChannelInfo->pDynData->aSfbScale,
                   sizeof(SHORT) * IGF_MAX_WIN * IGF_MAX_SFB_SHORT);
 
         if (pAacDecoderChannelInfo->IGFdata.bitstreamData[0].igf_allZero) {
           /* copy noise filled spectrum to the internal representation: */
-          FDKmemcpy(hMap->fSpectrumTab[0], pAacDecoderChannelInfo->pSpectralCoefficient,
+          mpegh_FDKmemcpy(hMap->fSpectrumTab[0], pAacDecoderChannelInfo->pSpectralCoefficient,
                     sizeof(FIXP_DBL) * 1024);
         }
 
@@ -815,7 +815,7 @@ void IGF_StereoFillingPrepare(CAacDecoderChannelInfo* pAacDecoderChannelInfo,
     FIXP_DBL* dmx_prev = dmx_prev_modified;
 
     /* Find the available headroom of the downmix signal and a suitable shift value*/
-    INT head_shift = getScalefactor(&dmx_prev[bin_start], sfb_width);
+    INT head_shift = mpegh_getScalefactor(&dmx_prev[bin_start], sfb_width);
 
     /* Avoiding noise boosting. Cleaning noise*/
     if (head_shift > 25) {
@@ -975,7 +975,7 @@ void IGF_StereoFillingApply(CAacDecoderChannelInfo* pAacDecoderChannelInfo,
 
     /* Stereo filling changes the dynamic range of the signal,despite keeping the energy of
     the signal constant. */
-    INT head_shift = getScalefactor(&pSpec[bin_start], sfb_width);
+    INT head_shift = mpegh_getScalefactor(&pSpec[bin_start], sfb_width);
 
     /* Do not calculate zeros or -1s */
     if (head_shift == 31) {
@@ -1095,7 +1095,7 @@ void ApplyTools(CAacDecoderStaticChannelInfo* pAacDecoderStaticChannelInfo[],
     if ((elFlags & AC_EL_ENHANCED_NOISE) && (!(elFlags & AC_EL_IGF_AFTER_TNS)) &&
         ((elFlags & AC_EL_IGF_INDEP_TILING) || !common_window)) {
       UCHAR TNF_mask[1024];
-      FDKmemclear(TNF_mask, 1024);
+      mpegh_FDKmemclear(TNF_mask, 1024);
 
       /* Run main IGF routine */
       CIgf_apply(&pAacDecoderStaticChannelInfo[channel]->IGF_StaticData,
@@ -1220,7 +1220,7 @@ void ApplyTools(CAacDecoderStaticChannelInfo* pAacDecoderStaticChannelInfo[],
     if ((elFlags & AC_EL_ENHANCED_NOISE) && (elFlags & AC_EL_IGF_AFTER_TNS) &&
         ((elFlags & AC_EL_IGF_INDEP_TILING) || !common_window)) {
       UCHAR TNF_mask[1024];
-      FDKmemclear(TNF_mask, 1024);
+      mpegh_FDKmemclear(TNF_mask, 1024);
 
       /* Run main IGF routine */
       CIgf_apply(&pAacDecoderStaticChannelInfo[channel]->IGF_StaticData,
@@ -1328,19 +1328,19 @@ void CBlock_FrequencyToTime(CAacDecoderStaticChannelInfo* pAacDecoderStaticChann
 #if defined(FDK_ASSERT_ENABLE)
       nSamples =
 #endif
-          imlt_block(
+          mpegh_imlt_block(
               &pAacDecoderStaticChannelInfo->IMdct, tmp,
               SPEC_LONG(pAacDecoderChannelInfo->pSpectralCoefficient),
               pAacDecoderChannelInfo->specScale, nSpec, frameLen, tl,
-              FDKgetWindowSlope(fl, GetWindowShape(&pAacDecoderChannelInfo->icsInfo)), fl,
-              FDKgetWindowSlope(fr, GetWindowShape(&pAacDecoderChannelInfo->icsInfo)), fr,
+              mpegh_FDKgetWindowSlope(fl, GetWindowShape(&pAacDecoderChannelInfo->icsInfo)), fl,
+              mpegh_FDKgetWindowSlope(fr, GetWindowShape(&pAacDecoderChannelInfo->icsInfo)), fr,
               (FIXP_DBL)0,
               pAacDecoderChannelInfo->currAliasingSymmetry ? MLT_FLAG_CURR_ALIAS_SYMMETRY : 0);
 
 #if defined(FUNCTION_scale_imdct_samples)
       scale_imdct_samples(tmp, outSamples, frameLen, 1);
 #else
-      scaleValuesSaturate(outSamples, tmp, frameLen, MDCT_OUT_HEADROOM - aacOutDataHeadroom);
+      mpegh_scaleValuesSaturate(outSamples, tmp, frameLen, MDCT_OUT_HEADROOM - aacOutDataHeadroom);
 #endif /* defined(FUNCTION_scale_imdct_samples) */
     }
   }
diff --git a/src/libMpeghDec/src/channel.cpp b/src/libMpeghDec/src/channel.cpp
index 05cd2a0..487e6eb 100644
--- a/src/libMpeghDec/src/channel.cpp
+++ b/src/libMpeghDec/src/channel.cpp
@@ -204,8 +204,8 @@ void CChannelElement_Decode(
         UCHAR* TNF_maskR =
             (UCHAR*)pAacDecoderChannelInfo[0]->pComStaticData->pWorkBufferCore1->mdctOutTemp + 512 +
             1024;
-        FDKmemclear(TNF_maskL, 1024);
-        FDKmemclear(TNF_maskR, 1024);
+        mpegh_FDKmemclear(TNF_maskL, 1024);
+        mpegh_FDKmemclear(TNF_maskR, 1024);
 
         CIgf_apply_stereo(
             &(pAacDecoderStaticChannelInfo[L]->IGF_StaticData),
@@ -275,10 +275,10 @@ void CChannelElement_Decode(
     } /* CommonWindow */
     else {
       if (elFlags & AC_EL_USAC_CP_POSSIBLE) {
-        FDKmemclear(pAacDecoderStaticChannelInfo[L]
+        mpegh_FDKmemclear(pAacDecoderStaticChannelInfo[L]
                         ->pCpeStaticData->jointStereoPersistentData.alpha_q_re_prev,
                     JointStereoMaximumGroups * JointStereoMaximumBands * sizeof(SHORT));
-        FDKmemclear(pAacDecoderStaticChannelInfo[L]
+        mpegh_FDKmemclear(pAacDecoderStaticChannelInfo[L]
                         ->pCpeStaticData->jointStereoPersistentData.alpha_q_im_prev,
                     JointStereoMaximumGroups * JointStereoMaximumBands * sizeof(SHORT));
       }
@@ -309,8 +309,8 @@ void CChannelElement_Decode(
         UCHAR* TNF_maskR =
             (UCHAR*)pAacDecoderChannelInfo[0]->pComStaticData->pWorkBufferCore1->mdctOutTemp + 512 +
             1024;
-        FDKmemclear(TNF_maskL, 1024);
-        FDKmemclear(TNF_maskR, 1024);
+        mpegh_FDKmemclear(TNF_maskL, 1024);
+        mpegh_FDKmemclear(TNF_maskR, 1024);
 
         CIgf_apply_stereo(
             &(pAacDecoderStaticChannelInfo[L]->IGF_StaticData),
@@ -469,7 +469,7 @@ AAC_DECODER_ERROR CChannelElement_Read(HANDLE_FDK_BITSTREAM hBs,
   FDK_ASSERT((numberOfChannels == 1) || (numberOfChannels == 2));
 
   /* Get channel element sequence table */
-  list = getBitstreamElementList(aot, epConfig, numberOfChannels, 0, elFlags);
+  list = mpegh_getBitstreamElementList(aot, epConfig, numberOfChannels, 0, elFlags);
   if (list == NULL) {
     error = AAC_DEC_UNSUPPORTED_FORMAT;
     goto bail;
@@ -646,8 +646,8 @@ AAC_DECODER_ERROR CChannelElement_Read(HANDLE_FDK_BITSTREAM hBs,
             CCplxPredictionData* cPD =
                 pAacDecoderChannelInfo[0]->pComStaticData->cplxPredictionData;
             for (group = 0; group < 8; group++) {
-              FDKmemclear(&cPD->alpha_q_re[group][max_sfb_ste], runs * sizeof(SHORT));
-              FDKmemclear(&cPD->alpha_q_im[group][max_sfb_ste], runs * sizeof(SHORT));
+              mpegh_FDKmemclear(&cPD->alpha_q_re[group][max_sfb_ste], runs * sizeof(SHORT));
+              mpegh_FDKmemclear(&cPD->alpha_q_im[group][max_sfb_ste], runs * sizeof(SHORT));
             }
           }
         }
@@ -667,7 +667,7 @@ AAC_DECODER_ERROR CChannelElement_Read(HANDLE_FDK_BITSTREAM hBs,
               break;
             }
           } else if (ch == 1) {
-            FDKmemcpy(pAacDecoderStaticChannelInfo[1]->ltp_param,
+            mpegh_FDKmemcpy(pAacDecoderStaticChannelInfo[1]->ltp_param,
                       pAacDecoderStaticChannelInfo[0]->ltp_param,
                       sizeof(pAacDecoderStaticChannelInfo[0]->ltp_param));
           }
@@ -860,7 +860,7 @@ AAC_DECODER_ERROR CChannelElement_Read(HANDLE_FDK_BITSTREAM hBs,
         pAacDecoderChannelInfo[ch]->renderMode == AACDEC_RENDER_ELDFB) {
       /* Copy lower part of coded spectrum for later use in FD Prediction */
       FIXP_DBL quantSpecCurr[172];
-      FDKmemcpy(quantSpecCurr, pAacDecoderChannelInfo[ch]->pSpectralCoefficient,
+      mpegh_FDKmemcpy(quantSpecCurr, pAacDecoderChannelInfo[ch]->pSpectralCoefficient,
                 172 * sizeof(quantSpecCurr[0]));
 
       /* IGF Stereo Filling start/stop */
@@ -907,7 +907,7 @@ AAC_DECODER_ERROR CChannelElement_Read(HANDLE_FDK_BITSTREAM hBs,
 
       /* Shows which bands are empty. */
       UCHAR* band_is_noise = pAacDecoderChannelInfo[ch]->pDynData->band_is_noise;
-      FDKmemset(band_is_noise, (UCHAR)1, sizeof(UCHAR) * (8 * 16));
+      mpegh_FDKmemset(band_is_noise, (UCHAR)1, sizeof(UCHAR) * (8 * 16));
 
       error = CBlock_InverseQuantizeSpectralData(pAacDecoderChannelInfo[ch], pSamplingRateInfo,
                                                  band_is_noise, 1);
@@ -978,9 +978,9 @@ AAC_DECODER_ERROR CChannelElement_Read(HANDLE_FDK_BITSTREAM hBs,
              * fill it again in "IGF_StereoFillingPrepare" */
             FIXP_DBL* dmx_prev_modified =
                 pAacDecoderChannelInfo[0]->pComStaticData->pWorkBufferCore1->mdctOutTemp;
-            FDKmemclear(dmx_prev_modified, 1024 * sizeof(LONG));
+            mpegh_FDKmemclear(dmx_prev_modified, 1024 * sizeof(LONG));
             SHORT dmx_prev_modified_exp[64];
-            FDKmemclear(dmx_prev_modified_exp, 64 * sizeof(SHORT));
+            mpegh_FDKmemclear(dmx_prev_modified_exp, 64 * sizeof(SHORT));
 
             /* We calculate the previous downmix for the fully noise-filled bands only and put it in
              * "dmx_prev_modified" */
@@ -1084,10 +1084,10 @@ AAC_DECODER_ERROR CChannelElement_Read(HANDLE_FDK_BITSTREAM hBs,
               SHORT* p2_tile_spectrum_exp = iisIGFDecLibAccessSourceSpectrum_exponent(
                   &pAacDecoderStaticChannelInfo[ch]->IGF_StaticData, tileIdx, 0);
 
-              FDKmemcpy(p2_tile_spectrum, pAacDecoderChannelInfo[ch]->pSpectralCoefficient,
+              mpegh_FDKmemcpy(p2_tile_spectrum, pAacDecoderChannelInfo[ch]->pSpectralCoefficient,
                         sizeof(FIXP_DBL) * sfb_offset[sfb_max_num_bins_copied]);
 
-              FDKmemcpy(p2_tile_spectrum_exp, pAacDecoderChannelInfo[ch]->pDynData->aSfbScale,
+              mpegh_FDKmemcpy(p2_tile_spectrum_exp, pAacDecoderChannelInfo[ch]->pDynData->aSfbScale,
                         sizeof(SHORT) * sfb_max_num_bins_copied);
             }
           }
diff --git a/src/libMpeghDec/src/conceal.cpp b/src/libMpeghDec/src/conceal.cpp
index 2197a2c..557d473 100644
--- a/src/libMpeghDec/src/conceal.cpp
+++ b/src/libMpeghDec/src/conceal.cpp
@@ -261,7 +261,7 @@ void CConcealment_InitChannelData(CConcealmentInfo* pConcealChannelInfo,
                                   AACDEC_RENDER_MODE initRenderMode, int samplesPerFrame) {
   int i;
   pConcealChannelInfo->TDNoiseSeed = 0;
-  FDKmemclear(pConcealChannelInfo->TDNoiseStates, sizeof(pConcealChannelInfo->TDNoiseStates));
+  mpegh_FDKmemclear(pConcealChannelInfo->TDNoiseStates, sizeof(pConcealChannelInfo->TDNoiseStates));
   pConcealChannelInfo->TDNoiseCoef[0] = FL2FXCONST_SGL(0.05f);
   pConcealChannelInfo->TDNoiseCoef[1] = FL2FXCONST_SGL(0.5f);
   pConcealChannelInfo->TDNoiseCoef[2] = FL2FXCONST_SGL(0.45f);
@@ -276,7 +276,7 @@ void CConcealment_InitChannelData(CConcealmentInfo* pConcealChannelInfo,
 
   pConcealChannelInfo->concealState = ConcealState_Ok;
 
-  FDKmemclear(pConcealChannelInfo->spectralCoefficient, 1024 * sizeof(FIXP_CNCL));
+  mpegh_FDKmemclear(pConcealChannelInfo->spectralCoefficient, 1024 * sizeof(FIXP_CNCL));
 
   for (i = 0; i < 8; i++) {
     pConcealChannelInfo->specScale[i] = 0;
@@ -484,7 +484,7 @@ void CConcealment_Store(CConcealmentInfo* hConcealmentInfo,
     SHORT* pSpecScale = pAacDecoderChannelInfo->specScale;
 
     /* store new scale factors */
-    FDKmemcpy(hConcealmentInfo->specScale, pSpecScale, 8 * sizeof(SHORT));
+    mpegh_FDKmemcpy(hConcealmentInfo->specScale, pSpecScale, 8 * sizeof(SHORT));
 
     C_ALLOC_ALIGNED_CHECK(pSpectralCoefficient);
     C_ALLOC_ALIGNED_CHECK(hConcealmentInfo->spectralCoefficient);
@@ -492,7 +492,7 @@ void CConcealment_Store(CConcealmentInfo* hConcealmentInfo,
     if (hConcealmentInfo->pConcealParams->method < ConcealMethodInter) {
       /* store new spectral bins */
 #if (CNCL_FRACT_BITS == DFRACT_BITS)
-      FDKmemcpy(hConcealmentInfo->spectralCoefficient, pSpectralCoefficient,
+      mpegh_FDKmemcpy(hConcealmentInfo->spectralCoefficient, pSpectralCoefficient,
                 1024 * sizeof(FIXP_CNCL));
 #else
       FIXP_CNCL* RESTRICT pCncl = &hConcealmentInfo->spectralCoefficient[1024 - 1];
@@ -512,7 +512,7 @@ void CConcealment_Store(CConcealmentInfo* hConcealmentInfo,
     hConcealmentInfo->windowSequence = GetWindowSequence(pIcsInfo);
     hConcealmentInfo->windowShape = GetWindowShape(pIcsInfo);
     hConcealmentInfo->lastWindowGroups = GetWindowGroups(pIcsInfo);
-    FDKmemcpy(hConcealmentInfo->lastWindowGroupLength, GetWindowGroupLengthTable(pIcsInfo),
+    mpegh_FDKmemcpy(hConcealmentInfo->lastWindowGroupLength, GetWindowGroupLengthTable(pIcsInfo),
               sizeof(UCHAR) * 8);
     hConcealmentInfo->lastWinGrpLen =
         *(GetWindowGroupLengthTable(pIcsInfo) + GetWindowGroups(pIcsInfo) - 1);
@@ -573,7 +573,7 @@ int CConcealment_Apply(CConcealmentInfo* hConcealmentInfo,
         case ConcealMethodMute:
           if (!frameOk) {
             /* Mute spectral data in case of errors */
-            FDKmemclear(pAacDecoderChannelInfo->pSpectralCoefficient,
+            mpegh_FDKmemclear(pAacDecoderChannelInfo->pSpectralCoefficient,
                         samplesPerFrame * sizeof(FIXP_DBL));
             /* Set last window shape */
             pAacDecoderChannelInfo->icsInfo.WindowShape = hConcealmentInfo->windowShape;
@@ -604,11 +604,11 @@ int CConcealment_Apply(CConcealmentInfo* hConcealmentInfo,
 
       if (hConcealmentInfo->concealState != ConcealState_Mute) {
         /* restore scale factors */
-        FDKmemcpy(pSpecScale, hConcealmentInfo->specScale, 8 * sizeof(SHORT));
+        mpegh_FDKmemcpy(pSpecScale, hConcealmentInfo->specScale, 8 * sizeof(SHORT));
 
         /* restore spectral bins */
 #if (CNCL_FRACT_BITS == DFRACT_BITS)
-        FDKmemcpy(pSpectralCoefficient, hConcealmentInfo->spectralCoefficient,
+        mpegh_FDKmemcpy(pSpectralCoefficient, hConcealmentInfo->spectralCoefficient,
                   1024 * sizeof(FIXP_DBL));
 #else
         for (i = 1024; i != 0; i--) {
@@ -617,10 +617,10 @@ int CConcealment_Apply(CConcealmentInfo* hConcealmentInfo,
 #endif
       } else {
         /* clear scale factors */
-        FDKmemclear(pSpecScale, 8 * sizeof(SHORT));
+        mpegh_FDKmemclear(pSpecScale, 8 * sizeof(SHORT));
 
         /* clear buffer */
-        FDKmemclear(pSpectralCoefficient, 1024 * sizeof(FIXP_CNCL));
+        mpegh_FDKmemclear(pSpectralCoefficient, 1024 * sizeof(FIXP_CNCL));
       }
     }
   }
@@ -676,8 +676,8 @@ static int CConcealment_ApplyNoise(CConcealmentInfo* pConcealmentInfo,
       pConcealmentInfo->winGrpOffset[1] = 0;
 
       /* mute spectral data */
-      FDKmemclear(pSpectralCoefficient, samplesPerFrame * sizeof(FIXP_DBL));
-      FDKmemclear(pConcealmentInfo->spectralCoefficient, samplesPerFrame * sizeof(FIXP_DBL));
+      mpegh_FDKmemclear(pSpectralCoefficient, samplesPerFrame * sizeof(FIXP_DBL));
+      mpegh_FDKmemclear(pConcealmentInfo->spectralCoefficient, samplesPerFrame * sizeof(FIXP_DBL));
 
       appliedProcessing = 1;
     } break;
@@ -1050,7 +1050,7 @@ static int CConcealment_ApplyFadeOut(int mode, CConcealmentInfo* pConcealmentInf
     if (mode == 1) {
       /* mute if attIdx gets large enaugh */
       if (attIdx > pConcealmentInfo->pConcealParams->numFadeOutFrames) {
-        FDKmemclear(pCncl, sizeof(FIXP_DBL) * windowLen);
+        mpegh_FDKmemclear(pCncl, sizeof(FIXP_DBL) * windowLen);
       }
 
       /* restore frequency coefficients from buffer - attenuation is done later */
diff --git a/src/libMpeghDec/src/deque.cpp b/src/libMpeghDec/src/deque.cpp
index 45367d6..ad6aea1 100644
--- a/src/libMpeghDec/src/deque.cpp
+++ b/src/libMpeghDec/src/deque.cpp
@@ -92,7 +92,7 @@ amm-info@iis.fraunhofer.de
 #include "genericStds.h"
 
 int deque_alloc(deque* q, unsigned int length, unsigned int block_size) {
-  q->data = (void*)FDKcalloc(length, block_size);
+  q->data = (void*)mpegh_FDKcalloc(length, block_size);
   if (q->data == NULL) {
     return -1;
   }
@@ -108,7 +108,7 @@ int deque_alloc(deque* q, unsigned int length, unsigned int block_size) {
 
 void deque_free(deque* q) {
   if (q->data != NULL) {
-    FDKfree(q->data);
+    mpegh_FDKfree(q->data);
     q->data = NULL;
   }
   deque_clear(q);
@@ -119,7 +119,7 @@ int deque_push_back(deque* q, void* data) {
     return -1;
   }
 
-  FDKmemcpy((unsigned char*)q->data + q->last * q->block_size, data, q->block_size);
+  mpegh_FDKmemcpy((unsigned char*)q->data + q->last * q->block_size, data, q->block_size);
   q->last = (q->last + 1) % q->max;
   q->size++;
   if (q->size == q->max) {
@@ -145,7 +145,7 @@ int deque_bulk_push_back(deque* q, void* data, unsigned int numData) {
       left = 0;
     }
     void* writePos = (unsigned char*)q->data + q->last * q->block_size;
-    FDKmemcpy(writePos, data, toCopy * q->block_size);
+    mpegh_FDKmemcpy(writePos, data, toCopy * q->block_size);
   } else {
     left = numData;
   }
@@ -153,7 +153,7 @@ int deque_bulk_push_back(deque* q, void* data, unsigned int numData) {
   if (left > 0) {
     unsigned char* tmpData = (unsigned char*)data + (numData - left) * q->block_size;
     ;
-    FDKmemcpy((unsigned char*)q->data, tmpData, left * q->block_size);
+    mpegh_FDKmemcpy((unsigned char*)q->data, tmpData, left * q->block_size);
   }
   q->last = (q->last + numData) % q->max;
   q->size += numData;
@@ -180,13 +180,13 @@ int deque_bulk_push_back_zeros(deque* q, unsigned int numZeros) {
       left = 0;
     }
     void* writePos = (unsigned char*)q->data + q->last * q->block_size;
-    FDKmemset(writePos, 0, toCopy * q->block_size);
+    mpegh_FDKmemset(writePos, 0, toCopy * q->block_size);
   } else {
     left = numZeros;
   }
 
   if (left > 0) {
-    FDKmemset((unsigned char*)q->data, 0, left * q->block_size);
+    mpegh_FDKmemset((unsigned char*)q->data, 0, left * q->block_size);
   }
   q->last = (q->last + numZeros) % q->max;
   q->size += numZeros;
@@ -235,12 +235,12 @@ int deque_bulk_pop_front_copy(deque* q, void* destination, unsigned int numData)
   void* dest = (unsigned char*)destination;
   if (q->first + numData >= q->max) {
     unsigned int toCopy = q->max - q->first;
-    FDKmemcpy(dest, data, toCopy * q->block_size);
+    mpegh_FDKmemcpy(dest, data, toCopy * q->block_size);
     left -= toCopy;
     data = (unsigned char*)q->data;
     dest = (unsigned char*)destination + toCopy * q->block_size;
   }
-  FDKmemcpy(dest, data, left * q->block_size);
+  mpegh_FDKmemcpy(dest, data, left * q->block_size);
   q->first = (q->first + numData) % q->max;
   q->size -= numData;
   q->full = false;
diff --git a/src/libMpeghDec/src/fdp.cpp b/src/libMpeghDec/src/fdp.cpp
index ffa65e5..bf494a8 100644
--- a/src/libMpeghDec/src/fdp.cpp
+++ b/src/libMpeghDec/src/fdp.cpp
@@ -171,8 +171,8 @@ void FDP_DecodeBins(CAacDecoderChannelInfo* pAacDecoderChannelInfo,
 
   /* if indepFlag==1 -> reset FDP history */
   if (flags & AC_INDEP) {
-    FDKmemclear(quantSpecPrev1, 160 * sizeof(quantSpecPrev1[0]));
-    FDKmemclear(quantSpecPrev2, 160 * sizeof(quantSpecPrev2[0]));
+    mpegh_FDKmemclear(quantSpecPrev1, 160 * sizeof(quantSpecPrev1[0]));
+    mpegh_FDKmemclear(quantSpecPrev2, 160 * sizeof(quantSpecPrev2[0]));
   }
 
   if (!isTcx && (bEightShortSequence || (sfbNumActive <= 0))) { /* no FD predictor */
@@ -265,12 +265,12 @@ void FDP_DecodeBins(CAacDecoderChannelInfo* pAacDecoderChannelInfo,
 
         /* We calculate the number of missing (non-available) headroom which would happen in fdp_int
          * after being scaled */
-        int fdp_scale = getScalefactor(p2fdp, width);
+        int fdp_scale = mpegh_getScalefactor(p2fdp, width);
         int fdp_shift = 40 - pAacDecoderChannelInfo->pDynData->aSfbScale[sfb];
         fdp_scale = fdp_scale - fdp_shift;
 
         /* Find the headroom of the signal */
-        int output_scale = getScalefactor(p2output, width);
+        int output_scale = mpegh_getScalefactor(p2output, width);
 
         /* Find the minimum of the headroom of the signal and the missing fdp headroom */
         int diffMin = fMin(fdp_scale, output_scale);
diff --git a/src/libMpeghDec/src/ltp_post.cpp b/src/libMpeghDec/src/ltp_post.cpp
index 7d34026..3ef141a 100644
--- a/src/libMpeghDec/src/ltp_post.cpp
+++ b/src/libMpeghDec/src/ltp_post.cpp
@@ -245,7 +245,7 @@ static void ltp_get_zir(FIXP_DBL* zir, int length, FIXP_SGL* synth_ltp, FIXP_SGL
     y0++;
   }
 
-  FDKmemclear(zir, length * sizeof(FIXP_DBL));
+  mpegh_FDKmemclear(zir, length * sizeof(FIXP_DBL));
 
   CLpc_Synthesis(zir, length, 1, A, A_e, lpcorder, buf, &stIdx);
 
@@ -351,7 +351,7 @@ static void ltp_synth_filter(FIXP_SGL* synth_ltp, FIXP_SGL* synth, int length, i
 
 #endif /* defined(FUNCTION_ltp_synth_filter_aac) */
   } else {
-    FDKmemcpy(synth_ltp, synth, length * sizeof(FIXP_SGL));
+    mpegh_FDKmemcpy(synth_ltp, synth, length * sizeof(FIXP_SGL));
   }
 
   return;
@@ -435,10 +435,10 @@ void ltp_post(FIXP_DBL* sig, int L_frame, int fs, int* ltp_param, int* pitch_int
     FDK_ASSERT((L_frame >= LTP_MEM_IN_SIZE) && (L_frame >= LTP_MEM_OUT_SIZE));
 
     /* Update mem_in states */
-    scaleValuesSaturate(mem_in, sig + L_frame - LTP_MEM_IN_SIZE, LTP_MEM_IN_SIZE, PCM_OUT_HEADROOM);
+    mpegh_scaleValuesSaturate(mem_in, sig + L_frame - LTP_MEM_IN_SIZE, LTP_MEM_IN_SIZE, PCM_OUT_HEADROOM);
 
     /* Update mem_out states */
-    scaleValuesSaturate(mem_out, sig + L_frame - LTP_MEM_OUT_SIZE, LTP_MEM_OUT_SIZE,
+    mpegh_scaleValuesSaturate(mem_out, sig + L_frame - LTP_MEM_OUT_SIZE, LTP_MEM_OUT_SIZE,
                         PCM_OUT_HEADROOM);
 
     /* Update past values */
@@ -466,13 +466,13 @@ void ltp_post(FIXP_DBL* sig, int L_frame, int fs, int* ltp_param, int* pitch_int
 
   /* Input buffer */
   sig_in = buf_in + LTP_MEM_IN_SIZE;
-  FDKmemcpy(buf_in, mem_in, LTP_MEM_IN_SIZE * sizeof(FIXP_SGL));
-  scaleValuesSaturate(sig_in, sig, L_frame, PCM_OUT_HEADROOM);
-  FDKmemcpy(mem_in, sig_in + L_frame - LTP_MEM_IN_SIZE, LTP_MEM_IN_SIZE * sizeof(FIXP_SGL));
+  mpegh_FDKmemcpy(buf_in, mem_in, LTP_MEM_IN_SIZE * sizeof(FIXP_SGL));
+  mpegh_scaleValuesSaturate(sig_in, sig, L_frame, PCM_OUT_HEADROOM);
+  mpegh_FDKmemcpy(mem_in, sig_in + L_frame - LTP_MEM_IN_SIZE, LTP_MEM_IN_SIZE * sizeof(FIXP_SGL));
 
   /* Output buffer */
   sig_out = buf_out + LTP_MEM_OUT_SIZE;
-  FDKmemcpy(buf_out, mem_out, LTP_MEM_OUT_SIZE * sizeof(FIXP_SGL));
+  mpegh_FDKmemcpy(buf_out, mem_out, LTP_MEM_OUT_SIZE * sizeof(FIXP_SGL));
 
   /* LTP parameters: integer pitch, fractional pitch, gain */
   ltp_decode_params(ltp_param, &pitch_int, &pitch_fr, &gain, pit_min, pit_fr1, pit_fr2, pit_max,
@@ -491,7 +491,7 @@ void ltp_post(FIXP_DBL* sig, int L_frame, int fs, int* ltp_param, int* pitch_int
 
   /******** Transition part ********/
   if (gain == (FIXP_SGL)0 && *gain_past == (FIXP_SGL)0) {
-    FDKmemcpy(sig_out + enc_dec_delay, sig_in + enc_dec_delay, L_transition * sizeof(FIXP_SGL));
+    mpegh_FDKmemcpy(sig_out + enc_dec_delay, sig_in + enc_dec_delay, L_transition * sizeof(FIXP_SGL));
   } else if (*gain_past == (FIXP_SGL)0) {
     ltp_synth_filter(sig_out + enc_dec_delay, sig_in + enc_dec_delay, L_transition, pitch_int,
                      pitch_fr, gain, ltp_param[2], pitres, NULL, 1, filtIdx);
@@ -529,7 +529,7 @@ void ltp_post(FIXP_DBL* sig, int L_frame, int fs, int* ltp_param, int* pitch_int
   *pitch_fr_past = pitch_fr;
   *gain_past = gain;
   *gainIdx_past = ltp_param[2];
-  FDKmemcpy(mem_out, buf_out + L_frame, LTP_MEM_OUT_SIZE * sizeof(FIXP_SGL));
+  mpegh_FDKmemcpy(mem_out, buf_out + L_frame, LTP_MEM_OUT_SIZE * sizeof(FIXP_SGL));
 
   return;
 }
diff --git a/src/libMpeghDec/src/mct.cpp b/src/libMpeghDec/src/mct.cpp
index 5b2433e..96c4828 100644
--- a/src/libMpeghDec/src/mct.cpp
+++ b/src/libMpeghDec/src/mct.cpp
@@ -215,10 +215,10 @@ int CMct_Initialize(CMctPtr* pCMctPtr, const ULONG mctChanMask, int firstSigIdx,
   if (pCMctPtr == NULL) return -1;
   if (*pCMctPtr != NULL) return -1;
 
-  mct = (CMct*)FDKcalloc(sizeof(CMct), 1);
+  mct = (CMct*)mpegh_FDKcalloc(sizeof(CMct), 1);
   if (!mct) return AAC_DEC_OUT_OF_MEMORY;
 
-  mct->mctWork = (CMctWorkPtr)FDKcalloc(sizeof(CMctWork), 1);
+  mct->mctWork = (CMctWorkPtr)mpegh_FDKcalloc(sizeof(CMctWork), 1);
   if (!mct->mctWork) {
     goto bail;
   }
@@ -234,9 +234,9 @@ int CMct_Initialize(CMctPtr* pCMctPtr, const ULONG mctChanMask, int firstSigIdx,
   }
 
   if (mct->numMctChannels) {
-    mct->prevOutSpec = (FIXP_DBL*)FDKmalloc(mct->numMctChannels * 1024 * sizeof(FIXP_DBL));
+    mct->prevOutSpec = (FIXP_DBL*)mpegh_FDKmalloc(mct->numMctChannels * 1024 * sizeof(FIXP_DBL));
     if (!mct->prevOutSpec) goto bail;
-    mct->prevOutSpec_exp = (SHORT*)FDKmalloc(mct->numMctChannels * 8 * 16 * sizeof(SHORT));
+    mct->prevOutSpec_exp = (SHORT*)mpegh_FDKmalloc(mct->numMctChannels * 8 * 16 * sizeof(SHORT));
     if (!mct->prevOutSpec_exp) goto bail;
   } else {
     mct->prevOutSpec = NULL;
@@ -250,10 +250,10 @@ int CMct_Initialize(CMctPtr* pCMctPtr, const ULONG mctChanMask, int firstSigIdx,
   return AAC_DEC_OK;
 
 bail:
-  if (mct->mctWork != NULL) FDKfree(mct->mctWork);
-  if (mct->prevOutSpec != NULL) FDKfree(mct->prevOutSpec);
-  /* if (mct->prevOutSpec_exp != NULL) FDKfree(mct->prevOutSpec_exp); */
-  FDKfree(mct);
+  if (mct->mctWork != NULL) mpegh_FDKfree(mct->mctWork);
+  if (mct->prevOutSpec != NULL) mpegh_FDKfree(mct->prevOutSpec);
+  /* if (mct->prevOutSpec_exp != NULL) mpegh_FDKfree(mct->prevOutSpec_exp); */
+  mpegh_FDKfree(mct);
 
   return AAC_DEC_OUT_OF_MEMORY;
 }
@@ -261,15 +261,15 @@ int CMct_Initialize(CMctPtr* pCMctPtr, const ULONG mctChanMask, int firstSigIdx,
 void CMct_Destroy(CMctPtr self) {
   if (self != NULL) {
     if (self->mctWork != NULL) {
-      FDKfree(self->mctWork);
+      mpegh_FDKfree(self->mctWork);
     }
     if (self->prevOutSpec != NULL) {
-      FDKfree(self->prevOutSpec);
+      mpegh_FDKfree(self->prevOutSpec);
     }
     if (self->prevOutSpec_exp != NULL) {
-      FDKfree(self->prevOutSpec_exp);
+      mpegh_FDKfree(self->prevOutSpec_exp);
     }
-    FDKfree(self);
+    mpegh_FDKfree(self);
   }
 }
 
@@ -537,7 +537,7 @@ static void clean_sfb_band_MCT_STEFI_DMX(FIXP_DBL* outCoefficient, INT outCoeffi
     }
 
   } else {
-    FDKmemclear(outCoefficient, sizeof(FIXP_DBL) * length);
+    mpegh_FDKmemclear(outCoefficient, sizeof(FIXP_DBL) * length);
   }
 }
 
@@ -566,7 +566,7 @@ static int inverseDpcmAngleCoding(CMctPtr self, SHORT pairCoeffQSfb[], int pair,
         self->pairCoeffQSfbPrev[pair][band] = DEFAULT_ALPHA;
       }
 #else
-      FDKmemclear(self->pairCoeffQSfbPrev[pair],
+      mpegh_FDKmemclear(self->pairCoeffQSfbPrev[pair],
                   MAX_NUM_MCT_BANDS * sizeof(self->pairCoeffQSfbPrev[0][0]));
 #endif
     }
@@ -818,12 +818,12 @@ static void applyMctRotationIdx(FIXP_DBL* dmx, SHORT* dmxExp, FIXP_DBL* res, SHO
           (fMultDiv2(temp_dmx, SinAlpha) >> lScale) + (fMultDiv2(temp_res, CosAlpha) >> rScale);
     }
 
-    int headroom = getScalefactor(dmx, nSamples) - 1;
-    scaleValues(dmx, nSamples, headroom);
+    int headroom = mpegh_getScalefactor(dmx, nSamples) - 1;
+    mpegh_scaleValues(dmx, nSamples, headroom);
     *dmxExp = OutExp - headroom;
 
-    headroom = getScalefactor(res, nSamples) - 1;
-    scaleValues(res, nSamples, headroom);
+    headroom = mpegh_getScalefactor(res, nSamples) - 1;
+    mpegh_scaleValues(res, nSamples, headroom);
     *resExp = OutExp - headroom;
 #endif
   }
@@ -902,12 +902,12 @@ static void applyMctPrediction(FIXP_DBL* dmx, SHORT* dmxExp, FIXP_DBL* res, SHOR
     *p2CoeffL++ = tempL + help2;
   }
 
-  int headroom = getScalefactor(dmx, nSamples);
-  scaleValues(dmx, nSamples, headroom);
+  int headroom = mpegh_getScalefactor(dmx, nSamples);
+  mpegh_scaleValues(dmx, nSamples, headroom);
   *dmxExp = OutExp - headroom;
 
-  headroom = getScalefactor(res, nSamples);
-  scaleValues(res, nSamples, headroom);
+  headroom = mpegh_getScalefactor(res, nSamples);
+  mpegh_scaleValues(res, nSamples, headroom);
   *resExp = OutExp - headroom;
 }
 #endif /* #ifndef applyMctPrediction */
@@ -1151,7 +1151,7 @@ static void CMct_StereoFilling_GetPreviousDmx(
           } else {
             int width = pScaleFactorBandOffsets[sfb + 1] - pScaleFactorBandOffsets[sfb];
 
-            FDKmemcpy(outCoefficient, leftCoefficient, sizeof(FIXP_DBL) * width);
+            mpegh_FDKmemcpy(outCoefficient, leftCoefficient, sizeof(FIXP_DBL) * width);
 
             band_is_noise[group * 16 + sfb] = 0;
 
@@ -1352,7 +1352,7 @@ static void MCT_StereoFilling(FIXP_DBL* pSpec, SHORT* pSpec_exp,
     /* Find a suitable shift for dmx addition */
     const int shift = DFRACT_BITS - fNormz((FIXP_DBL)sfb_width);
 
-    INT head_shift_sfb = getScalefactor(&pSpec[bin_start], sfb_width);
+    INT head_shift_sfb = mpegh_getScalefactor(&pSpec[bin_start], sfb_width);
 
     /* Calculate the energy in the particular SFB */
     FIXP_DBL enRes = (FIXP_DBL)0;
@@ -1411,7 +1411,7 @@ static void MCT_StereoFilling(FIXP_DBL* pSpec, SHORT* pSpec_exp,
       INT energy_dmx_e = 0;
 
       /* Find the available headroom of the downmix signal and a suitable shift value*/
-      INT head_shift_dmx = getScalefactor(&dmx_prev[bin_start], sfb_width);
+      INT head_shift_dmx = mpegh_getScalefactor(&dmx_prev[bin_start], sfb_width);
 
       /* Calculate the energy of the previous downmix. If it is non-zero, then the
       downmix will be scaled and added to the signal.*/
@@ -1556,7 +1556,7 @@ static void MCT_StereoFilling(FIXP_DBL* pSpec, SHORT* pSpec_exp,
 
         /* Stereo filling changes the dynamic range of the signal,despite keeping the energy of
         the signal constant. */
-        INT head_shift = getScalefactor(&pSpec[bin_start], sfb_width);
+        INT head_shift = mpegh_getScalefactor(&pSpec[bin_start], sfb_width);
 
         /* Modify spectrum */
         for (int bin = bin_start; bin < bin_stop; bin++) {
@@ -1651,8 +1651,8 @@ int CMct_MCT_StereoFilling(CMctPtr self, CStreamInfo* streamInfo,
         FIXP_DBL emptyBuffer[1024];
         SHORT emptyBuffer_exp[(8 * 16)];
 
-        FDKmemclear(prevDmx, sizeof(FIXP_DBL) * 1024);
-        FDKmemclear(prevDmx_exp, sizeof(SHORT) * (8 * 16));
+        mpegh_FDKmemclear(prevDmx, sizeof(FIXP_DBL) * 1024);
+        mpegh_FDKmemclear(prevDmx_exp, sizeof(SHORT) * (8 * 16));
 
         FIXP_DBL* prevSpec1 = &self->prevOutSpec[work->codePairs[pair][0] * 1024];
         FIXP_DBL* prevSpec2 = &self->prevOutSpec[work->codePairs[pair][1] * 1024];
@@ -1666,8 +1666,8 @@ int CMct_MCT_StereoFilling(CMctPtr self, CStreamInfo* streamInfo,
         }
         /* If one of the previous elements is available for computing previous dmx */
         else if (zeroPrevOutSpec1 || zeroPrevOutSpec2) {
-          FDKmemclear(emptyBuffer, sizeof(FIXP_DBL) * 1024);
-          FDKmemclear(emptyBuffer_exp, sizeof(SHORT) * (8 * 16));
+          mpegh_FDKmemclear(emptyBuffer, sizeof(FIXP_DBL) * 1024);
+          mpegh_FDKmemclear(emptyBuffer_exp, sizeof(SHORT) * (8 * 16));
 
           if (zeroPrevOutSpec1) {
             prevSpec1 = emptyBuffer;
@@ -1699,8 +1699,8 @@ int CMct_MCT_StereoFilling(CMctPtr self, CStreamInfo* streamInfo,
          * subsequent tile processing intact */
         FIXP_DBL* prevDmx_temp = emptyBuffer;      /*Reuse available buffer*/
         SHORT* prevDmx_exp_temp = emptyBuffer_exp; /*Reuse available buffer*/
-        FDKmemcpy(prevDmx_temp, prevDmx, sizeof(FIXP_DBL) * 1024);
-        FDKmemcpy(prevDmx_exp_temp, prevDmx_exp, sizeof(SHORT) * (8 * 16));
+        mpegh_FDKmemcpy(prevDmx_temp, prevDmx, sizeof(FIXP_DBL) * 1024);
+        mpegh_FDKmemcpy(prevDmx_exp_temp, prevDmx_exp, sizeof(SHORT) * (8 * 16));
 
         /* Stereo Filling parameter calculation */
         MCT_StereoFilling(chInfo2->pSpectralCoefficient, chInfo2->pDynData->aSfbScale, chInfo2,
@@ -1723,8 +1723,8 @@ int CMct_MCT_StereoFilling(CMctPtr self, CStreamInfo* streamInfo,
                   iisIGFDecLibAccessSourceSpectrum_exponent(&stChInfo2->IGF_StaticData, tileIdx, 0);
 
               /* Use the stored prevDmx for Stereo Filing */
-              FDKmemcpy(prevDmx, prevDmx_temp, sizeof(FIXP_DBL) * 1024);
-              FDKmemcpy(prevDmx_exp, prevDmx_exp_temp, sizeof(SHORT) * 128);
+              mpegh_FDKmemcpy(prevDmx, prevDmx_temp, sizeof(FIXP_DBL) * 1024);
+              mpegh_FDKmemcpy(prevDmx_exp, prevDmx_exp_temp, sizeof(SHORT) * 128);
 
               /* Apply MCT Steffi over the particular tile */
               MCT_StereoFilling(p2_tile_spectrum, p2_tile_spectrum_exp, chInfo2, samplingRateInfo,
@@ -1737,7 +1737,7 @@ int CMct_MCT_StereoFilling(CMctPtr self, CStreamInfo* streamInfo,
                                       samplingRateInfo);
 
         } /* if(MCT_elFlags[chTag[ch2]] & AC_EL_ENHANCED_NOISE) */
-        FDKmemclear(band_is_noise, (8 * 16));
+        mpegh_FDKmemclear(band_is_noise, (8 * 16));
 
       } /* if(bIsShortBlock == 0) */
 
@@ -1820,13 +1820,13 @@ void CMct_StereoFilling_save_prev(CMctPtr self, CAacDecoderChannelInfo** pAacDec
 
   for (int i = 0; i < self->numMctChannels; i++) {
     chInfo = pAacDecoderChannelInfo[chTag[i]];
-    FDKmemcpy(&self->prevOutSpec[i * 1024], chInfo->pSpectralCoefficient, 1024 * sizeof(FIXP_DBL));
-    FDKmemcpy(&self->prevOutSpec_exp[i * (8 * 16)], chInfo->pDynData->aSfbScale,
+    mpegh_FDKmemcpy(&self->prevOutSpec[i * 1024], chInfo->pSpectralCoefficient, 1024 * sizeof(FIXP_DBL));
+    mpegh_FDKmemcpy(&self->prevOutSpec_exp[i * (8 * 16)], chInfo->pDynData->aSfbScale,
               (8 * 16) * sizeof(SHORT));
   }
 }
 
 void CMct_StereoFilling_clear_prev(CMctPtr self, CAacDecoderChannelInfo** pAacDecoderChannelInfo) {
-  FDKmemclear(&self->prevOutSpec[0], self->numMctChannels * 1024 * sizeof(FIXP_DBL));
-  FDKmemclear(&self->prevOutSpec_exp[0], self->numMctChannels * (8 * 16) * sizeof(SHORT));
+  mpegh_FDKmemclear(&self->prevOutSpec[0], self->numMctChannels * 1024 * sizeof(FIXP_DBL));
+  mpegh_FDKmemclear(&self->prevOutSpec_exp[0], self->numMctChannels * (8 * 16) * sizeof(SHORT));
 }
diff --git a/src/libMpeghDec/src/mpeghdecoder.cpp b/src/libMpeghDec/src/mpeghdecoder.cpp
index 5a58d06..144265e 100644
--- a/src/libMpeghDec/src/mpeghdecoder.cpp
+++ b/src/libMpeghDec/src/mpeghdecoder.cpp
@@ -202,13 +202,13 @@ HANDLE_MPEGH_DECODER_CONTEXT mpeghdecoder_init(int32_t cicpSetup) {
     return NULL;
   }
 
-  MPEGH_DECODER_CONTEXT* ctx = (MPEGH_DECODER_CONTEXT*)FDKcalloc(1, sizeof(MPEGH_DECODER_CONTEXT));
+  MPEGH_DECODER_CONTEXT* ctx = (MPEGH_DECODER_CONTEXT*)mpegh_FDKcalloc(1, sizeof(MPEGH_DECODER_CONTEXT));
   if (ctx == NULL) {
     goto bail;
   }
 
   ctx->maxDecoderOutputSamples = numOutChannels * MAX_NUM_FRAME_SAMPLES;
-  ctx->tmpSamples = (INT_PCM*)FDKcalloc(ctx->maxDecoderOutputSamples, sizeof(INT_PCM));
+  ctx->tmpSamples = (INT_PCM*)mpegh_FDKcalloc(ctx->maxDecoderOutputSamples, sizeof(INT_PCM));
   if (ctx->tmpSamples == NULL) {
     goto bail;
   }
@@ -304,16 +304,16 @@ MPEGH_DECODER_ERROR mpeghdecoder_setMhaConfig(HANDLE_MPEGH_DECODER_CONTEXT hCtx,
     return MPEGH_DEC_UNSUPPORTED_PARAM;
   }
   if (hCtx->mhaConfig != NULL) {
-    FDKfree(hCtx->mhaConfig);
+    mpegh_FDKfree(hCtx->mhaConfig);
     hCtx->mhaConfig = NULL;
   }
   MPEGH_DECODER_ERROR retval = MPEGH_DEC_OK;
   hCtx->mhaConfigLength = configSize;
-  hCtx->mhaConfig = (uint8_t*)FDKcalloc(hCtx->mhaConfigLength, sizeof(uint8_t));
+  hCtx->mhaConfig = (uint8_t*)mpegh_FDKcalloc(hCtx->mhaConfigLength, sizeof(uint8_t));
   if (hCtx->mhaConfig == NULL) {
     return MPEGH_DEC_OUT_OF_MEMORY;
   }
-  FDKmemcpy(hCtx->mhaConfig, config, configSize * sizeof(uint8_t));
+  mpegh_FDKmemcpy(hCtx->mhaConfig, config, configSize * sizeof(uint8_t));
 
   retval = restartDecoder(hCtx);
   return retval;
@@ -325,12 +325,12 @@ void mpeghdecoder_destroy(HANDLE_MPEGH_DECODER_CONTEXT hCtx) {
   }
 
   if (hCtx->mhaConfig != NULL) {
-    FDKfree(hCtx->mhaConfig);
+    mpegh_FDKfree(hCtx->mhaConfig);
     hCtx->mhaConfig = NULL;
   }
 
   if (hCtx->tmpSamples != NULL) {
-    FDKfree(hCtx->tmpSamples);
+    mpegh_FDKfree(hCtx->tmpSamples);
     hCtx->tmpSamples = NULL;
   }
 
@@ -350,7 +350,7 @@ void mpeghdecoder_destroy(HANDLE_MPEGH_DECODER_CONTEXT hCtx) {
   deque_free(&hCtx->fadeoutIdxQueue);
   deque_free(&hCtx->fadeinIdxQueue);
 
-  FDKfree(hCtx);
+  mpegh_FDKfree(hCtx);
   hCtx = NULL;
 }
 
diff --git a/src/libMpeghDec/src/stereo.cpp b/src/libMpeghDec/src/stereo.cpp
index 0c5be6e..391fea3 100644
--- a/src/libMpeghDec/src/stereo.cpp
+++ b/src/libMpeghDec/src/stereo.cpp
@@ -113,7 +113,7 @@ int CJointStereo_Read(HANDLE_FDK_BITSTREAM bs, CJointStereoData* pJointStereoDat
 
   pJointStereoData->MsMaskPresent = (UCHAR)FDKread2Bits(bs);
 
-  FDKmemclear(pJointStereoData->MsUsed, scaleFactorBandsTransmitted * sizeof(UCHAR));
+  mpegh_FDKmemclear(pJointStereoData->MsUsed, scaleFactorBandsTransmitted * sizeof(UCHAR));
 
   pJointStereoData->cplx_pred_flag = 0;
   if (cplxPredictionActiv) {
@@ -192,9 +192,9 @@ int CJointStereo_Read(HANDLE_FDK_BITSTREAM bs, CJointStereoData* pJointStereoDat
              (pJointStereoPersistentData->winSeqPrev != BLOCK_SHORT)) ||
             ((pJointStereoPersistentData->winSeqPrev == BLOCK_SHORT) &&
              (windowSequence != BLOCK_SHORT))) {
-          FDKmemclear(pJointStereoPersistentData->alpha_q_re_prev,
+          mpegh_FDKmemclear(pJointStereoPersistentData->alpha_q_re_prev,
                       JointStereoMaximumGroups * JointStereoMaximumBands * sizeof(SHORT));
-          FDKmemclear(pJointStereoPersistentData->alpha_q_im_prev,
+          mpegh_FDKmemclear(pJointStereoPersistentData->alpha_q_im_prev,
                       JointStereoMaximumGroups * JointStereoMaximumBands * sizeof(SHORT));
         }
         if (flags & AC_MPEGH3DA) {
@@ -207,9 +207,9 @@ int CJointStereo_Read(HANDLE_FDK_BITSTREAM bs, CJointStereoData* pJointStereoDat
             }
           }
         } else {
-          FDKmemclear(cplxPredictionData->alpha_q_re,
+          mpegh_FDKmemclear(cplxPredictionData->alpha_q_re,
                       JointStereoMaximumGroups * JointStereoMaximumBands * sizeof(SHORT));
-          FDKmemclear(cplxPredictionData->alpha_q_im,
+          mpegh_FDKmemclear(cplxPredictionData->alpha_q_im,
                       JointStereoMaximumGroups * JointStereoMaximumBands * sizeof(SHORT));
         }
 
@@ -338,7 +338,7 @@ int CJointStereo_ReadIGF(HANDLE_FDK_BITSTREAM bs, CJointStereoData* pJointStereo
 
   pJointStereoData->IGF_MsMaskPresent = (UCHAR)FDKread2Bits(bs);
 
-  FDKmemclear(&(pJointStereoData->MsUsed[igfStartSfb]),
+  mpegh_FDKmemclear(&(pJointStereoData->MsUsed[igfStartSfb]),
               (JointStereoMaximumBands - igfStartSfb) * sizeof(UCHAR));
 
   pJointStereoData->igf_cplx_pred_flag = 0;
@@ -1003,7 +1003,7 @@ void CJointStereo_ApplyMS(CAacDecoderChannelInfo* pAacDecoderChannelInfo[2],
 
       for (groupwin = 0; groupwin < pWindowGroupLength[group]; groupwin++, window++) {
         /* initialize the MDST with zeros */
-        FDKmemclear(&dmx_im[windowLen * window], windowLen * sizeof(FIXP_DBL));
+        mpegh_FDKmemclear(&dmx_im[windowLen * window], windowLen * sizeof(FIXP_DBL));
 
         /* 1. calculate the previous downmix MDCT. We do this once just for the Main band. */
         if (cplxPredictionData->complex_coef == 1) {
@@ -1044,7 +1044,7 @@ void CJointStereo_ApplyMS(CAacDecoderChannelInfo* pAacDecoderChannelInfo[2],
                 /* now scale channels and determine downmix MDCT of previous frame */
                 if (pAacDecoderStaticChannelInfo[L]
                         ->pCpeStaticData->jointStereoPersistentData.clearSpectralCoeffs == 1) {
-                  FDKmemclear(dmx_re_prev, windowLen * sizeof(FIXP_DBL));
+                  mpegh_FDKmemclear(dmx_re_prev, windowLen * sizeof(FIXP_DBL));
                   dmx_re_prev_e = 0;
                 } else {
                   if (cplxPredictionData->pred_dir == 0) {
@@ -1067,7 +1067,7 @@ void CJointStereo_ApplyMS(CAacDecoderChannelInfo* pAacDecoderChannelInfo[2],
                 /* In case that we use INF we have to preserve the state of the "dmx_re_prev"
                 (original or computed). This is necessary because we have to apply MS over the
                 separate IGF tiles. */
-                FDKmemcpy(store_dmx_re_prev, &dmx_re_prev[0], windowLen * sizeof(FIXP_DBL));
+                mpegh_FDKmemcpy(store_dmx_re_prev, &dmx_re_prev[0], windowLen * sizeof(FIXP_DBL));
 
                 /* Particular exponent of the computed/original "dmx_re_prev" must be kept for the
                  * tile MS calculations if necessary.*/
@@ -1094,15 +1094,15 @@ void CJointStereo_ApplyMS(CAacDecoderChannelInfo* pAacDecoderChannelInfo[2],
           if (window == 0) {
             if (dmx_re_prev_e < frameMaxScale) {
               if (mainband_flag == 0) {
-                scaleValues(dmx_re_prev, store_dmx_re_prev, windowLen,
+                mpegh_scaleValues(dmx_re_prev, store_dmx_re_prev, windowLen,
                             -fMin(DFRACT_BITS - 1, (frameMaxScale - dmx_re_prev_e)));
               } else {
-                scaleValues(dmx_re_prev, windowLen,
+                mpegh_scaleValues(dmx_re_prev, windowLen,
                             -fMin(DFRACT_BITS - 1, (frameMaxScale - dmx_re_prev_e)));
               }
             } else {
               if (mainband_flag == 0) {
-                FDKmemcpy(dmx_re_prev, store_dmx_re_prev, windowLen * sizeof(FIXP_DBL));
+                mpegh_FDKmemcpy(dmx_re_prev, store_dmx_re_prev, windowLen * sizeof(FIXP_DBL));
               }
               specScaleL[0] = dmx_re_prev_e;
               specScaleR[0] = dmx_re_prev_e;
@@ -1110,7 +1110,7 @@ void CJointStereo_ApplyMS(CAacDecoderChannelInfo* pAacDecoderChannelInfo[2],
           } else { /* window != 0 */
             FDK_ASSERT(pAacDecoderChannelInfo[L]->icsInfo.WindowSequence == BLOCK_SHORT);
             if (specScaleL[window - 1] < frameMaxScale) {
-              scaleValues(&dmx_re[windowLen * (window - 1)], windowLen,
+              mpegh_scaleValues(&dmx_re[windowLen * (window - 1)], windowLen,
                           -fMin(DFRACT_BITS - 1, (frameMaxScale - specScaleL[window - 1])));
             } else {
               specScaleL[window] = specScaleL[window - 1];
diff --git a/src/libMpeghDec/src/ui.cpp b/src/libMpeghDec/src/ui.cpp
index eea544b..01f748c 100644
--- a/src/libMpeghDec/src/ui.cpp
+++ b/src/libMpeghDec/src/ui.cpp
@@ -1005,8 +1005,8 @@ AAC_DECODER_ERROR FDK_mpeghUiInitialize(HANDLE_AACDECODER self) {
   self->uiStatusValid = 0;
   self->drcStatusValid = 0;
   self->uiSignalChanged = 0;
-  FDKmemclear(&self->uiStatus, sizeof(self->uiStatus));
-  FDKmemclear(&self->uiStatusNext, sizeof(self->uiStatusNext));
+  mpegh_FDKmemclear(&self->uiStatus, sizeof(self->uiStatus));
+  mpegh_FDKmemclear(&self->uiStatusNext, sizeof(self->uiStatusNext));
   updateOnOffFlags(self);
 
   tpErr =
@@ -1066,7 +1066,7 @@ void updateOnOffFlags(HANDLE_AACDECODER self) {
   }
 
   /* clear skipped signals flags */
-  FDKmemclear(self->signalSkipped, TP_MPEGH_MAX_SIGNAL_GROUPS * sizeof(UCHAR));
+  mpegh_FDKmemclear(self->signalSkipped, TP_MPEGH_MAX_SIGNAL_GROUPS * sizeof(UCHAR));
 
   /* check if element skipping active */
   if (!self->useElementSkipping || !(self->flags[0] & AC_MPEGH3DA) ||
@@ -1134,11 +1134,11 @@ AAC_DECODER_ERROR applyUserInteractivity(HANDLE_AACDECODER self, PCM_DEC* pTimeD
   UCHAR maeIDobjGrp[((28) * 2)], maeIDobjIdx[((28) * 2)], objGrp;
   int grp, valid = 0, ch, streamIndex = 0;
 
-  FDKmemclear(channelGain, sizeof(channelGain));
-  FDKmemset(maeIDobjGrp, 255, ((28) * 2));
-  FDKmemclear(maeIDobjIdx, sizeof(maeIDobjIdx));
-  FDKmemclear(maeIDstartCh, sizeof(maeIDstartCh));
-  FDKmemclear(maeIDstopCh, sizeof(maeIDstopCh));
+  mpegh_FDKmemclear(channelGain, sizeof(channelGain));
+  mpegh_FDKmemset(maeIDobjGrp, 255, ((28) * 2));
+  mpegh_FDKmemclear(maeIDobjIdx, sizeof(maeIDobjIdx));
+  mpegh_FDKmemclear(maeIDstartCh, sizeof(maeIDstartCh));
+  mpegh_FDKmemclear(maeIDstopCh, sizeof(maeIDstopCh));
 
   /* generate lookup tables */
   objGrp = 0;
diff --git a/src/libMpeghUIMan/src/mpeghUIManager.cpp b/src/libMpeghUIMan/src/mpeghUIManager.cpp
index f838290..c250c3e 100644
--- a/src/libMpeghUIMan/src/mpeghUIManager.cpp
+++ b/src/libMpeghUIMan/src/mpeghUIManager.cpp
@@ -118,7 +118,7 @@ static UINT nextPow2(UINT x) {
 LINKSPEC_H HANDLE_MPEGH_UI_MANAGER mpegh_UI_Manager_Open(void) {
   HANDLE_MPEGH_UI_MANAGER self;
 
-  self = (HANDLE_MPEGH_UI_MANAGER)FDKcalloc(1, sizeof(MPEGH_UI_MANAGER));
+  self = (HANDLE_MPEGH_UI_MANAGER)mpegh_FDKcalloc(1, sizeof(MPEGH_UI_MANAGER));
 
   if (self) {
     if (UI_Manager_Create(&self->hUiManager, 1) != UI_MANAGER_OK) {
@@ -139,7 +139,7 @@ LINKSPEC_H void mpegh_UI_Manager_Close(HANDLE_MPEGH_UI_MANAGER self) {
     UI_Manager_Delete(&self->hUiManager);
   }
 
-  FDKfree(self);
+  mpegh_FDKfree(self);
 }
 
 /* get XML state */
@@ -595,7 +595,7 @@ LINKSPEC_H MPEGH_UI_ERROR mpegh_UI_UpdateMHAS(HANDLE_MPEGH_UI_MANAGER self, UCHA
   if (*mhasLength + nBytes > mhasBufferLength) return MPEGH_UI_BUFFER_TOO_SMALL;
 
   /* prepare writing of packets */
-  FDKmemmove(mhasBuffer + self->insertOffset + nBytes, mhasBuffer + self->insertOffset,
+  mpegh_FDKmemmove(mhasBuffer + self->insertOffset + nBytes, mhasBuffer + self->insertOffset,
              *mhasLength - self->insertOffset);
   FDKinitBitStream(hBs, mhasBuffer + self->insertOffset, nextPow2(nBytes), 0, BS_WRITER);
 
diff --git a/src/libPCMutils/include/pcm_utils.h b/src/libPCMutils/include/pcm_utils.h
index aa9961e..1bd5b22 100644
--- a/src/libPCMutils/include/pcm_utils.h
+++ b/src/libPCMutils/include/pcm_utils.h
@@ -93,7 +93,7 @@ amm-info@iis.fraunhofer.de
 
 #include "common_fix.h"
 
-void FDK_interleave(const FIXP_DBL* RESTRICT pIn, LONG* RESTRICT pOut, const UINT channels,
+void MPEGH_interleave(const FIXP_DBL* RESTRICT pIn, LONG* RESTRICT pOut, const UINT channels,
                     const UINT frameSize, const UINT length);
 
 #endif /* !defined(PCM_UTILS_H) */
diff --git a/src/libPCMutils/src/arm/pcm_utils_arm.cpp b/src/libPCMutils/src/arm/pcm_utils_arm.cpp
index 9cb87e3..8e9ce71 100644
--- a/src/libPCMutils/src/arm/pcm_utils_arm.cpp
+++ b/src/libPCMutils/src/arm/pcm_utils_arm.cpp
@@ -85,7 +85,7 @@ amm-info@iis.fraunhofer.de
    Author(s):   Arthur Tritthart, Fabian Bauer
 
    Description: Arm /Arm Neon Versions for
-                - FDK_interleave
+                - MPEGH_interleave
 
 *******************************************************************************/
 
@@ -262,7 +262,7 @@ FDK_label(FDK_interleave_DBL_LONG_end)
   FDK_ASM_ROUTINE_END()
 
 
-void FDK_interleave(
+void MPEGH_interleave(
       const FIXP_DBL  *RESTRICT pIn,
             LONG      *RESTRICT pOut,
             UINT                channels,
diff --git a/src/libPCMutils/src/limiter.cpp b/src/libPCMutils/src/limiter.cpp
index 4365eea..eae1041 100644
--- a/src/libPCMutils/src/limiter.cpp
+++ b/src/libPCMutils/src/limiter.cpp
@@ -115,12 +115,12 @@ TDLimiterPtr pcmLimiter_Create(unsigned int maxAttackMs, unsigned int releaseMs,
   release = (unsigned int)(releaseMs * maxSampleRate / 1000);
 
   /* alloc limiter struct */
-  limiter = (TDLimiterPtr)FDKcalloc(1, sizeof(struct TDLimiter));
+  limiter = (TDLimiterPtr)mpegh_FDKcalloc(1, sizeof(struct TDLimiter));
   if (!limiter) return NULL;
 
   /* alloc max and delay buffers */
-  limiter->maxBuf = (FIXP_DBL*)FDKcalloc(attack + 1, sizeof(FIXP_DBL));
-  limiter->delayBuf = (FIXP_DBL*)FDKcalloc(attack * maxChannels, sizeof(FIXP_DBL));
+  limiter->maxBuf = (FIXP_DBL*)mpegh_FDKcalloc(attack + 1, sizeof(FIXP_DBL));
+  limiter->delayBuf = (FIXP_DBL*)mpegh_FDKcalloc(attack * maxChannels, sizeof(FIXP_DBL));
 
   if (!limiter->maxBuf || !limiter->delayBuf) {
     pcmLimiter_Destroy(limiter);
@@ -185,8 +185,8 @@ TDLIMITER_ERROR pcmLimiter_Apply(TDLimiterPtr limiter, PCM_LIM* samplesIn, INT_P
     }
 
     if (limiter->scaling != scaling) {
-      scaleValuesSaturate(delayBuf, attack * channels, limiter->scaling - scaling);
-      scaleValuesSaturate(maxBuf, attack + 1, limiter->scaling - scaling);
+      mpegh_scaleValuesSaturate(delayBuf, attack * channels, limiter->scaling - scaling);
+      mpegh_scaleValuesSaturate(maxBuf, attack + 1, limiter->scaling - scaling);
       max = scaleValueSaturate(max, limiter->scaling - scaling);
       limiter->scaling = scaling;
     }
@@ -298,7 +298,7 @@ TDLIMITER_ERROR pcmLimiter_Apply(TDLimiterPtr limiter, PCM_LIM* samplesIn, INT_P
       delayTailCopyLength = fMin(delayTailLength, nSamples - delayHeadCopyLength);
 
 #if PCM_LIM_BITS == DFRACT_BITS
-      FDKmemcpy(delayBuf + delayBufIdx * channels, samplesIn + delayDirectCopyLength * channels,
+      mpegh_FDKmemcpy(delayBuf + delayBufIdx * channels, samplesIn + delayDirectCopyLength * channels,
                 delayHeadCopyLength * channels * sizeof(PCM_LIM));
 #else
       FIXP_DBL* p2Delay = delayBuf + delayBufIdx * channels;
@@ -309,7 +309,7 @@ TDLIMITER_ERROR pcmLimiter_Apply(TDLimiterPtr limiter, PCM_LIM* samplesIn, INT_P
 #endif
 
 #if PCM_LIM_BITS == DFRACT_BITS
-      FDKmemcpy(delayBuf, samplesIn + (delayDirectCopyLength + delayHeadCopyLength) * channels,
+      mpegh_FDKmemcpy(delayBuf, samplesIn + (delayDirectCopyLength + delayHeadCopyLength) * channels,
                 delayTailCopyLength * channels * sizeof(PCM_LIM));
 #else
       p2Delay = delayBuf;
@@ -330,7 +330,7 @@ TDLIMITER_ERROR pcmLimiter_Apply(TDLimiterPtr limiter, PCM_LIM* samplesIn, INT_P
         limiter->smoothState0 = FL2FXCONST_DBL(1.0f / (1 << 1));
         limiter->minGain = FL2FXCONST_DBL(1.0f / (1 << 1));
         limiter->previous_mode = 0; /* Set to simplified mode */
-        FDKmemset(limiter->maxBuf, 0, (limiter->attack + 1) * sizeof(FIXP_DBL));
+        mpegh_FDKmemset(limiter->maxBuf, 0, (limiter->attack + 1) * sizeof(FIXP_DBL));
       }
 
       /* Store the circular buffer pointer */
@@ -494,8 +494,8 @@ TDLIMITER_ERROR pcmLimiter_Reset(TDLimiterPtr limiter) {
     limiter->minGain = FL2FXCONST_DBL(1.0f / (1 << 1));
     limiter->scaling = 0;
 
-    FDKmemset(limiter->maxBuf, 0, (limiter->attack + 1) * sizeof(FIXP_DBL));
-    FDKmemset(limiter->delayBuf, 0, limiter->attack * limiter->channels * sizeof(FIXP_DBL));
+    mpegh_FDKmemset(limiter->maxBuf, 0, (limiter->attack + 1) * sizeof(FIXP_DBL));
+    mpegh_FDKmemset(limiter->delayBuf, 0, limiter->attack * limiter->channels * sizeof(FIXP_DBL));
   } else {
     return TDLIMIT_INVALID_HANDLE;
   }
@@ -506,10 +506,10 @@ TDLIMITER_ERROR pcmLimiter_Reset(TDLimiterPtr limiter) {
 /* destroy limiter */
 TDLIMITER_ERROR pcmLimiter_Destroy(TDLimiterPtr limiter) {
   if (limiter != NULL) {
-    FDKfree(limiter->maxBuf);
-    FDKfree(limiter->delayBuf);
+    mpegh_FDKfree(limiter->maxBuf);
+    mpegh_FDKfree(limiter->delayBuf);
 
-    FDKfree(limiter);
+    mpegh_FDKfree(limiter);
   } else {
     return TDLIMIT_INVALID_HANDLE;
   }
diff --git a/src/libPCMutils/src/pcm_utils.cpp b/src/libPCMutils/src/pcm_utils.cpp
index 9d4ed85..c58c347 100644
--- a/src/libPCMutils/src/pcm_utils.cpp
+++ b/src/libPCMutils/src/pcm_utils.cpp
@@ -95,7 +95,7 @@ amm-info@iis.fraunhofer.de
 #endif
 
 #ifndef FUNCTION_FDK_interleave_DBL_LONG
-void FDK_interleave(const FIXP_DBL* RESTRICT pIn, LONG* RESTRICT pOut, const UINT channels,
+void MPEGH_interleave(const FIXP_DBL* RESTRICT pIn, LONG* RESTRICT pOut, const UINT channels,
                     const UINT frameSize, const UINT length) {
   for (UINT ch = 0; ch < channels; ch++) {
     const FIXP_DBL* In = &pIn[ch * frameSize];
diff --git a/src/libSYS/src/cmdl_parser.cpp b/src/libSYS/src/cmdl_parser.cpp
index bef95e9..1de502a 100644
--- a/src/libSYS/src/cmdl_parser.cpp
+++ b/src/libSYS/src/cmdl_parser.cpp
@@ -114,8 +114,8 @@ static void GetNumberOfArgs(TEXTCHAR* str, INT* nArgs);
 
 static void removeQuotes(char* str) {
   if (str[0] == '"') {
-    FDKstrcpy(str, str + 1);
-    str[FDKstrlen(str) - 1] = 0;
+    mpegh_FDKstrcpy(str, str + 1);
+    str[mpegh_FDKstrlen(str) - 1] = 0;
   }
 }
 
@@ -134,7 +134,7 @@ INT IIS_ScanCmdl(INT argc, TEXTCHAR* argv[], const TEXTCHAR* str, ...) {
   va_list ap;
 
   if (argc == 0 || argc == 1) {
-    FDKprintf("No command line arguments\n");
+    mpegh_FDKprintf("No command line arguments\n");
     goto bail;
   }
 
@@ -142,7 +142,7 @@ INT IIS_ScanCmdl(INT argc, TEXTCHAR* argv[], const TEXTCHAR* str, ...) {
      because strlen() might read 4 bytes at a time. */
   str_clean = (TEXTCHAR*)calloc((unsigned int)_tcslen(str) + 3, sizeof(TEXTCHAR));
   if (str_clean == NULL) {
-    FDKprintf("Error allocating memory line %d, file %s\n", __LINE__, __FILE__);
+    mpegh_FDKprintf("Error allocating memory line %d, file %s\n", __LINE__, __FILE__);
     return 0;
   }
 
@@ -159,7 +159,7 @@ INT IIS_ScanCmdl(INT argc, TEXTCHAR* argv[], const TEXTCHAR* str, ...) {
   switches_used = (INT*)calloc(argc, sizeof(INT));
 
   if (b_str_opt == NULL || s_str == NULL || c_str_type == NULL || switches_used == NULL) {
-    FDKprintf("Error allocating memory line %d, file %s\n", __LINE__, __FILE__);
+    mpegh_FDKprintf("Error allocating memory line %d, file %s\n", __LINE__, __FILE__);
     goto bail;
   }
 
@@ -262,7 +262,7 @@ INT IIS_ScanCmdl(INT argc, TEXTCHAR* argv[], const TEXTCHAR* str, ...) {
       }
 
       default:
-        FDKprintfErr("warning: unsupported data identifier \"%c\"\n", c_str_type[i]);
+        mpegh_FDKprintfErr("warning: unsupported data identifier \"%c\"\n", c_str_type[i]);
         break;
     }
   }
@@ -462,30 +462,30 @@ extern "C" INT IIS_ProcessCmdlList(const TEXTCHAR* param_filename,
   char* line_ptr;
 
 #ifdef CMDFILE_PREFIX
-  FDKstrcpy(tmp, CMDFILE_PREFIX);
-  FDKstrcpy(tmp + FDKstrlen(CMDFILE_PREFIX), param_filename);
+  mpegh_FDKstrcpy(tmp, CMDFILE_PREFIX);
+  mpegh_FDKstrcpy(tmp + mpegh_FDKstrlen(CMDFILE_PREFIX), param_filename);
   /* Open the file with command lines */
-  config_fp = FDKfopen(tmp, "r");
+  config_fp = mpegh_FDKfopen(tmp, "r");
 #else
   /* Open the file with command lines */
-  config_fp = FDKfopen(param_filename, "r");
+  config_fp = mpegh_FDKfopen(param_filename, "r");
 #endif
 
   if (config_fp == NULL) {
 #ifdef CMDFILE_PREFIX
-    FDKprintf("\ncould not open config file %s", tmp);
+    mpegh_FDKprintf("\ncould not open config file %s", tmp);
 #else
-    FDKprintf("\ncould not open config file %s", param_filename);
+    mpegh_FDKprintf("\ncould not open config file %s", param_filename);
 #endif
     return 1;
   }
 
   /* Obtain a command line from config file */
-  while (FDKfgets(line, CMDL_MAX_STRLEN * CMDL_MAX_ARGC, config_fp) != NULL) {
+  while (mpegh_FDKfgets(line, CMDL_MAX_STRLEN * CMDL_MAX_ARGC, config_fp) != NULL) {
     argc = 1;
 
     /* Eat \n */
-    line_ptr = FDKstrchr(line, '\n');
+    line_ptr = mpegh_FDKstrchr(line, '\n');
     if (line_ptr != NULL) *line_ptr = ' ';
 
     line_ptr = line;
@@ -496,7 +496,7 @@ extern "C" INT IIS_ProcessCmdlList(const TEXTCHAR* param_filename,
       while (*line_ptr == ' ' && line_ptr < line + CMDL_MAX_STRLEN) line_ptr++;
       argv_ptr[argc] = line_ptr;
       /* Get pointer to next blank. */
-      line_ptr = FDKstrchr(line_ptr, ' ');
+      line_ptr = mpegh_FDKstrchr(line_ptr, ' ');
       /*  */
       if (line_ptr != NULL) {
         /* Null terminate */
@@ -510,7 +510,7 @@ extern "C" INT IIS_ProcessCmdlList(const TEXTCHAR* param_filename,
       if (argc == CMDL_MAX_ARGC && line_ptr != NULL) {
         /* Maximum number of argeuments haven been parsed,
            but there are still arguments in the line       */
-        FDKprintfErr(
+        mpegh_FDKprintfErr(
             "Error: Too many arguments. Please increase CMDL_MAX_ARGC if you need the encoder to "
             "read more arguments.\n");
         break;
@@ -518,16 +518,16 @@ extern "C" INT IIS_ProcessCmdlList(const TEXTCHAR* param_filename,
     } while (line_ptr != NULL);
 
     /* call "would be main()" */
-    if (argc > 2 && *argv_ptr[1] != '#' && FDKstrlen(argv_ptr[1]) > 1 &&
+    if (argc > 2 && *argv_ptr[1] != '#' && mpegh_FDKstrlen(argv_ptr[1]) > 1 &&
         !(argc == CMDL_MAX_ARGC && line_ptr != NULL)) {
       int retval;
 
       retval = (*pFunction)(argc, argv_ptr);
 
-      FDKprintf("main returned %d\n", retval);
+      mpegh_FDKprintf("main returned %d\n", retval);
     }
   }
 
-  FDKfclose(config_fp);
+  mpegh_FDKfclose(config_fp);
   return 0;
 }
diff --git a/src/libSYS/src/genericStds.cpp b/src/libSYS/src/genericStds.cpp
index aad4032..f6eb97e 100644
--- a/src/libSYS/src/genericStds.cpp
+++ b/src/libSYS/src/genericStds.cpp
@@ -136,25 +136,25 @@ INT FDKtolower(INT c) {
 #include <stdlib.h>
 #include <stdio.h>
 
-void FDKprintf(const char* szFmt, ...) {
+void mpegh_FDKprintf(const char* szFmt, ...) {
   va_list ap;
   va_start(ap, szFmt);
   vprintf(szFmt, ap);
   va_end(ap);
 }
 
-void FDKprintfErr(const char* szFmt, ...) {
+void mpegh_FDKprintfErr(const char* szFmt, ...) {
   va_list ap;
   va_start(ap, szFmt);
   vfprintf(stderr, szFmt, ap);
   va_end(ap);
 }
 
-INT FDKgetchar(void) {
+INT mpegh_FDKgetchar(void) {
   return (INT)getchar();
 }
 
-INT FDKfprintf(FDKFILE* stream, const char* format, ...) {
+INT mpegh_FDKfprintf(FDKFILE* stream, const char* format, ...) {
   INT chars = 0;
   va_list ap;
   va_start(ap, format);
@@ -167,16 +167,16 @@ INT FDKfprintf(FDKFILE* stream, const char* format, ...) {
 
 /************************************************************************************************/
 
-char* FDKstrchr(char* s, INT c) {
+char* mpegh_FDKstrchr(char* s, INT c) {
   return strchr(s, c);
 }
-const char* FDKstrstr(const char* haystack, const char* needle) {
+const char* mpegh_FDKstrstr(const char* haystack, const char* needle) {
   return strstr(haystack, needle);
 }
-char* FDKstrcpy(char* dest, const char* src) {
+char* mpegh_FDKstrcpy(char* dest, const char* src) {
   return strcpy(dest, src);
 }
-char* FDKstrncpy(char* dest, const char* src, UINT n) {
+char* mpegh_FDKstrncpy(char* dest, const char* src, UINT n) {
   return strncpy(dest, src, n);
 }
 
@@ -184,7 +184,7 @@ char* FDKstrncpy(char* dest, const char* src, UINT n) {
  * DYNAMIC MEMORY management (heap)
  *************************************************************************/
 
-void* FDKcalloc(const UINT n, const UINT size) {
+void* mpegh_FDKcalloc(const UINT n, const UINT size) {
   void* ptr;
 
   ptr = calloc(n, size);
@@ -192,7 +192,7 @@ void* FDKcalloc(const UINT n, const UINT size) {
   return ptr;
 }
 
-void* FDKmalloc(const UINT size) {
+void* mpegh_FDKmalloc(const UINT size) {
   void* ptr;
 
   ptr = malloc(size);
@@ -200,13 +200,13 @@ void* FDKmalloc(const UINT size) {
   return ptr;
 }
 
-void FDKfree(void* ptr) {
+void mpegh_FDKfree(void* ptr) {
   free((INT*)ptr);
 }
 
-void* FDKaalloc(const UINT size, const UINT alignment) {
+void* mpegh_FDKaalloc(const UINT size, const UINT alignment) {
   void *addr, *result = NULL;
-  addr = FDKcalloc(1, size + alignment + (UINT)sizeof(void*)); /* Malloc and clear memory. */
+  addr = mpegh_FDKcalloc(1, size + alignment + (UINT)sizeof(void*)); /* Malloc and clear memory. */
 
   if (addr != NULL) {
     result = ALIGN_PTR((unsigned char*)addr + sizeof(void*)); /* Get aligned memory base address. */
@@ -217,13 +217,13 @@ void* FDKaalloc(const UINT size, const UINT alignment) {
   return result; /* Return aligned address.          */
 }
 
-void FDKafree(void* ptr) {
+void mpegh_FDKafree(void* ptr) {
   void* addr;
   addr = *(((void**)ptr) - 1); /* Get pointer to malloc'ed memory. */
 
   C_ALLOC_ALIGNED_UNREGISTER(ptr);
 
-  FDKfree(addr); /* Free malloc'ed memory area.      */
+  mpegh_FDKfree(addr); /* Free malloc'ed memory area.      */
 }
 
 /*--------------------------------------------------------------------------*
@@ -231,19 +231,19 @@ void FDKafree(void* ptr) {
  *--------------------------------------------------------------------------*/
 
 /*--------------------------------------------------------------------------*
- * FDKcalloc_L
+ * mpegh_FDKcalloc_L
  *--------------------------------------------------------------------------*/
-void* FDKcalloc_L(const UINT dim, const UINT size, MEMORY_SECTION s) {
-  return FDKcalloc(dim, size);
+void* mpegh_FDKcalloc_L(const UINT dim, const UINT size, MEMORY_SECTION s) {
+  return mpegh_FDKcalloc(dim, size);
 }
 
-void FDKfree_L(void* p) {
-  FDKfree(p);
+void mpegh_FDKfree_L(void* p) {
+  mpegh_FDKfree(p);
 }
 
-void* FDKaalloc_L(const UINT size, const UINT alignment, MEMORY_SECTION s) {
+void* mpegh_FDKaalloc_L(const UINT size, const UINT alignment, MEMORY_SECTION s) {
   void *addr, *result = NULL;
-  addr = FDKcalloc_L(1, size + alignment + (UINT)sizeof(void*), s); /* Malloc and clear memory. */
+  addr = mpegh_FDKcalloc_L(1, size + alignment + (UINT)sizeof(void*), s); /* Malloc and clear memory. */
 
   if (addr != NULL) {
     result = ALIGN_PTR((unsigned char*)addr + sizeof(void*)); /* Get aligned memory base address. */
@@ -254,22 +254,22 @@ void* FDKaalloc_L(const UINT size, const UINT alignment, MEMORY_SECTION s) {
   return result; /* Return aligned address.          */
 }
 
-void FDKafree_L(void* ptr) {
+void mpegh_FDKafree_L(void* ptr) {
   void* addr;
 
   addr = *(((void**)ptr) - 1); /* Get pointer to malloc'ed memory. */
 
   C_ALLOC_ALIGNED_UNREGISTER(ptr);
 
-  FDKfree_L(addr); /* Free malloc'ed memory area.      */
+  mpegh_FDKfree_L(addr); /* Free malloc'ed memory area.      */
 }
 
 /*---------------------------------------------------------------------------------------
- * FUNCTION:    FDKmemcpy
+ * FUNCTION:    mpegh_FDKmemcpy
  * DESCRIPTION: - copies memory from "src" to "dst" with length "size" bytes
  *              - compiled with FDK_DEBUG will give you warnings
  *---------------------------------------------------------------------------------------*/
-void FDKmemcpy(void* dst, const void* src, const UINT size) {
+void mpegh_FDKmemcpy(void* dst, const void* src, const UINT size) {
   /* -- check for overlapping memory areas -- */
   FDK_ASSERT(((const unsigned char*)dst - (const unsigned char*)src) >= (ptrdiff_t)size ||
              ((const unsigned char*)src - (const unsigned char*)dst) >= (ptrdiff_t)size);
@@ -278,56 +278,56 @@ void FDKmemcpy(void* dst, const void* src, const UINT size) {
   memcpy(dst, src, size);
 }
 
-void FDKmemmove(void* dst, const void* src, const UINT size) {
+void mpegh_FDKmemmove(void* dst, const void* src, const UINT size) {
   memmove(dst, src, size);
 }
 
-void FDKmemset(void* memPtr, const INT value, const UINT size) {
+void mpegh_FDKmemset(void* memPtr, const INT value, const UINT size) {
   memset(memPtr, value, size);
 }
 
-void FDKmemclear(void* memPtr, const UINT size) {
-  FDKmemset(memPtr, 0, size);
+void mpegh_FDKmemclear(void* memPtr, const UINT size) {
+  mpegh_FDKmemset(memPtr, 0, size);
 }
 
-UINT FDKstrlen(const char* s) {
+UINT mpegh_FDKstrlen(const char* s) {
   return (UINT)strlen(s);
 }
 
 /* Compare function wrappers */
-INT FDKmemcmp(const void* s1, const void* s2, const UINT size) {
+INT mpegh_FDKmemcmp(const void* s1, const void* s2, const UINT size) {
   return memcmp(s1, s2, size);
 }
-INT FDKstrcmp(const char* s1, const char* s2) {
+INT mpegh_FDKstrcmp(const char* s1, const char* s2) {
   return strcmp(s1, s2);
 }
-INT FDKstrncmp(const char* s1, const char* s2, const UINT size) {
+INT mpegh_FDKstrncmp(const char* s1, const char* s2, const UINT size) {
   return strncmp(s1, s2, size);
 }
 
-int IS_LITTLE_ENDIAN(void) {
+int MPEGH_IS_LITTLE_ENDIAN(void) {
   int __dummy = 1;
   return (*((UCHAR*)(&(__dummy))));
 }
 
-UINT TO_LITTLE_ENDIAN(UINT val) {
-  return IS_LITTLE_ENDIAN() ? val
+UINT MPEGH_TO_LITTLE_ENDIAN(UINT val) {
+  return MPEGH_IS_LITTLE_ENDIAN() ? val
                             : (((val & 0xff) << 24) | ((val & 0xff00) << 8) |
                                ((val & 0xff0000) >> 8) | ((val & 0xff000000) >> 24));
 }
 
 /* ==================== FILE I/O ====================== */
 
-FDKFILE* FDKfopen(const char* filename, const char* mode) {
+FDKFILE* mpegh_FDKfopen(const char* filename, const char* mode) {
   return fopen(filename, mode);
 }
-INT FDKfclose(FDKFILE* fp) {
+INT mpegh_FDKfclose(FDKFILE* fp) {
   return fclose((FILE*)fp);
 }
-INT FDKfseek(FDKFILE* fp, LONG OFFSET, int WHENCE) {
+INT mpegh_FDKfseek(FDKFILE* fp, LONG OFFSET, int WHENCE) {
   return fseek((FILE*)fp, OFFSET, WHENCE);
 }
-INT FDKftell(FDKFILE* fp) {
+INT mpegh_FDKftell(FDKFILE* fp) {
   return (INT)ftell((FILE*)fp);
 }
 #if !defined(FUNCTION_FDKfseek64)
@@ -335,7 +335,7 @@ INT FDKfseek64(FDKFILE* fp, INT64 OFFSET, int WHENCE) {
   INT err;
   err = fseek((FILE*)fp, OFFSET, WHENCE);
   if (err) {
-    FDKprintfErr("Error: FDKfseek64() = %x\n", err);
+    mpegh_FDKprintfErr("Error: FDKfseek64() = %x\n", err);
   }
   return err;
 }
@@ -345,34 +345,34 @@ INT64 FDKftell64(FDKFILE* fp) {
   INT64 pos;
   pos = ftell((FILE*)fp);
   if (pos == -1L) {
-    FDKprintfErr("Error: FDKftell64() returns invalid file position indicator.\n");
+    mpegh_FDKprintfErr("Error: FDKftell64() returns invalid file position indicator.\n");
   }
   return pos;
 }
 #endif
-INT FDKfflush(FDKFILE* fp) {
+INT mpegh_FDKfflush(FDKFILE* fp) {
   return fflush((FILE*)fp);
 }
-const INT FDKSEEK_SET = SEEK_SET;
-const INT FDKSEEK_CUR = SEEK_CUR;
-const INT FDKSEEK_END = SEEK_END;
+const INT MPEGH_FDKSEEK_SET = SEEK_SET;
+const INT MPEGH_FDKSEEK_CUR = SEEK_CUR;
+const INT MPEGH_FDKSEEK_END = SEEK_END;
 
-UINT FDKfwrite(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp) {
+UINT mpegh_FDKfwrite(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp) {
   return (UINT)fwrite(ptrf, size, nmemb, (FILE*)fp);
 }
-UINT FDKfread(void* dst, INT size, UINT nmemb, FDKFILE* fp) {
+UINT mpegh_FDKfread(void* dst, INT size, UINT nmemb, FDKFILE* fp) {
   return (UINT)fread(dst, size, nmemb, (FILE*)fp);
 }
-char* FDKfgets(void* dst, INT size, FDKFILE* fp) {
+char* mpegh_FDKfgets(void* dst, INT size, FDKFILE* fp) {
   return fgets((char*)dst, size, (FILE*)fp);
 }
-void FDKrewind(FDKFILE* fp) {
-  FDKfseek((FILE*)fp, 0, FDKSEEK_SET);
+void mpegh_FDKrewind(FDKFILE* fp) {
+  mpegh_FDKfseek((FILE*)fp, 0, MPEGH_FDKSEEK_SET);
 }
 
-UINT FDKfwrite_EL(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp) {
-  if (IS_LITTLE_ENDIAN()) {
-    FDKfwrite(ptrf, size, nmemb, fp);
+UINT mpegh_FDKfwrite_EL(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp) {
+  if (MPEGH_IS_LITTLE_ENDIAN()) {
+    mpegh_FDKfwrite(ptrf, size, nmemb, fp);
   } else {
     UINT n;
     INT s;
@@ -381,7 +381,7 @@ UINT FDKfwrite_EL(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp) {
 
     for (n = 0; n < nmemb; n++) {
       for (s = size - 1; s >= 0; s--) {
-        FDKfwrite(ptr + s, 1, 1, fp);
+        mpegh_FDKfwrite(ptr + s, 1, 1, fp);
       }
       ptr = ptr + size;
     }
@@ -389,7 +389,7 @@ UINT FDKfwrite_EL(const void* ptrf, INT size, UINT nmemb, FDKFILE* fp) {
   return nmemb;
 }
 
-UINT FDKfread_EL(void* dst, INT size, UINT nmemb, FDKFILE* fp) {
+UINT mpegh_FDKfread_EL(void* dst, INT size, UINT nmemb, FDKFILE* fp) {
   UINT n, s0, s1, err;
   UCHAR tmp, *ptr;
   UCHAR tmp24[3];
@@ -398,7 +398,7 @@ UINT FDKfread_EL(void* dst, INT size, UINT nmemb, FDKFILE* fp) {
   if (size == 3) {
     ptr = (UCHAR*)dst;
     for (n = 0; n < nmemb; n++) {
-      if ((err = FDKfread(tmp24, 1, 3, fp)) != 3) {
+      if ((err = mpegh_FDKfread(tmp24, 1, 3, fp)) != 3) {
         return err;
       }
       *ptr++ = tmp24[0];
@@ -414,11 +414,11 @@ UINT FDKfread_EL(void* dst, INT size, UINT nmemb, FDKFILE* fp) {
     err = nmemb;
     size = sizeof(LONG);
   } else {
-    if ((err = FDKfread(dst, size, nmemb, fp)) != nmemb) {
+    if ((err = mpegh_FDKfread(dst, size, nmemb, fp)) != nmemb) {
       return err;
     }
   }
-  if (!IS_LITTLE_ENDIAN() && size > 1) {
+  if (!MPEGH_IS_LITTLE_ENDIAN() && size > 1) {
     ptr = (UCHAR*)dst;
     for (n = 0; n < nmemb; n++) {
       for (s0 = 0, s1 = size - 1; s0 < s1; s0++, s1--) {
@@ -432,6 +432,6 @@ UINT FDKfread_EL(void* dst, INT size, UINT nmemb, FDKFILE* fp) {
   return err;
 }
 
-INT FDKfeof(FDKFILE* fp) {
+INT mpegh_FDKfeof(FDKFILE* fp) {
   return feof((FILE*)fp);
 }
diff --git a/src/libSYS/src/wav_file.cpp b/src/libSYS/src/wav_file.cpp
index 9da6b80..d64e5bb 100644
--- a/src/libSYS/src/wav_file.cpp
+++ b/src/libSYS/src/wav_file.cpp
@@ -108,103 +108,103 @@ INT WAV_InputOpen(HANDLE_WAV* pWav, const char* filename) {
   INT offset;
 
   if (wav == NULL) {
-    FDKprintfErr("WAV_InputOpen(): Unable to allocate WAV struct.\n");
+    mpegh_FDKprintfErr("WAV_InputOpen(): Unable to allocate WAV struct.\n");
     goto error;
   }
 
-  wav->fp = FDKfopen(filename, "rb");
+  wav->fp = mpegh_FDKfopen(filename, "rb");
   if (wav->fp == NULL) {
-    FDKprintfErr("WAV_InputOpen(): Unable to open wav file. %s\n", filename);
+    mpegh_FDKprintfErr("WAV_InputOpen(): Unable to open wav file. %s\n", filename);
     goto error;
   }
 
   /* read RIFF-chunk */
-  if (FDKfread(&(wav->header.riffType), 1, 4, wav->fp) != 4) {
-    FDKprintfErr("WAV_InputOpen(): couldn't read RIFF_ID\n");
+  if (mpegh_FDKfread(&(wav->header.riffType), 1, 4, wav->fp) != 4) {
+    mpegh_FDKprintfErr("WAV_InputOpen(): couldn't read RIFF_ID\n");
     goto error; /* bad error "couldn't read RIFF_ID" */
   }
-  if (FDKstrncmp("RIFF", wav->header.riffType, 4) && FDKstrncmp("RF64", wav->header.riffType, 4)) {
-    FDKprintfErr("WAV_InputOpen(): RIFF or RF64 descriptor not found.\n");
+  if (mpegh_FDKstrncmp("RIFF", wav->header.riffType, 4) && mpegh_FDKstrncmp("RF64", wav->header.riffType, 4)) {
+    mpegh_FDKprintfErr("WAV_InputOpen(): RIFF or RF64 descriptor not found.\n");
     goto error;
   }
 
   /* Read RIFF size. Ignored. */
-  FDKfread_EL(&(wav->header.riffSize), 4, 1, wav->fp);
+  mpegh_FDKfread_EL(&(wav->header.riffSize), 4, 1, wav->fp);
 
   /* read WAVE-chunk */
-  if (FDKfread(&wav->header.waveType, 1, 4, wav->fp) != 4) {
-    FDKprintfErr("WAV_InputOpen(): couldn't read format\n");
+  if (mpegh_FDKfread(&wav->header.waveType, 1, 4, wav->fp) != 4) {
+    mpegh_FDKprintfErr("WAV_InputOpen(): couldn't read format\n");
     goto error; /* bad error "couldn't read format" */
   }
-  if (FDKstrncmp("WAVE", wav->header.waveType, 4)) {
-    FDKprintfErr("WAV_InputOpen(): WAVE chunk ID not found.\n");
+  if (mpegh_FDKstrncmp("WAVE", wav->header.waveType, 4)) {
+    mpegh_FDKprintfErr("WAV_InputOpen(): WAVE chunk ID not found.\n");
     goto error;
   }
 
   /* use ds64 */
-  if (FDKstrncmp("RF64", wav->header.riffType, 4) == 0 && (wav->header.riffSize >= 0xFFFFFFFF)) {
-    if (FDKfread(&(wav->header.ds64Chunk.chunkID), 1, 4, wav->fp) != 4) {
-      FDKprintfErr("WAV_InputOpen(): DS64 descriptor not found.\n");
+  if (mpegh_FDKstrncmp("RF64", wav->header.riffType, 4) == 0 && (wav->header.riffSize >= 0xFFFFFFFF)) {
+    if (mpegh_FDKfread(&(wav->header.ds64Chunk.chunkID), 1, 4, wav->fp) != 4) {
+      mpegh_FDKprintfErr("WAV_InputOpen(): DS64 descriptor not found.\n");
       goto error;
     }
-    FDKfread_EL(&(wav->header.ds64Chunk.chunkSize), 4, 1, wav->fp);
-    FDKfread_EL(&(wav->header.ds64Chunk.riffSize64), 8, 1, wav->fp);
-    FDKfread_EL(&(wav->header.ds64Chunk.dataSize64), 8, 1, wav->fp);
-    FDKfread_EL(&(wav->header.ds64Chunk.samplesPerCh64), 8, 1, wav->fp);
-    FDKfread_EL(&(wav->header.ds64Chunk.tableLength), 4, 1, wav->fp);
+    mpegh_FDKfread_EL(&(wav->header.ds64Chunk.chunkSize), 4, 1, wav->fp);
+    mpegh_FDKfread_EL(&(wav->header.ds64Chunk.riffSize64), 8, 1, wav->fp);
+    mpegh_FDKfread_EL(&(wav->header.ds64Chunk.dataSize64), 8, 1, wav->fp);
+    mpegh_FDKfread_EL(&(wav->header.ds64Chunk.samplesPerCh64), 8, 1, wav->fp);
+    mpegh_FDKfread_EL(&(wav->header.ds64Chunk.tableLength), 4, 1, wav->fp);
   }
 
   /* read format-chunk */
   while (1) {
-    if (FDKfread(&(wav->header.formatType), 1, 4, wav->fp) != 4) {
-      FDKprintfErr("WAV_InputOpen(): couldn't read format_ID\n");
+    if (mpegh_FDKfread(&(wav->header.formatType), 1, 4, wav->fp) != 4) {
+      mpegh_FDKprintfErr("WAV_InputOpen(): couldn't read format_ID\n");
       goto error; /* bad error "couldn't read format_ID" */
     }
 
-    if (FDKstrncmp("fmt", wav->header.formatType, 3)) {
+    if (mpegh_FDKstrncmp("fmt", wav->header.formatType, 3)) {
       /* skip non fmt chunks */
       UINT chunkSize = 0;
-      FDKfread_EL(&chunkSize, 4, 1, wav->fp);
-      FDKfseek(wav->fp, chunkSize, FDKSEEK_CUR);
+      mpegh_FDKfread_EL(&chunkSize, 4, 1, wav->fp);
+      mpegh_FDKfseek(wav->fp, chunkSize, MPEGH_FDKSEEK_CUR);
     } else {
       break;
     }
   }
 
-  FDKfread_EL(&wav->header.formatSize, 4, 1,
+  mpegh_FDKfread_EL(&wav->header.formatSize, 4, 1,
               wav->fp); /* should be 16 for PCM-format (uncompressed) */
 
   /* read  info */
-  FDKfread_EL(&(wav->header.compressionCode), 2, 1, wav->fp);
+  mpegh_FDKfread_EL(&(wav->header.compressionCode), 2, 1, wav->fp);
   if ((wav->header.compressionCode != 0x0001) && (wav->header.compressionCode != 0x0003) &&
       (wav->header.compressionCode != 0xFFFE)) {
-    FDKprintfErr("WAV_InputOpen(): PCM-format (uncompressed) or extensible-format expected.\n");
+    mpegh_FDKprintfErr("WAV_InputOpen(): PCM-format (uncompressed) or extensible-format expected.\n");
     goto error;
   }
-  FDKfread_EL(&(wav->header.numChannels), 2, 1, wav->fp);
-  FDKfread_EL(&(wav->header.sampleRate), 4, 1, wav->fp);
-  FDKfread_EL(&(wav->header.bytesPerSecond), 4, 1, wav->fp);
-  FDKfread_EL(&(wav->header.blockAlign), 2, 1, wav->fp);
-  FDKfread_EL(&(wav->header.bitsPerSample), 2, 1, wav->fp);
+  mpegh_FDKfread_EL(&(wav->header.numChannels), 2, 1, wav->fp);
+  mpegh_FDKfread_EL(&(wav->header.sampleRate), 4, 1, wav->fp);
+  mpegh_FDKfread_EL(&(wav->header.bytesPerSecond), 4, 1, wav->fp);
+  mpegh_FDKfread_EL(&(wav->header.blockAlign), 2, 1, wav->fp);
+  mpegh_FDKfread_EL(&(wav->header.bitsPerSample), 2, 1, wav->fp);
   if ((wav->header.compressionCode == 0x0001) &&
       ((wav->header.bitsPerSample != 8) && (wav->header.bitsPerSample != 12) &&
        (wav->header.bitsPerSample != 16) && (wav->header.bitsPerSample != 24) &&
        (wav->header.bitsPerSample != 32))) {
-    FDKprintfErr(
+    mpegh_FDKprintfErr(
         "WAV_InputOpen(): invalid value with given PCM-format (PCM) for bits per sample.\n");
     goto error;
   }
   if ((wav->header.compressionCode == 0x0003) && (wav->header.bitsPerSample != 32)) {
-    FDKprintfErr(
+    mpegh_FDKprintfErr(
         "WAV_InputOpen(): invalid value with given PCM-format (float) for bits per sample.\n");
     goto error;
   }
   if (wav->header.blockAlign != (wav->header.numChannels * ((wav->header.bitsPerSample + 7) / 8))) {
-    FDKprintfErr("WAV_InputOpen(): invalid value for frame size.\n");
+    mpegh_FDKprintfErr("WAV_InputOpen(): invalid value for frame size.\n");
     goto error;
   }
   if (wav->header.bytesPerSecond != (wav->header.blockAlign * wav->header.sampleRate)) {
-    FDKprintfErr("WAV_InputOpen(): invalid value for bytes per second.\n");
+    mpegh_FDKprintfErr("WAV_InputOpen(): invalid value for bytes per second.\n");
     goto error;
   }
 
@@ -219,13 +219,13 @@ INT WAV_InputOpen(HANDLE_WAV* pWav, const char* filename) {
     INT i;
 
     /* read extra bytes */
-    FDKfread_EL(&(extraFormatBytes), 2, 1, wav->fp);
+    mpegh_FDKfread_EL(&(extraFormatBytes), 2, 1, wav->fp);
     offset -= 2;
 
     if (extraFormatBytes >= 22) {
-      FDKfread_EL(&(validBitsPerSample), 2, 1, wav->fp);
-      FDKfread_EL(&(wav->channelMask), 4, 1, wav->fp);
-      FDKfread_EL(&(guid), 16, 1, wav->fp);
+      mpegh_FDKfread_EL(&(validBitsPerSample), 2, 1, wav->fp);
+      mpegh_FDKfread_EL(&(wav->channelMask), 4, 1, wav->fp);
+      mpegh_FDKfread_EL(&(guid), 16, 1, wav->fp);
 
       /* check for PCM GUID */
       for (i = 1; i < 16; i++)
@@ -241,30 +241,30 @@ INT WAV_InputOpen(HANDLE_WAV* pWav, const char* filename) {
 
   /* Skip rest of fmt header if any. */
   for (; offset > 0; offset--) {
-    FDKfread(&wav->header.formatSize, 1, 1, wav->fp);
+    mpegh_FDKfread(&wav->header.formatSize, 1, 1, wav->fp);
   }
 
   do {
     /* Read data chunk ID */
-    if (FDKfread(wav->header.dataType, 1, 4, wav->fp) != 4) {
-      FDKprintfErr("WAV_InputOpen(): Unable to read data chunk ID.\n");
+    if (mpegh_FDKfread(wav->header.dataType, 1, 4, wav->fp) != 4) {
+      mpegh_FDKprintfErr("WAV_InputOpen(): Unable to read data chunk ID.\n");
       goto error;
     }
 
     /* Read chunk length. */
-    FDKfread_EL(&offset, 4, 1, wav->fp);
+    mpegh_FDKfread_EL(&offset, 4, 1, wav->fp);
 
     /* Check for data chunk signature. */
-    if (FDKstrncmp("data", wav->header.dataType, 4) == 0) {
+    if (mpegh_FDKstrncmp("data", wav->header.dataType, 4) == 0) {
       wav->header.dataSize = offset;
-      wav->headerSize = FDKftell(wav->fp);
+      wav->headerSize = mpegh_FDKftell(wav->fp);
       break;
     }
     /* Jump over non data chunk. */
     for (; offset > 0; offset--) {
-      FDKfread(&(wav->header.dataSize), 1, 1, wav->fp);
+      mpegh_FDKfread(&(wav->header.dataSize), 1, 1, wav->fp);
     }
-  } while (!FDKfeof(wav->fp));
+  } while (!mpegh_FDKfeof(wav->fp));
 
   /* return success */
   *pWav = wav;
@@ -275,7 +275,7 @@ INT WAV_InputOpen(HANDLE_WAV* pWav, const char* filename) {
 
   if (wav) {
     if (wav->fp) {
-      FDKfclose(wav->fp);
+      mpegh_FDKfclose(wav->fp);
       wav->fp = NULL;
     }
     free(wav);
@@ -311,7 +311,7 @@ INT WAV_InputRead(HANDLE_WAV wav, void* buffer, UINT numSamples, int nBits) {
   double* dptr = (double*)buffer;
 
   /* read until end of audio only, ignore possibly following non-audio data */
-  if (FDKstrncmp("RF64", wav->header.riffType, 4) == 0) {
+  if (mpegh_FDKstrncmp("RF64", wav->header.riffType, 4) == 0) {
     if ((UINT64)(FDKftell64(wav->fp) + (wav->header.bitsPerSample >> 3) * numSamples) >
         wav->headerSize + wav->header.ds64Chunk.dataSize64) {
       if ((UINT64)FDKftell64(wav->fp) < wav->headerSize + wav->header.ds64Chunk.dataSize64) {
@@ -323,10 +323,10 @@ INT WAV_InputRead(HANDLE_WAV wav, void* buffer, UINT numSamples, int nBits) {
       }
     }
   } else {
-    if (FDKftell(wav->fp) + (wav->header.bitsPerSample >> 3) * numSamples >
+    if (mpegh_FDKftell(wav->fp) + (wav->header.bitsPerSample >> 3) * numSamples >
         wav->headerSize + wav->header.dataSize) {
-      if ((UINT)FDKftell(wav->fp) < wav->headerSize + wav->header.dataSize) {
-        numSamples = (wav->headerSize + wav->header.dataSize - FDKftell(wav->fp)) /
+      if ((UINT)mpegh_FDKftell(wav->fp) < wav->headerSize + wav->header.dataSize) {
+        numSamples = (wav->headerSize + wav->header.dataSize - mpegh_FDKftell(wav->fp)) /
                      (wav->header.bitsPerSample >> 3);
       } else {
         numSamples = 0;
@@ -337,15 +337,15 @@ INT WAV_InputRead(HANDLE_WAV wav, void* buffer, UINT numSamples, int nBits) {
   switch (wav->header.compressionCode) {
     case 0x01: /* PCM uncompressed */
       if (nBits == wav->header.bitsPerSample) {
-        result = FDKfread_EL(buffer, wav->header.bitsPerSample >> 3, numSamples, wav->fp);
+        result = mpegh_FDKfread_EL(buffer, wav->header.bitsPerSample >> 3, numSamples, wav->fp);
       } else {
         result = 0;
         for (i = 0; i < numSamples; i++) {
           LONG tmp = 0;
-          result += FDKfread_EL(&tmp, wav->header.bitsPerSample >> 3, 1, wav->fp);
+          result += mpegh_FDKfread_EL(&tmp, wav->header.bitsPerSample >> 3, 1, wav->fp);
 
           /* Move read bits to lower bits of LONG. */
-          if (!IS_LITTLE_ENDIAN() && wav->header.bitsPerSample != 24 &&
+          if (!MPEGH_IS_LITTLE_ENDIAN() && wav->header.bitsPerSample != 24 &&
               wav->header.bitsPerSample < 32) {
             tmp >>= (32 - wav->header.bitsPerSample);
           }
@@ -371,13 +371,13 @@ INT WAV_InputRead(HANDLE_WAV wav, void* buffer, UINT numSamples, int nBits) {
 
     case 0x03: /* IEEE float */
       if ((wav->header.bitsPerSample != 32) && (wav->header.bitsPerSample != 64)) {
-        FDKprintf("WAV_InputRead(): unsupported format!!");
+        mpegh_FDKprintf("WAV_InputRead(): unsupported format!!");
         break;
       }
 
       if (((nBits == NBITS_FLOAT) && (wav->header.bitsPerSample == 32)) ||
           ((nBits == NBITS_DOUBLE) && (wav->header.bitsPerSample == 64))) {
-        result = FDKfread_EL(buffer, wav->header.bitsPerSample >> 3, numSamples, wav->fp);
+        result = mpegh_FDKfread_EL(buffer, wav->header.bitsPerSample >> 3, numSamples, wav->fp);
       } else {
         result = 0;
         for (i = 0; i < numSamples; i++) {
@@ -385,10 +385,10 @@ INT WAV_InputRead(HANDLE_WAV wav, void* buffer, UINT numSamples, int nBits) {
 
           if (wav->header.bitsPerSample == 32) {
             float f = 0;
-            result += FDKfread_EL(&f, 4, 1, wav->fp);
+            result += mpegh_FDKfread_EL(&f, 4, 1, wav->fp);
             tmp = (double)f;
           } else {
-            result += FDKfread_EL(&tmp, 8, 1, wav->fp);
+            result += mpegh_FDKfread_EL(&tmp, 8, 1, wav->fp);
           }
 
           if (nBits == NBITS_FLOAT) {
@@ -428,13 +428,13 @@ INT WAV_InputRead(HANDLE_WAV wav, void* buffer, UINT numSamples, int nBits) {
 
     case 0x07: /* u-Law compression */
       for (i = 0; i < numSamples; i++) {
-        result += FDKfread(&(bptr[i << 1]), 1, 1, wav->fp);
+        result += mpegh_FDKfread(&(bptr[i << 1]), 1, 1, wav->fp);
         sptr[i] = (SHORT)ulaw2pcm(bptr[i << 1]);
       }
       break;
 
     default:
-      FDKprintf("WAV_InputRead(): unsupported data-compression!!");
+      mpegh_FDKprintf("WAV_InputRead(): unsupported data-compression!!");
       break;
   }
   return result;
@@ -445,7 +445,7 @@ void WAV_InputClose(HANDLE_WAV* pWav) {
 
   if (wav != NULL) {
     if (wav->fp != NULL) {
-      FDKfclose(wav->fp);
+      mpegh_FDKfclose(wav->fp);
       wav->fp = NULL;
     }
     free(wav);
@@ -472,7 +472,7 @@ static INT_PCM ulaw2pcm(UCHAR ulawbyte) {
 /************** Writer ***********************/
 
 static UINT64 LittleEndian64(UINT64 v) {
-  if (IS_LITTLE_ENDIAN())
+  if (MPEGH_IS_LITTLE_ENDIAN())
     return v;
   else
     return (v & 0x00000000000000FFLL) << 56 | (v & 0x000000000000FF00LL) << 40 |
@@ -482,7 +482,7 @@ static UINT64 LittleEndian64(UINT64 v) {
 }
 
 static UINT LittleEndian32(UINT v) {
-  if (IS_LITTLE_ENDIAN())
+  if (MPEGH_IS_LITTLE_ENDIAN())
     return v;
   else
     return (v & 0x000000FF) << 24 | (v & 0x0000FF00) << 8 | (v & 0x00FF0000) >> 8 |
@@ -490,14 +490,14 @@ static UINT LittleEndian32(UINT v) {
 }
 
 static SHORT LittleEndian16(SHORT v) {
-  if (IS_LITTLE_ENDIAN())
+  if (MPEGH_IS_LITTLE_ENDIAN())
     return v;
   else
     return (SHORT)(((v << 8) & 0xFF00) | ((v >> 8) & 0x00FF));
 }
 
 static USHORT Unpack(USHORT v) {
-  if (IS_LITTLE_ENDIAN())
+  if (MPEGH_IS_LITTLE_ENDIAN())
     return v;
   else
     return (SHORT)(((v << 8) & 0xFF00) | ((v >> 8) & 0x00FF));
@@ -506,43 +506,43 @@ static USHORT Unpack(USHORT v) {
 UINT WAV_WriteHeader(HANDLE_WAV wav) {
   UINT size = 0;
 
-  size += (FDKfwrite_EL(&wav->header.riffType, 1, 4, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.riffType, 1, 4, wav->fp)) *
           sizeof(wav->header.riffType[0]);  // RIFF Type
-  size += (FDKfwrite_EL(&wav->header.riffSize, 4, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.riffSize, 4, 1, wav->fp)) *
           sizeof(wav->header.riffSize);  // RIFF Size
-  size += (FDKfwrite_EL(&wav->header.waveType, 1, 4, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.waveType, 1, 4, wav->fp)) *
           sizeof(wav->header.waveType[0]);  // WAVE Type
-  size += (FDKfwrite_EL(&wav->header.ds64Chunk.chunkID, 1, 4, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.ds64Chunk.chunkID, 1, 4, wav->fp)) *
           sizeof(wav->header.ds64Chunk.chunkID[0]);  // JUNK/RF64 Type
-  size += (FDKfwrite_EL(&wav->header.ds64Chunk.chunkSize, 4, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.ds64Chunk.chunkSize, 4, 1, wav->fp)) *
           sizeof(wav->header.ds64Chunk.chunkSize);  // JUNK/RF64 Size
-  size += (FDKfwrite_EL(&wav->header.ds64Chunk.riffSize64, 8, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.ds64Chunk.riffSize64, 8, 1, wav->fp)) *
           sizeof(wav->header.ds64Chunk.riffSize64);  // Riff Size (64 bit)
-  size += (FDKfwrite_EL(&wav->header.ds64Chunk.dataSize64, 8, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.ds64Chunk.dataSize64, 8, 1, wav->fp)) *
           sizeof(wav->header.ds64Chunk.dataSize64);  // Data Size (64 bit)
-  size += (FDKfwrite_EL(&wav->header.ds64Chunk.samplesPerCh64, 8, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.ds64Chunk.samplesPerCh64, 8, 1, wav->fp)) *
           sizeof(wav->header.ds64Chunk.samplesPerCh64);  // Number of Samples
-  size += (FDKfwrite_EL(&wav->header.ds64Chunk.tableLength, 4, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.ds64Chunk.tableLength, 4, 1, wav->fp)) *
           sizeof(wav->header.ds64Chunk.tableLength);  // Number of valid entries in array table
-  size += (FDKfwrite_EL(&wav->header.formatType, 1, 4, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.formatType, 1, 4, wav->fp)) *
           sizeof(wav->header.formatType[0]);  // format Type
-  size += (FDKfwrite_EL(&wav->header.formatSize, 4, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.formatSize, 4, 1, wav->fp)) *
           sizeof(wav->header.formatSize);  // format Size
-  size += (FDKfwrite_EL(&wav->header.compressionCode, 2, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.compressionCode, 2, 1, wav->fp)) *
           sizeof(wav->header.compressionCode);  // compression Code
-  size += (FDKfwrite_EL(&wav->header.numChannels, 2, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.numChannels, 2, 1, wav->fp)) *
           sizeof(wav->header.numChannels);  // numChannels
-  size += (FDKfwrite_EL(&wav->header.sampleRate, 4, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.sampleRate, 4, 1, wav->fp)) *
           sizeof(wav->header.sampleRate);  // sampleRate
-  size += (FDKfwrite_EL(&wav->header.bytesPerSecond, 4, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.bytesPerSecond, 4, 1, wav->fp)) *
           sizeof(wav->header.bytesPerSecond);  // bytesPerSecond
-  size += (FDKfwrite_EL(&wav->header.blockAlign, 2, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.blockAlign, 2, 1, wav->fp)) *
           sizeof(wav->header.blockAlign);  // blockAlign
-  size += (FDKfwrite_EL(&wav->header.bitsPerSample, 2, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.bitsPerSample, 2, 1, wav->fp)) *
           sizeof(wav->header.bitsPerSample);  // bitsPerSample
-  size += (FDKfwrite_EL(&wav->header.dataType, 1, 4, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.dataType, 1, 4, wav->fp)) *
           sizeof(wav->header.dataType[0]);  // dataType
-  size += (FDKfwrite_EL(&wav->header.dataSize, 4, 1, wav->fp)) *
+  size += (mpegh_FDKfwrite_EL(&wav->header.dataSize, 4, 1, wav->fp)) *
           sizeof(wav->header.dataSize);  // dataSize
 
   return size;
@@ -565,36 +565,36 @@ INT WAV_OutputOpen(HANDLE_WAV* pWav, const char* outputFilename, INT sampleRate,
   UINT size = 0;
 
   if (wav == NULL) {
-    FDKprintfErr("WAV_OutputOpen(): Unable to allocate WAV struct.\n");
+    mpegh_FDKprintfErr("WAV_OutputOpen(): Unable to allocate WAV struct.\n");
     goto bail;
   }
 
   if (bitsPerSample != 16 && bitsPerSample != 24 && bitsPerSample != 32 &&
       bitsPerSample != NBITS_FLOAT && bitsPerSample != NBITS_DOUBLE) {
-    FDKprintfErr("WAV_OutputOpen(): Invalid argument (bitsPerSample).\n");
+    mpegh_FDKprintfErr("WAV_OutputOpen(): Invalid argument (bitsPerSample).\n");
     goto bail;
   }
 
-  wav->fp = FDKfopen(outputFilename, "wb");
+  wav->fp = mpegh_FDKfopen(outputFilename, "wb");
   if (wav->fp == NULL) {
-    FDKprintfErr("WAV_OutputOpen(): unable to create file %s\n", outputFilename);
+    mpegh_FDKprintfErr("WAV_OutputOpen(): unable to create file %s\n", outputFilename);
     goto bail;
   }
 
-  FDKstrncpy(wav->header.riffType, "RIFF", 4);
+  mpegh_FDKstrncpy(wav->header.riffType, "RIFF", 4);
   wav->header.riffSize =
       LittleEndian32(0x7fffffff); /* in case fseek() doesn't work later in WAV_OutputClose() */
-  FDKstrncpy(wav->header.waveType, "WAVE", 4);
+  mpegh_FDKstrncpy(wav->header.waveType, "WAVE", 4);
 
   /* Create 'JUNK' chunk for possible transition to RF64  */
-  FDKstrncpy(wav->header.ds64Chunk.chunkID, "JUNK", 4);
+  mpegh_FDKstrncpy(wav->header.ds64Chunk.chunkID, "JUNK", 4);
   wav->header.ds64Chunk.chunkSize = LittleEndian32(28);
   wav->header.ds64Chunk.riffSize64 = LittleEndian64(0);
   wav->header.ds64Chunk.dataSize64 = LittleEndian64(0);
   wav->header.ds64Chunk.samplesPerCh64 = LittleEndian64(0);
   wav->header.ds64Chunk.tableLength = LittleEndian32(0);
 
-  FDKstrncpy(wav->header.formatType, "fmt ", 4);
+  mpegh_FDKstrncpy(wav->header.formatType, "fmt ", 4);
   wav->header.formatSize = LittleEndian32(16);
 
   wav->header.compressionCode = LittleEndian16(0x01);
@@ -613,14 +613,14 @@ INT WAV_OutputOpen(HANDLE_WAV* pWav, const char* outputFilename, INT sampleRate,
   wav->header.blockAlign = LittleEndian16((SHORT)(numChannels * (bitsPerSample >> 3)));
   wav->header.sampleRate = LittleEndian32(sampleRate);
   wav->header.bytesPerSecond = LittleEndian32(sampleRate * wav->header.blockAlign);
-  FDKstrncpy(wav->header.dataType, "data", 4);
+  mpegh_FDKstrncpy(wav->header.dataType, "data", 4);
   wav->header.dataSize = LittleEndian32(
       0x7fffffff - WAV_HEADER_SIZE - (sizeof(wav->header.riffType) + sizeof(wav->header.riffSize)));
 
   size = WAV_WriteHeader(wav);
 
   if (size != WAV_HEADER_SIZE) {
-    FDKprintfErr("WAV_OutputOpen(): error writing to output file %s\n", outputFilename);
+    mpegh_FDKprintfErr("WAV_OutputOpen(): error writing to output file %s\n", outputFilename);
     goto bail;
   }
 
@@ -633,7 +633,7 @@ INT WAV_OutputOpen(HANDLE_WAV* pWav, const char* outputFilename, INT sampleRate,
 bail:
   if (wav) {
     if (wav->fp) {
-      FDKfclose(wav->fp);
+      mpegh_FDKfclose(wav->fp);
     }
     free(wav);
   }
@@ -680,8 +680,8 @@ INT WAV_OutputWrite(HANDLE_WAV wav, void* sampleBuffer, UINT numberOfSamples, in
   /* Pack samples if required */
   if ((!wavIEEEfloat && bps == nBufBits && bps == nSigBits) ||
       (wavIEEEfloat && bps == nBufBits && nSigBits < 0)) {
-    if (FDKfwrite_EL(sampleBuffer, (bps >> 3), numberOfSamples, wav->fp) != numberOfSamples) {
-      FDKprintfErr("WAV_OutputWrite(): error: unable to write to file %d\n", wav->fp);
+    if (mpegh_FDKfwrite_EL(sampleBuffer, (bps >> 3), numberOfSamples, wav->fp) != numberOfSamples) {
+      mpegh_FDKprintfErr("WAV_OutputWrite(): error: unable to write to file %d\n", wav->fp);
       return -1;
     }
   } else if (!wavIEEEfloat) {
@@ -727,7 +727,7 @@ INT WAV_OutputWrite(HANDLE_WAV wav, void* sampleBuffer, UINT numberOfSamples, in
 
         /* Correct alignment difference between 32 bit data buffer "tmp" and 24 bits to be written.
          */
-        if (!IS_LITTLE_ENDIAN() && bps == 24) {
+        if (!MPEGH_IS_LITTLE_ENDIAN() && bps == 24) {
           shift += 8;
         }
 
@@ -738,9 +738,9 @@ INT WAV_OutputWrite(HANDLE_WAV wav, void* sampleBuffer, UINT numberOfSamples, in
       }
 
       /* Write sample */
-      result = FDKfwrite_EL(&tmp, bps >> 3, 1, wav->fp);
+      result = mpegh_FDKfwrite_EL(&tmp, bps >> 3, 1, wav->fp);
       if (result <= 0) {
-        FDKprintfErr("WAV_OutputWrite(): error: unable to write to file %d\n", wav->fp);
+        mpegh_FDKprintfErr("WAV_OutputWrite(): error: unable to write to file %d\n", wav->fp);
         return -1;
       }
     }
@@ -773,14 +773,14 @@ INT WAV_OutputWrite(HANDLE_WAV wav, void* sampleBuffer, UINT numberOfSamples, in
 
       /* Write sample */
       if (bps == 64) {
-        result = FDKfwrite_EL(&d, 8, 1, wav->fp);
+        result = mpegh_FDKfwrite_EL(&d, 8, 1, wav->fp);
       } else {
         float f = (float)d;
-        result = FDKfwrite_EL(&f, 4, 1, wav->fp);
+        result = mpegh_FDKfwrite_EL(&f, 4, 1, wav->fp);
       }
 
       if (result <= 0) {
-        FDKprintfErr("WAV_OutputWrite(): error: unable to write to file %d\n", wav->fp);
+        mpegh_FDKprintfErr("WAV_OutputWrite(): error: unable to write to file %d\n", wav->fp);
         return -1;
       }
     }
@@ -805,8 +805,8 @@ void WAV_OutputClose(HANDLE_WAV* pWav) {
 
   if (wav->header.ds64Chunk.dataSize64 + WAV_HEADER_SIZE >= (1LL << 32)) {
     /* File is >=4GB --> write RF64 Header */
-    FDKstrncpy(wav->header.riffType, "RF64", 4);
-    FDKstrncpy(wav->header.ds64Chunk.chunkID, "ds64", 4);
+    mpegh_FDKstrncpy(wav->header.riffType, "RF64", 4);
+    mpegh_FDKstrncpy(wav->header.ds64Chunk.chunkID, "ds64", 4);
     wav->header.ds64Chunk.riffSize64 =
         LittleEndian64(wav->header.ds64Chunk.dataSize64 + WAV_HEADER_SIZE -
                        (sizeof(wav->header.riffType) + sizeof(wav->header.riffSize)));
@@ -818,8 +818,8 @@ void WAV_OutputClose(HANDLE_WAV* pWav) {
     wav->header.riffSize = LittleEndian32(0xFFFFFFFF);
   } else {
     /* File is <4GB --> write RIFF Header */
-    FDKstrncpy(wav->header.riffType, "RIFF", 4);
-    FDKstrncpy(wav->header.ds64Chunk.chunkID, "JUNK", 4);
+    mpegh_FDKstrncpy(wav->header.riffType, "RIFF", 4);
+    mpegh_FDKstrncpy(wav->header.ds64Chunk.chunkID, "JUNK", 4);
     wav->header.dataSize = (UINT)(wav->header.ds64Chunk.dataSize64 & 0x00000000FFFFFFFFLL);
     wav->header.riffSize =
         LittleEndian32(wav->header.dataSize + WAV_HEADER_SIZE -
@@ -833,18 +833,18 @@ void WAV_OutputClose(HANDLE_WAV* pWav) {
   }
 
   if (wav->fp != NULL) {
-    if (FDKfseek(wav->fp, 0, FDKSEEK_SET)) {
-      FDKprintf("WAV_OutputClose(): fseek() failed.\n");
+    if (mpegh_FDKfseek(wav->fp, 0, MPEGH_FDKSEEK_SET)) {
+      mpegh_FDKprintf("WAV_OutputClose(): fseek() failed.\n");
     }
 
     size = WAV_WriteHeader(wav);
 
     if (size != WAV_HEADER_SIZE) {
-      FDKprintfErr("WAV_OutputClose(): unable to write header\n");
+      mpegh_FDKprintfErr("WAV_OutputClose(): unable to write header\n");
     }
 
-    if (FDKfclose(wav->fp)) {
-      FDKprintfErr("WAV_OutputClose(): unable to close wav file\n");
+    if (mpegh_FDKfclose(wav->fp)) {
+      mpegh_FDKprintfErr("WAV_OutputClose(): unable to close wav file\n");
     }
     wav->fp = NULL;
   }
diff --git a/src/libUIManager/src/uiManager.cpp b/src/libUIManager/src/uiManager.cpp
index d1d6ad0..0626ebe 100644
--- a/src/libUIManager/src/uiManager.cpp
+++ b/src/libUIManager/src/uiManager.cpp
@@ -375,7 +375,7 @@ static void selectAudioLang(HANDLE_UI_MANAGER hUiManager, UI_STATE* pUiState = N
 
         /* get language priority of member */
         for (prio = 0; prio < NUM_PREF_LANGUAGES; prio++) {
-          if (FDKstrncmp(pGroup->contentData.contentLanguage,
+          if (mpegh_FDKstrncmp(pGroup->contentData.contentLanguage,
                          &pUiState->prefAudioLanguages[prio][0], 3) == 0)
             break;
         }
@@ -1343,11 +1343,11 @@ static void persistenceRestore(HANDLE_UI_MANAGER hUiManager) {
 
 /* create instance */
 INT UI_Manager_Create(HANDLE_UI_MANAGER* phUiManager, INT storeAsiDescriptions) {
-  *phUiManager = (HANDLE_UI_MANAGER)FDKcalloc(1, sizeof(UI_MANAGER));
+  *phUiManager = (HANDLE_UI_MANAGER)mpegh_FDKcalloc(1, sizeof(UI_MANAGER));
   if (*phUiManager == NULL) return UI_MANAGER_OUT_OF_MEMORY;
 
   if (storeAsiDescriptions) {
-    (*phUiManager)->asi.pDescriptions = (ASI_DESCRIPTIONS*)FDKcalloc(1, sizeof(ASI_DESCRIPTIONS));
+    (*phUiManager)->asi.pDescriptions = (ASI_DESCRIPTIONS*)mpegh_FDKcalloc(1, sizeof(ASI_DESCRIPTIONS));
   }
   (*phUiManager)->asi.activeDmxId = INVALID_ID;
   (*phUiManager)->uiState.targetLoudness = UI_MANAGER_USE_DEFAULT_TARGET_LOUDNESS;
@@ -1628,8 +1628,8 @@ INT UI_Manager_Delete(HANDLE_UI_MANAGER* phUiManager) {
   if (*phUiManager && (*phUiManager)->hPersistence)
     persistenceManagerDelete((*phUiManager)->hPersistence);
 
-  if (*phUiManager && (*phUiManager)->asi.pDescriptions) FDKfree((*phUiManager)->asi.pDescriptions);
-  FDKfree(*phUiManager);
+  if (*phUiManager && (*phUiManager)->asi.pDescriptions) mpegh_FDKfree((*phUiManager)->asi.pDescriptions);
+  mpegh_FDKfree(*phUiManager);
   *phUiManager = NULL;
 
   return UI_MANAGER_OK;
diff --git a/src/libUIManager/src/uiPersistence.cpp b/src/libUIManager/src/uiPersistence.cpp
index f49b929..0bb2bea 100644
--- a/src/libUIManager/src/uiPersistence.cpp
+++ b/src/libUIManager/src/uiPersistence.cpp
@@ -175,7 +175,7 @@ static USHORT getKey(HANDLE_UI_PERSISTENCE_MANAGER hPersistence, const UCHAR* uu
     }
 
     /* stop if existing key found */
-    if (FDKmemcmp(keys[keyIdx].uuid, uuid, 16) == 0) break;
+    if (mpegh_FDKmemcmp(keys[keyIdx].uuid, uuid, 16) == 0) break;
 
     if (forWriting) {
       /* if this is the last key, delete it */
@@ -214,7 +214,7 @@ static void deleteKey(HANDLE_UI_PERSISTENCE_MANAGER hPersistence, const UCHAR* u
     if (keys[keyIdx].firstCmdIdx == INVALID_INDEX) return;
 
     /* stop if key found */
-    if (FDKmemcmp(keys[keyIdx].uuid, uuid, 16) == 0) break;
+    if (mpegh_FDKmemcmp(keys[keyIdx].uuid, uuid, 16) == 0) break;
 
     /* go to next key */
     prevKeyIdx = keyIdx;
@@ -332,14 +332,14 @@ static void updateMemory(HANDLE_UI_PERSISTENCE_MANAGER hPersistence) {
 HANDLE_UI_PERSISTENCE_MANAGER persistenceManagerCreate() {
   /* create persistence manager instance */
   HANDLE_UI_PERSISTENCE_MANAGER hPersistence =
-      (HANDLE_UI_PERSISTENCE_MANAGER)FDKcalloc(1, sizeof(UI_PERSISTENCE_MANAGER));
+      (HANDLE_UI_PERSISTENCE_MANAGER)mpegh_FDKcalloc(1, sizeof(UI_PERSISTENCE_MANAGER));
 
   return hPersistence;
 }
 
 /* delete instance */
 void persistenceManagerDelete(HANDLE_UI_PERSISTENCE_MANAGER hPersistence) {
-  FDKfree(hPersistence);
+  mpegh_FDKfree(hPersistence);
 }
 
 /* set memory */
@@ -414,7 +414,7 @@ INT persistenceManagerSetMemory(HANDLE_UI_PERSISTENCE_MANAGER hPersistence, void
   if ((*pVersionID != VERSION_ID) ||
       (*pCRC != calcCRC(persistenceMemory, persistenceMemorySize - sizeof(USHORT)))) {
     /* clear memory */
-    FDKmemset(persistenceMemory, 0xFF, persistenceMemorySize);
+    mpegh_FDKmemset(persistenceMemory, 0xFF, persistenceMemorySize);
 
     /* init keys */
     hPersistence->firstKeyIdx = 0;
@@ -527,7 +527,7 @@ void persistenceManagerSaveCommand(HANDLE_UI_PERSISTENCE_MANAGER hPersistence,
   /* get key */
   keyIdx = getKey(hPersistence, uiAction->uuid, 1);
 
-  FDKmemcpy(hPersistence->keys[keyIdx].uuid, uiAction->uuid, 16);
+  mpegh_FDKmemcpy(hPersistence->keys[keyIdx].uuid, uiAction->uuid, 16);
 
   /* get command index */
   cmdIdx = hPersistence->keys[keyIdx].firstCmdIdx;
@@ -645,7 +645,7 @@ UCHAR persistenceManagerGetCommand(HANDLE_UI_PERSISTENCE_MANAGER hPersistence, c
   /* restore UI action */
   command = &(hPersistence->commands[cmdIdx]);
 
-  FDKmemcpy(uiAction->uuid, hPersistence->keys[keyIdx].uuid, 16);
+  mpegh_FDKmemcpy(uiAction->uuid, hPersistence->keys[keyIdx].uuid, 16);
   uiAction->actionType = command->type;
   uiAction->presentFlags = 0;
 
diff --git a/src/libUIManager/src/uiXml.cpp b/src/libUIManager/src/uiXml.cpp
index dfa7b75..1ccc0a2 100644
--- a/src/libUIManager/src/uiXml.cpp
+++ b/src/libUIManager/src/uiXml.cpp
@@ -156,13 +156,13 @@ static void writeString(UI_MANAGER_XML_WRITER* pWriter, const char* str) {
 
   if (!pWriter->nLeft) return;
 
-  l = FDKstrlen(str);
+  l = mpegh_FDKstrlen(str);
   if (l > pWriter->nLeft) {
     pWriter->nLeft = 0;
     return;
   }
 
-  FDKstrncpy(pWriter->pOut, str, pWriter->nLeft);
+  mpegh_FDKstrncpy(pWriter->pOut, str, pWriter->nLeft);
   pWriter->pOut += l;
   pWriter->nLeft -= l;
 }
@@ -187,7 +187,7 @@ static void writeEscapedString(UI_MANAGER_XML_WRITER* pWriter, const char* str)
 
   if (!pWriter->nLeft) return;
 
-  l = FDKstrlen(str);
+  l = mpegh_FDKstrlen(str);
   for (i = 0; i < l; i++) {
     UINT chars_len;
     const char* chars_pointer;
@@ -228,7 +228,7 @@ static void writeEscapedString(UI_MANAGER_XML_WRITER* pWriter, const char* str)
       pWriter->nLeft = 0;
       return;
     }
-    FDKstrncpy(pWriter->pOut, chars_pointer, chars_len);
+    mpegh_FDKstrncpy(pWriter->pOut, chars_pointer, chars_len);
     pWriter->pOut += chars_len;
     pWriter->nLeft -= chars_len;
   }
@@ -950,7 +950,7 @@ static void writeScene(HANDLE_UI_MANAGER hUiManager, UCHAR shortInfo) {
 
     for (i = 1; i < nSortedGrpIDs; i++) {
       if (sortedGrpIDs[i] == mainDlg) {
-        FDKmemmove(sortedGrpIDs + 1, sortedGrpIDs, i * sizeof(USHORT));
+        mpegh_FDKmemmove(sortedGrpIDs + 1, sortedGrpIDs, i * sizeof(USHORT));
         sortedGrpIDs[0] = mainDlg;
         break;
       }
@@ -1059,7 +1059,7 @@ static UINT findChar(char charToFind, const char* strToSearchIn, UINT lenToSearc
 static UINT findString(const char* strToFind, const char* strToSearchIn, UINT lenToSearchIn) {
   UINT i, j, l;
 
-  l = FDKstrlen(strToFind);
+  l = mpegh_FDKstrlen(strToFind);
 
   if (lenToSearchIn < l) return 0;
 
@@ -1180,8 +1180,8 @@ static void readText(const char* str, char* text) {
 
 /* read boolean */
 static UCHAR readBool(const char* str) {
-  if (FDKstrncmp(str, "true", 4) == 0) return 1;
-  if (FDKstrncmp(str, "false", 4) == 0) return 0;
+  if (mpegh_FDKstrncmp(str, "true", 4) == 0) return 1;
+  if (mpegh_FDKstrncmp(str, "false", 4) == 0) return 0;
   return readInt(str) ? 1 : 0;
 }
 
@@ -1228,7 +1228,7 @@ UINT uiManagerParseXmlAction(const char* xmlIn, UINT xmlInSize, UI_MANAGER_ACTIO
   int i, l = xmlInSize;
   const char *p = xmlIn, *pAttrib;
 
-  FDKmemclear(&pAction->uuid, 16 * sizeof(UCHAR));
+  mpegh_FDKmemclear(&pAction->uuid, 16 * sizeof(UCHAR));
   pAction->actionType = UI_MANAGER_COMMAND_INVALID;
   pAction->paramInt = 0;
   pAction->paramFloat = (FIXP_DBL)0;
diff --git a/src/libgVBAPRenderer/src/gVBAPRenderer.cpp b/src/libgVBAPRenderer/src/gVBAPRenderer.cpp
index 86e00cc..264923b 100644
--- a/src/libgVBAPRenderer/src/gVBAPRenderer.cpp
+++ b/src/libgVBAPRenderer/src/gVBAPRenderer.cpp
@@ -838,7 +838,7 @@ static void gVBAPRenderer_Spread_internal_normalizeVector(FIXP_DBL* vector, int
   FIXP_DBL denom, nrg = 0, tmp;
 
   int shift = 32 - fNormz((FIXP_DBL)(vectorLength - 1));
-  int headroom = getScalefactor(vector, vectorLength);
+  int headroom = mpegh_getScalefactor(vector, vectorLength);
 
   for (n = 0; n < vectorLength; n++) {
     tmp = vector[n] << headroom;
@@ -980,7 +980,7 @@ static void gVBAPRenderer_Spread_renderSpread(HANDLE_GVBAPRENDERER phgVBAPRender
 
   oamSample.spreadAngle = oamSample.spreadHeight = oamSample.spreadDepth = (FIXP_DBL)0;
   oamSample.gain = FL2FXCONST_DBL(1.0 / 8);
-  FDKmemset(outputGainArray, 0, phgVBAPRenderer->numChannels * sizeof(FIXP_DBL));
+  mpegh_FDKmemset(outputGainArray, 0, phgVBAPRenderer->numChannels * sizeof(FIXP_DBL));
 
   /* calculate VBAP gains (assuming spread = 0 for implemented MDAP spread, no downmixing of ghost
    * speakers, gain factor set to 1.0 because gain factor will be applied after spread gains have
@@ -1198,7 +1198,7 @@ int gVBAPRenderer_Open(HANDLE_GVBAPRENDERER* phgVBAPRenderer, int numObjects, in
     return -1;
   }
 
-  tmp = (HANDLE_GVBAPRENDERER)FDKcalloc(1, sizeof(GVBAPRENDERER));
+  tmp = (HANDLE_GVBAPRENDERER)mpegh_FDKcalloc(1, sizeof(GVBAPRENDERER));
   if (!tmp) {
     return -2; /* could not allocate memory */
   }
@@ -1209,8 +1209,8 @@ int gVBAPRenderer_Open(HANDLE_GVBAPRENDERER* phgVBAPRenderer, int numObjects, in
   *phgVBAPRenderer = tmp;
 
   /* allocate memory for speakerlist and fill it with values and save the mapping order */
-  (*phgVBAPRenderer)->speakerSetup.speakerList = (SPEAKER*)FDKmalloc(outChannels * sizeof(SPEAKER));
-  (*phgVBAPRenderer)->speakerSetup.mapping = (int*)FDKmalloc(outChannels * sizeof(int));
+  (*phgVBAPRenderer)->speakerSetup.speakerList = (SPEAKER*)mpegh_FDKmalloc(outChannels * sizeof(SPEAKER));
+  (*phgVBAPRenderer)->speakerSetup.mapping = (int*)mpegh_FDKmalloc(outChannels * sizeof(int));
 
   if ((*phgVBAPRenderer)->speakerSetup.speakerList == NULL ||
       (*phgVBAPRenderer)->speakerSetup.mapping == NULL) {
@@ -1293,14 +1293,14 @@ int gVBAPRenderer_Open(HANDLE_GVBAPRENDERER* phgVBAPRenderer, int numObjects, in
        numLFE)) /* if no downmixMatrix exists then free memory and set pointer to NULL */
   {
     if ((*phgVBAPRenderer)->downmixMatrix != NULL) {
-      fdkFreeMatrix2D((void**)(*phgVBAPRenderer)->downmixMatrix);
+      mpegh_fdkFreeMatrix2D((void**)(*phgVBAPRenderer)->downmixMatrix);
       (*phgVBAPRenderer)->downmixMatrix = NULL;
     }
   }
 
   /* allocate memory for speakerTriplet and fill it with values */
   if (((*phgVBAPRenderer)->speakerSetup.speakerTriplet =
-           (SPEAKERTRIPLET*)FDKmalloc(tL->size * sizeof(SPEAKERTRIPLET))) == NULL) {
+           (SPEAKERTRIPLET*)mpegh_FDKmalloc(tL->size * sizeof(SPEAKERTRIPLET))) == NULL) {
     return -2; /* could not allocate memory */
   }
 
@@ -1341,29 +1341,29 @@ int gVBAPRenderer_Open(HANDLE_GVBAPRENDERER* phgVBAPRenderer, int numObjects, in
   /* Alocate memory for gain cache. Length is number of real speakers including LFE + number of
    * ghosts */
   (*phgVBAPRenderer)->gainCache =
-      (FIXP_DBL*)FDKmalloc((outChannels + numGhosts - numLFE) * sizeof(FIXP_DBL));
+      (FIXP_DBL*)mpegh_FDKmalloc((outChannels + numGhosts - numLFE) * sizeof(FIXP_DBL));
 
   /* Alocate memory for start and end gains. Length is number of real speakers including LFE */
-  (*phgVBAPRenderer)->startGains = (FIXP_DBL**)fdkCallocMatrix2D(
+  (*phgVBAPRenderer)->startGains = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(
       numObjects, (*phgVBAPRenderer)->numChannels,
       sizeof(FIXP_DBL)); /* Dim: objects x (number of output channels) */
-  (*phgVBAPRenderer)->endGains = (FIXP_DBL**)fdkCallocMatrix2D(
+  (*phgVBAPRenderer)->endGains = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(
       numObjects, (*phgVBAPRenderer)->numChannels,
       sizeof(FIXP_DBL)); /* Dim: objects x (number of output channels) */
 
-  (*phgVBAPRenderer)->stepState = (FIXP_DBL**)fdkCallocMatrix2D(
+  (*phgVBAPRenderer)->stepState = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(
       numObjects, (*phgVBAPRenderer)->numChannels,
       sizeof(FIXP_DBL)); /* Dim: objects x (number of output channels) */
-  (*phgVBAPRenderer)->scaleState = (FIXP_DBL**)fdkCallocMatrix2D(
+  (*phgVBAPRenderer)->scaleState = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(
       numObjects, (*phgVBAPRenderer)->numChannels,
       sizeof(FIXP_DBL)); /* Dim: objects x (number of output channels) */
 
   (*phgVBAPRenderer)->startGainsMax =
-      (FIXP_DBL*)FDKmalloc((*phgVBAPRenderer)->numChannels * sizeof(FIXP_DBL));
+      (FIXP_DBL*)mpegh_FDKmalloc((*phgVBAPRenderer)->numChannels * sizeof(FIXP_DBL));
   (*phgVBAPRenderer)->prevGainsMax =
-      (FIXP_DBL*)FDKmalloc((*phgVBAPRenderer)->numChannels * sizeof(FIXP_DBL));
+      (FIXP_DBL*)mpegh_FDKmalloc((*phgVBAPRenderer)->numChannels * sizeof(FIXP_DBL));
   (*phgVBAPRenderer)->OAM_parsed_data =
-      (INT*)FDKcalloc((*phgVBAPRenderer)->numObjects * OAM_NUMBER_MAX_COMPONENTS, sizeof(INT));
+      (INT*)mpegh_FDKcalloc((*phgVBAPRenderer)->numObjects * OAM_NUMBER_MAX_COMPONENTS, sizeof(INT));
   if (((*phgVBAPRenderer)->gainCache == NULL) || ((*phgVBAPRenderer)->startGains == NULL) ||
       ((*phgVBAPRenderer)->endGains == NULL) || ((*phgVBAPRenderer)->stepState == NULL) ||
       ((*phgVBAPRenderer)->scaleState == NULL) || ((*phgVBAPRenderer)->startGainsMax == NULL) ||
@@ -1395,14 +1395,14 @@ int gVBAPRenderer_Open(HANDLE_GVBAPRENDERER* phgVBAPRenderer, int numObjects, in
     }
 
     (*phgVBAPRenderer)->spread_gainArray =
-        (FIXP_DBL*)FDKcalloc(spread_numInvolvedLS, sizeof(FIXP_DBL));
+        (FIXP_DBL*)mpegh_FDKcalloc(spread_numInvolvedLS, sizeof(FIXP_DBL));
     if ((*phgVBAPRenderer)->spread_gainArray == NULL) {
       return -2;
     }
 
     for (i = 0; i < GVBAP_SPREAD_NUM_VSO; i++) {
       (*phgVBAPRenderer)->spread_gainsVSO[i] =
-          (FIXP_DBL*)FDKcalloc(spread_numInvolvedLS, sizeof(FIXP_DBL));
+          (FIXP_DBL*)mpegh_FDKcalloc(spread_numInvolvedLS, sizeof(FIXP_DBL));
       if ((*phgVBAPRenderer)->spread_gainsVSO[i] == NULL) {
         return -2;
       }
@@ -1453,13 +1453,13 @@ int gVBAPRenderer_Open(HANDLE_GVBAPRENDERER* phgVBAPRenderer, int numObjects, in
   }
 
   /* Alocate memory for OAM samples */
-  ((*phgVBAPRenderer)->oamSamples = (OAM_SAMPLE**)FDKcalloc(numOamFrames, sizeof(OAM_SAMPLE*)));
+  ((*phgVBAPRenderer)->oamSamples = (OAM_SAMPLE**)mpegh_FDKcalloc(numOamFrames, sizeof(OAM_SAMPLE*)));
 
   if (!((*phgVBAPRenderer)->oamSamples)) {
     return -2; /* could not allocate memory */
   }
   if (((*phgVBAPRenderer)->oamSamples[0] =
-           (OAM_SAMPLE*)FDKmalloc(numOamFrames * numObjects * sizeof(OAM_SAMPLE))) == NULL) {
+           (OAM_SAMPLE*)mpegh_FDKmalloc(numOamFrames * numObjects * sizeof(OAM_SAMPLE))) == NULL) {
     return -2; /* could not allocate memory */
   }
   for (i = 1; i < numOamFrames; i++) {
@@ -1484,12 +1484,12 @@ int gVBAPRenderer_Open(HANDLE_GVBAPRENDERER* phgVBAPRenderer, int numObjects, in
 
   /* CONCEALMENT */
   if (((*phgVBAPRenderer)->oamSamplesValid =
-           (OAM_SAMPLE**)FDKcalloc(numOamFrames, sizeof(OAM_SAMPLE*))) == NULL) {
+           (OAM_SAMPLE**)mpegh_FDKcalloc(numOamFrames, sizeof(OAM_SAMPLE*))) == NULL) {
     return -2; /* could not allocate memory */
   }
 
   if (((*phgVBAPRenderer)->oamSamplesValid[0] =
-           (OAM_SAMPLE*)FDKmalloc(numOamFrames * numObjects * sizeof(OAM_SAMPLE))) == NULL) {
+           (OAM_SAMPLE*)mpegh_FDKmalloc(numOamFrames * numObjects * sizeof(OAM_SAMPLE))) == NULL) {
     return -2; /* could not allocate memory */
   }
   for (i = 1; i < numOamFrames; i++) {
@@ -1677,7 +1677,7 @@ int gVBAPRenderer_RenderFrame_Time(HANDLE_GVBAPRENDERER RESTRICT hgVBAPRenderer,
 
       mappedChannel = hgVBAPRenderer->speakerSetup.mapping[channel];
       C_AALLOC_SCRATCH_START(outputCache, FIXP_DBL, GVBAPRENDERER_MAX_FRAMELENGTH)
-      FDKmemclear(outputCache, length * sizeof(FIXP_DBL));
+      mpegh_FDKmemclear(outputCache, length * sizeof(FIXP_DBL));
 
       tmp = fMax(hgVBAPRenderer->startGainsMax[channel], endGainsMax[channel]);
       maxGain = fMax(tmp, hgVBAPRenderer->prevGainsMax[channel]);
@@ -1783,16 +1783,16 @@ int gVBAPRenderer_RenderFrame_Time(HANDLE_GVBAPRENDERER RESTRICT hgVBAPRenderer,
 #endif
 #ifdef DEBUG_gVBAPRenderer_RenderFrame_Time_func1
         INT stop_clock = FDKclock();
-        FDKprintf("gVBAPRenderer_RenderFrame_Time_func1: %d  length=%d  s=%d  s1=%d\n",
+        mpegh_FDKprintf("gVBAPRenderer_RenderFrame_Time_func1: %d  length=%d  s=%d  s1=%d\n",
                   stop_clock - start_clock, length, s, s1);
         for (int sample = 0; sample < length; sample += 4) {
-          FDKprintf("0x%08X 0x%08X 0x%08X 0x%08X smp=%d 0x%08X 0x%08X 0x%08X 0x%08X\n",
+          mpegh_FDKprintf("0x%08X 0x%08X 0x%08X 0x%08X smp=%d 0x%08X 0x%08X 0x%08X 0x%08X\n",
                     outputCache[sample + 0], outputCache[sample + 1], outputCache[sample + 2],
                     outputCache[sample + 3], sample, pIn[sample + 0], pIn[sample + 1],
                     pIn[sample + 2], pIn[sample + 3]);
         }
-        FDKprintf("scale: 0x%08X\n", hgVBAPRenderer->scaleState[object][channel]);
-        FDKprintf("step:  0x%08X\n", hgVBAPRenderer->stepState[object][channel]);
+        mpegh_FDKprintf("scale: 0x%08X\n", hgVBAPRenderer->scaleState[object][channel]);
+        mpegh_FDKprintf("step:  0x%08X\n", hgVBAPRenderer->stepState[object][channel]);
         ;
 #endif
       }
@@ -1822,9 +1822,9 @@ int gVBAPRenderer_RenderFrame_Time(HANDLE_GVBAPRENDERER RESTRICT hgVBAPRenderer,
 #endif
 #ifdef DEBUG_gVBAPRenderer_RenderFrame_Time_func2
       INT stop_clock = FDKclock();
-      FDKprintf("gVBAPRenderer_RenderFrame_Time_func2: %d  s2=%d\n", stop_clock - start_clock, s2);
+      mpegh_FDKprintf("gVBAPRenderer_RenderFrame_Time_func2: %d  s2=%d\n", stop_clock - start_clock, s2);
       for (int sample = 0; sample < length; sample += 4) {
-        FDKprintf("0x%08X 0x%08X 0x%08X 0x%08X smp=%d 0x%08X 0x%08X 0x%08X 0x%08X\n",
+        mpegh_FDKprintf("0x%08X 0x%08X 0x%08X 0x%08X smp=%d 0x%08X 0x%08X 0x%08X 0x%08X\n",
                   pOut[sample + 0], pOut[sample + 1], pOut[sample + 2], pOut[sample + 3], sample,
                   outputCache[sample + 0], outputCache[sample + 1], outputCache[sample + 2],
                   outputCache[sample + 3]);
@@ -1842,63 +1842,63 @@ int gVBAPRenderer_RenderFrame_Time(HANDLE_GVBAPRENDERER RESTRICT hgVBAPRenderer,
 
 int gVBAPRenderer_Close(HANDLE_GVBAPRENDERER hgVBAPRenderer) {
   /* free start and end gain memory */
-  fdkFreeMatrix2D((void**)hgVBAPRenderer->startGains);
-  fdkFreeMatrix2D((void**)hgVBAPRenderer->endGains);
+  mpegh_fdkFreeMatrix2D((void**)hgVBAPRenderer->startGains);
+  mpegh_fdkFreeMatrix2D((void**)hgVBAPRenderer->endGains);
 
-  fdkFreeMatrix2D((void**)hgVBAPRenderer->stepState);
-  fdkFreeMatrix2D((void**)hgVBAPRenderer->scaleState);
+  mpegh_fdkFreeMatrix2D((void**)hgVBAPRenderer->stepState);
+  mpegh_fdkFreeMatrix2D((void**)hgVBAPRenderer->scaleState);
 
   /* free maximum start gain memory */
-  FDKfree(hgVBAPRenderer->startGainsMax);
+  mpegh_FDKfree(hgVBAPRenderer->startGainsMax);
 
   /* free maximum previous gain memory */
-  FDKfree(hgVBAPRenderer->prevGainsMax);
+  mpegh_FDKfree(hgVBAPRenderer->prevGainsMax);
 
   /* free OAM parsed data */
-  FDKfree(hgVBAPRenderer->OAM_parsed_data);
+  mpegh_FDKfree(hgVBAPRenderer->OAM_parsed_data);
 
   /* free gain cache */
-  FDKfree(hgVBAPRenderer->gainCache);
+  mpegh_FDKfree(hgVBAPRenderer->gainCache);
 
   /* free speaker triplet */
-  FDKfree(hgVBAPRenderer->speakerSetup.speakerTriplet);
+  mpegh_FDKfree(hgVBAPRenderer->speakerSetup.speakerTriplet);
 
   /* free speaker list */
-  FDKfree(hgVBAPRenderer->speakerSetup.speakerList);
+  mpegh_FDKfree(hgVBAPRenderer->speakerSetup.speakerList);
 
   /* free speaker mapping array */
-  FDKfree(hgVBAPRenderer->speakerSetup.mapping);
+  mpegh_FDKfree(hgVBAPRenderer->speakerSetup.mapping);
 
   /* free downmixMatrix */
   if (hgVBAPRenderer->downmixMatrix != NULL) {
-    fdkFreeMatrix2D((void**)hgVBAPRenderer->downmixMatrix);
+    mpegh_fdkFreeMatrix2D((void**)hgVBAPRenderer->downmixMatrix);
     hgVBAPRenderer->downmixMatrix = NULL;
   }
 
   if (hgVBAPRenderer->oamSamples) {
     if (hgVBAPRenderer->oamSamples[0]) {
-      FDKfree(hgVBAPRenderer->oamSamples[0]);
+      mpegh_FDKfree(hgVBAPRenderer->oamSamples[0]);
     }
-    FDKfree(hgVBAPRenderer->oamSamples);
+    mpegh_FDKfree(hgVBAPRenderer->oamSamples);
   }
   if (hgVBAPRenderer->oamSamplesValid) {
     if (hgVBAPRenderer->oamSamplesValid[0]) {
-      FDKfree(hgVBAPRenderer->oamSamplesValid[0]);
+      mpegh_FDKfree(hgVBAPRenderer->oamSamplesValid[0]);
     }
-    FDKfree(hgVBAPRenderer->oamSamplesValid);
+    mpegh_FDKfree(hgVBAPRenderer->oamSamplesValid);
   }
 
   for (int i = 0; i < GVBAP_SPREAD_NUM_VSO; i++) {
     if (hgVBAPRenderer->spread_gainsVSO[i] != NULL) {
-      FDKfree(hgVBAPRenderer->spread_gainsVSO[i]);
+      mpegh_FDKfree(hgVBAPRenderer->spread_gainsVSO[i]);
     }
   }
   if (hgVBAPRenderer->spread_gainArray != NULL) {
-    FDKfree(hgVBAPRenderer->spread_gainArray);
+    mpegh_FDKfree(hgVBAPRenderer->spread_gainArray);
   }
 
   /* free VBAP handle */
-  FDKfree(hgVBAPRenderer);
+  mpegh_FDKfree(hgVBAPRenderer);
 
   return 0;
 }
diff --git a/src/libgVBAPRenderer/src/quickHull.cpp b/src/libgVBAPRenderer/src/quickHull.cpp
index d874aca..f6c3be9 100644
--- a/src/libgVBAPRenderer/src/quickHull.cpp
+++ b/src/libgVBAPRenderer/src/quickHull.cpp
@@ -196,7 +196,7 @@ int qh_sphere_triangulation(int cicpIndex, vertexList* vL, triangleList* tL,
   tri.index[2] = pentagon[4];
   addTriangleToList(tL, tri);
 
-  positionIndexList = (surroundList*)FDKcalloc(vL->size, sizeof(surroundList));
+  positionIndexList = (surroundList*)mpegh_FDKcalloc(vL->size, sizeof(surroundList));
 
   if (!positionIndexList) {
     /*memory allocation error*/
@@ -227,7 +227,7 @@ int qh_sphere_triangulation(int cicpIndex, vertexList* vL, triangleList* tL,
       if (hTable) {
         /* copy downmix matrix from imaginary speaker table */
         *downmixMatrix =
-            (FIXP_DBL**)fdkCallocMatrix2D(hTable->numRow, hTable->numCol, sizeof(FIXP_DBL));
+            (FIXP_DBL**)mpegh_fdkCallocMatrix2D(hTable->numRow, hTable->numCol, sizeof(FIXP_DBL));
         if (*downmixMatrix == NULL) {
           /*memory allocation error*/
           err = 1;
@@ -244,12 +244,12 @@ int qh_sphere_triangulation(int cicpIndex, vertexList* vL, triangleList* tL,
     }
 
     if (!(*downmixMatrix)) {
-      *downmixMatrix = (FIXP_DBL**)fdkCallocMatrix2D(
+      *downmixMatrix = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(
           realSpeaker, vL->size, sizeof(FIXP_DBL)); /* Dim: realSpeaker x (realSpeaker + ghost) */
-      adjacencyMatrix = (FIXP_DBL**)fdkCallocMatrix2D(
+      adjacencyMatrix = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(
           vL->size, vL->size,
           sizeof(FIXP_DBL)); /* Dim: (realSpeaker + ghost) x (realSpeaker + ghost) */
-      mSquare = (FIXP_DBL**)fdkCallocMatrix2D(
+      mSquare = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(
           vL->size, vL->size,
           sizeof(FIXP_DBL)); /* Dim: (realSpeaker + ghost) x (realSpeaker + ghost) */
       *downmixMatrixNumRows = realSpeaker;
@@ -349,10 +349,10 @@ int qh_sphere_triangulation(int cicpIndex, vertexList* vL, triangleList* tL,
     if (downmixMatrixSuperset) {
       /* multiply superset downmix matrix with imaginary speaker downmix matrix */
       FIXP_DBL** downmixMatrixImaginaries = *downmixMatrix;
-      *downmixMatrix = (FIXP_DBL**)fdkCallocMatrix2D(subsetSpeaker, vL->size, sizeof(FIXP_DBL));
+      *downmixMatrix = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(subsetSpeaker, vL->size, sizeof(FIXP_DBL));
       if (*downmixMatrix == NULL) {
         /*memory allocation error*/
-        fdkFreeMatrix2D((void**)downmixMatrixImaginaries);
+        mpegh_fdkFreeMatrix2D((void**)downmixMatrixImaginaries);
         err = 1;
         goto bail;
       }
@@ -370,14 +370,14 @@ int qh_sphere_triangulation(int cicpIndex, vertexList* vL, triangleList* tL,
         }
       }
 
-      fdkFreeMatrix2D((void**)downmixMatrixImaginaries);
+      mpegh_fdkFreeMatrix2D((void**)downmixMatrixImaginaries);
     }
   }
 bail:
-  fdkFreeMatrix2D((void**)downmixMatrixSuperset);
-  fdkFreeMatrix2D((void**)adjacencyMatrix);
-  fdkFreeMatrix2D((void**)mSquare);
-  FDKfree(positionIndexList);
+  mpegh_fdkFreeMatrix2D((void**)downmixMatrixSuperset);
+  mpegh_fdkFreeMatrix2D((void**)adjacencyMatrix);
+  mpegh_fdkFreeMatrix2D((void**)mSquare);
+  mpegh_FDKfree(positionIndexList);
 
   return err;
 }
@@ -677,10 +677,10 @@ int add_imaginary_speakers(vertexList* vL, int* pentagon) {
   for (i = 0; i < numberOfRealSpeaker; i++) {
     if ((FIXP_DBL)fAbs(vL->element[i].sph.ele) < thresh) surroundListSize++;
   }
-  aziSurroundList = (surroundList*)FDKmalloc(
+  aziSurroundList = (surroundList*)mpegh_FDKmalloc(
       (surroundListSize + 2) *
       sizeof(surroundList)); /* a maximum number of 2 surround speaker can be added */
-  angleDiffList = (FIXP_DBL*)FDKmalloc((surroundListSize) * sizeof(FIXP_DBL));
+  angleDiffList = (FIXP_DBL*)mpegh_FDKmalloc((surroundListSize) * sizeof(FIXP_DBL));
 
   if (!aziSurroundList || !angleDiffList) {
     err = 1;
@@ -769,8 +769,8 @@ int add_imaginary_speakers(vertexList* vL, int* pentagon) {
   pentagon[4] = aziSurroundList[k].index;
 
 bail:
-  FDKfree(aziSurroundList);
-  FDKfree(angleDiffList);
+  mpegh_FDKfree(aziSurroundList);
+  mpegh_FDKfree(angleDiffList);
 
   return err;
 }
@@ -821,7 +821,7 @@ static CICP2GEOMETRY_ERROR augment_setup_to_superset(int* cicpIdx, vertexList* v
         }
       }
 
-      *downmix_mat = (FIXP_DBL**)fdkCallocMatrix2D(hTable->nSpeakersSubSet,
+      *downmix_mat = (FIXP_DBL**)mpegh_fdkCallocMatrix2D(hTable->nSpeakersSubSet,
                                                    hTable->nSpeakersSuperSet, sizeof(FIXP_DBL));
       if (*downmix_mat == NULL) {
         return CICP2GEOMETRY_ALLOC_ERROR;
diff --git a/src/libgVBAPRenderer/src/vbap_core.cpp b/src/libgVBAPRenderer/src/vbap_core.cpp
index c251c80..9ab3622 100644
--- a/src/libgVBAPRenderer/src/vbap_core.cpp
+++ b/src/libgVBAPRenderer/src/vbap_core.cpp
@@ -204,7 +204,7 @@ void calculateVbap(HANDLE_GVBAPRENDERER hgVBAPRenderer, OAM_SAMPLE source, FIXP_
 
   /* Check whether a downmix matrix for ghost speaker exists or not */
   if ((hgVBAPRenderer->downmixMatrix != NULL) && !noDownmix) {
-    FDKmemclear(final_gains, numSpeaker * sizeof(FIXP_DBL));
+    mpegh_FDKmemclear(final_gains, numSpeaker * sizeof(FIXP_DBL));
 
     /* Downmix ghost speakers */
     for (row = 0; row < numSpeaker; row++) {
@@ -219,7 +219,7 @@ void calculateVbap(HANDLE_GVBAPRENDERER hgVBAPRenderer, OAM_SAMPLE source, FIXP_
     }
   } else {
     numSpeaker = hgVBAPRenderer->numChannels - hgVBAPRenderer->numLFE + hgVBAPRenderer->numGhosts;
-    FDKmemclear(final_gains, numSpeaker * sizeof(FIXP_DBL));
+    mpegh_FDKmemclear(final_gains, numSpeaker * sizeof(FIXP_DBL));
 
     for (row = 0; row < numSpeaker; row++) {
       final_gains[row] = hgVBAPRenderer->gainCache[row];
@@ -248,7 +248,7 @@ void calculateVbap(HANDLE_GVBAPRENDERER hgVBAPRenderer, OAM_SAMPLE source, FIXP_
 
 void calculateVbapGain(HANDLE_GVBAPRENDERER hgVBAPRenderer, OAM_SAMPLE source) {
   /* clear gain cache in handler */
-  FDKmemclear(hgVBAPRenderer->gainCache,
+  mpegh_FDKmemclear(hgVBAPRenderer->gainCache,
               (hgVBAPRenderer->numChannels + hgVBAPRenderer->numGhosts - hgVBAPRenderer->numLFE) *
                   sizeof(FIXP_DBL));
 
@@ -402,7 +402,7 @@ void calcSpreadVectors(HANDLE_GVBAPRENDERER hgVBAPRenderer, OAM_SAMPLE source) {
   /* New exponent will be 2 */
   spreadAngle = fMult(spreadAngle, (FIXP_DBL)1686629713); /* Multiply by pi/4 */
 
-  fixp_cos_sin(spreadAngle, 2, &cos_spread, &sin_spread);
+  mpegh_fixp_cos_sin(spreadAngle, 2, &cos_spread, &sin_spread);
   inv_sin_spread = invFixp(sin_spread, &exp);
 
   summand = fMultDiv2(cos_spread, inv_sin_spread) * p1;
